/* This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
 * KreMLin invocation: /home/mpolubel/work/everest/kremlin/krml -add-include "extracted/TestLib.h" /c/testlib.c -skip-compilation -no-prefix Hacl.Test.CSHAKE -no-prefix Hacl.Impl.SHA3 -no-prefix Hacl.SHA3 -bundle Lib.* -bundle Spec.* -bundle C=C.Endianness -bundle Hacl.SHA3=Hacl.Impl.*,Hacl.SHA3 -library C,FStar -drop LowStar,Spec,Prims,Lib,C.Loops.* -add-include "c/Lib_PQ_Print.h" -tmpdir sha3-c .output/prims.krml .output/FStar_Pervasives_Native.krml .output/FStar_Pervasives.krml .output/FStar_Mul.krml .output/FStar_Squash.krml .output/FStar_Classical.krml .output/FStar_Preorder.krml .output/FStar_List_Tot_Base.krml .output/FStar_List_Tot_Properties.krml .output/FStar_StrongExcludedMiddle.krml .output/FStar_List_Tot.krml .output/FStar_Seq_Base.krml .output/FStar_Seq_Properties.krml .output/FStar_Seq.krml .output/FStar_Math_Lib.krml .output/FStar_Math_Lemmas.krml .output/FStar_BitVector.krml .output/FStar_UInt.krml .output/FStar_UInt32.krml .output/FStar_Int.krml .output/FStar_Int16.krml .output/FStar_Ghost.krml .output/FStar_ErasedLogic.krml .output/FStar_UInt64.krml .output/FStar_FunctionalExtensionality.krml .output/FStar_Set.krml .output/FStar_PropositionalExtensionality.krml .output/FStar_PredicateExtensionality.krml .output/FStar_TSet.krml .output/FStar_Monotonic_Heap.krml .output/FStar_Heap.krml .output/FStar_Map.krml .output/FStar_Monotonic_HyperHeap.krml .output/FStar_Monotonic_HyperStack.krml .output/FStar_HyperStack.krml .output/FStar_Monotonic_Witnessed.krml .output/FStar_HyperStack_ST.krml .output/FStar_HyperStack_All.krml .output/FStar_Int64.krml .output/FStar_Int63.krml .output/FStar_Int32.krml .output/FStar_Int8.krml .output/FStar_UInt63.krml .output/FStar_UInt16.krml .output/FStar_UInt8.krml .output/FStar_Int_Cast.krml .output/FStar_UInt128.krml .output/Lib_IntTypes.krml .output/Lib_RawIntTypes.krml .output/Spec_Loops.krml .output/FStar_Universe.krml .output/FStar_GSet.krml .output/FStar_ModifiesGen.krml .output/LowStar_Monotonic_Buffer.krml .output/LowStar_Buffer.krml .output/LowStar_BufferOps.krml .output/C_Loops.krml .output/Lib_Loops.krml .output/Lib_Sequence.krml .output/Lib_Sequence_Lemmas.krml .output/Lib_ByteSequence.krml .output/Lib_PQ_Buffer.krml .output/FStar_Kremlin_Endianness.krml .output/C_Endianness.krml .output/FStar_Exn.krml .output/FStar_ST.krml .output/FStar_All.krml .output/FStar_List.krml .output/C.krml .output/Lib_Endianness.krml .output/FStar_Char.krml .output/FStar_String.krml .output/LowStar_Modifies.krml .output/C_String.krml .output/Hacl_Impl_SHA3.krml .output/Hacl_SHA3.krml .output/Hacl_Test_CSHAKE.krml
 * F* version: f38903cb
 * KreMLin version: 43a44e14
 */

#include "Hacl_SHA3.h"

inline static bool lfsr86540(uint8_t *lfsr)
{
  uint8_t lfsr0 = lfsr[0U];
  uint8_t lfsr1 = lfsr0 & (uint8_t)1U;
  bool result = lfsr1 != (uint8_t)0U;
  uint8_t lfsr_ = lfsr0 << (uint32_t)1U;
  uint8_t lfsr_1;
  if ((lfsr0 & (uint8_t)0x80U) != (uint8_t)0U)
    lfsr_1 = lfsr_ ^ (uint8_t)0x71U;
  else
    lfsr_1 = lfsr_;
  lfsr[0U] = lfsr_1;
  return result;
}

inline static void state_theta(uint64_t *s)
{
  uint64_t _C[5U] = { 0U };
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)5U; i = i + (uint32_t)1U)
    _C[i] =
      s[i
      + (uint32_t)0U]
      ^ s[i + (uint32_t)5U] ^ s[i + (uint32_t)10U] ^ s[i + (uint32_t)15U] ^ s[i + (uint32_t)20U];
  for (uint32_t i0 = (uint32_t)0U; i0 < (uint32_t)5U; i0 = i0 + (uint32_t)1U)
  {
    uint64_t uu____0 = _C[(i0 + (uint32_t)1U) % (uint32_t)5U];
    uint64_t
    _D =
      _C[(i0 + (uint32_t)4U)
      % (uint32_t)5U]
      ^ (uu____0 << (uint32_t)1U | uu____0 >> (uint32_t)63U);
    for (uint32_t i = (uint32_t)0U; i < (uint32_t)5U; i = i + (uint32_t)1U)
      s[i0 + (uint32_t)5U * i] = s[i0 + (uint32_t)5U * i] ^ _D;
  }
}

inline static void state_permute1(uint64_t *s, uint8_t *lfsr)
{
  state_theta(s);
  uint32_t x = (uint32_t)1U;
  uint32_t y = (uint32_t)0U;
  uint64_t current = s[1U];
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)24U; i = i + (uint32_t)1U)
  {
    uint32_t x0 = x;
    uint32_t y0 = y;
    uint64_t current0 = current;
    uint32_t r = (i + (uint32_t)1U) * (i + (uint32_t)2U) / (uint32_t)2U % (uint32_t)64U;
    uint32_t _Y = ((uint32_t)2U * x0 + (uint32_t)3U * y0) % (uint32_t)5U;
    uint64_t temp = s[y0 + (uint32_t)5U * _Y];
    s[y0 + (uint32_t)5U * _Y] = current0 << r | current0 >> (uint32_t)64U - r;
    x = y0;
    y = _Y;
    current = temp;
  }
  uint64_t temp[25U] = { 0U };
  memcpy(temp, s, (uint32_t)25U * sizeof s[0U]);
  for (uint32_t i0 = (uint32_t)0U; i0 < (uint32_t)5U; i0 = i0 + (uint32_t)1U)
    for (uint32_t i = (uint32_t)0U; i < (uint32_t)5U; i = i + (uint32_t)1U)
      s[i + (uint32_t)5U * i0] =
        temp[i
        + (uint32_t)5U * i0]
        ^
          ~temp[(i + (uint32_t)1U)
          % (uint32_t)5U
          + (uint32_t)5U * i0]
          & temp[(i + (uint32_t)2U) % (uint32_t)5U + (uint32_t)5U * i0];
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)7U; i = i + (uint32_t)1U)
  {
    uint32_t bitPosition = ((uint32_t)1U << i) - (uint32_t)1U;
    bool result = lfsr86540(lfsr);
    if (result)
      s[0U] = s[0U] ^ (uint64_t)1U << bitPosition;
  }
}

inline static void state_permute(uint64_t *s)
{
  uint8_t lfsr = (uint8_t)0x01U;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)24U; i = i + (uint32_t)1U)
    state_permute1(s, &lfsr);
}

inline static void loadState(uint32_t rateInBytes, uint8_t *input, uint64_t *s)
{
  uint8_t block[200U] = { 0U };
  memcpy(block, input, rateInBytes * sizeof input[0U]);
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)25U; i = i + (uint32_t)1U)
  {
    uint64_t uu____0 = s[i];
    uint64_t u = load64_le(block + i * (uint32_t)8U);
    s[i] = uu____0 ^ u;
  }
}

inline static void storeState(uint32_t rateInBytes, uint64_t *s, uint8_t *res)
{
  uint8_t block[200U] = { 0U };
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)25U; i = i + (uint32_t)1U)
    store64_le(block + i * (uint32_t)8U, s[i]);
  memcpy(res, block, rateInBytes * sizeof block[0U]);
}

inline static void
absorb(
  uint64_t *s,
  uint32_t rateInBytes,
  uint32_t inputByteLen,
  uint8_t *input,
  uint8_t delimitedSuffix
)
{
  uint32_t n1 = inputByteLen / rateInBytes;
  uint32_t rem1 = inputByteLen % rateInBytes;
  for (uint32_t i = (uint32_t)0U; i < n1; i = i + (uint32_t)1U)
  {
    loadState(rateInBytes, input + i * rateInBytes, s);
    state_permute(s);
  }
  KRML_CHECK_SIZE(sizeof (uint8_t), rateInBytes);
  uint8_t lastBlock[rateInBytes];
  memset(lastBlock, 0U, rateInBytes * sizeof lastBlock[0U]);
  uint32_t rem2 = inputByteLen % rateInBytes;
  uint8_t *last1 = input + inputByteLen - rem2;
  memcpy(lastBlock, last1, rem2 * sizeof last1[0U]);
  lastBlock[rem2] = delimitedSuffix;
  loadState(rateInBytes, lastBlock, s);
  if (!((delimitedSuffix & (uint8_t)0x80U) == (uint8_t)0U) && rem1 == rateInBytes - (uint32_t)1U)
    state_permute(s);
  KRML_CHECK_SIZE(sizeof (uint8_t), rateInBytes);
  uint8_t nextBlock[rateInBytes];
  memset(nextBlock, 0U, rateInBytes * sizeof nextBlock[0U]);
  nextBlock[rateInBytes - (uint32_t)1U] = (uint8_t)0x80U;
  loadState(rateInBytes, nextBlock, s);
  state_permute(s);
}

inline static void
squeeze(uint64_t *s, uint32_t rateInBytes, uint32_t outputByteLen, uint8_t *output)
{
  uint32_t outBlocks = outputByteLen / rateInBytes;
  uint32_t remOut = outputByteLen % rateInBytes;
  for (uint32_t i = (uint32_t)0U; i < outBlocks; i = i + (uint32_t)1U)
  {
    storeState(rateInBytes, s, output + i * rateInBytes);
    state_permute(s);
  }
  storeState(remOut, s, output + outputByteLen - remOut);
}

static void
keccak(
  uint32_t rate,
  uint32_t capacity,
  uint32_t inputByteLen,
  uint8_t *input,
  uint8_t delimitedSuffix,
  uint32_t outputByteLen,
  uint8_t *output
)
{
  uint32_t rateInBytes = rate / (uint32_t)8U;
  uint64_t s[25U] = { 0U };
  absorb(s, rateInBytes, inputByteLen, input, delimitedSuffix);
  squeeze(s, rateInBytes, outputByteLen, output);
}

void shake128_hacl(uint32_t inputByteLen, uint8_t *input, uint32_t outputByteLen, uint8_t *output)
{
  keccak((uint32_t)1344U,
    (uint32_t)256U,
    inputByteLen,
    input,
    (uint8_t)0x1FU,
    outputByteLen,
    output);
}

void shake256_hacl(uint32_t inputByteLen, uint8_t *input, uint32_t outputByteLen, uint8_t *output)
{
  keccak((uint32_t)1088U,
    (uint32_t)512U,
    inputByteLen,
    input,
    (uint8_t)0x1FU,
    outputByteLen,
    output);
}

void sha3_224(uint32_t inputByteLen, uint8_t *input, uint8_t *output)
{
  keccak((uint32_t)1152U,
    (uint32_t)448U,
    inputByteLen,
    input,
    (uint8_t)0x06U,
    (uint32_t)28U,
    output);
}

void sha3_256(uint32_t inputByteLen, uint8_t *input, uint8_t *output)
{
  keccak((uint32_t)1088U,
    (uint32_t)512U,
    inputByteLen,
    input,
    (uint8_t)0x06U,
    (uint32_t)32U,
    output);
}

void sha3_384(uint32_t inputByteLen, uint8_t *input, uint8_t *output)
{
  keccak((uint32_t)832U,
    (uint32_t)768U,
    inputByteLen,
    input,
    (uint8_t)0x06U,
    (uint32_t)48U,
    output);
}

void sha3_512(uint32_t inputByteLen, uint8_t *input, uint8_t *output)
{
  keccak((uint32_t)576U,
    (uint32_t)1024U,
    inputByteLen,
    input,
    (uint8_t)0x06U,
    (uint32_t)64U,
    output);
}

void
cshake128_frodo(
  uint32_t input_len,
  uint8_t *input,
  uint16_t cstm,
  uint32_t output_len,
  uint8_t *output
)
{
  uint64_t s[25U] = { 0U };
  s[0U] = (uint64_t)0x10010001a801U | (uint64_t)cstm << (uint32_t)48U;
  state_permute(s);
  absorb(s, (uint32_t)168U, input_len, input, (uint8_t)0x04U);
  squeeze(s, (uint32_t)168U, output_len, output);
}

void
cshake256_frodo(
  uint32_t input_len,
  uint8_t *input,
  uint16_t cstm,
  uint32_t output_len,
  uint8_t *output
)
{
  uint64_t s[25U] = { 0U };
  s[0U] = (uint64_t)0x100100018801U | (uint64_t)cstm << (uint32_t)48U;
  state_permute(s);
  absorb(s, (uint32_t)136U, input_len, input, (uint8_t)0x04U);
  squeeze(s, (uint32_t)136U, output_len, output);
}

