/* This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
 * KreMLin invocation: /home/mpolubel/work/everest/kremlin/krml -add-include "extracted/TestLib.h" /c/testlib.c -skip-compilation -no-prefix Hacl.Test.CSHAKE -no-prefix Hacl.Impl.SHA3 -no-prefix Hacl.SHA3 -bundle Lib.* -bundle Spec.* -bundle C=C.Endianness -bundle Hacl.SHA3=Hacl.Impl.*,Hacl.SHA3 -library C,FStar -drop LowStar,Spec,Prims,Lib,C.Loops.* -add-include "c/Lib_PQ_Print.h" -tmpdir sha3-c .output/prims.krml .output/FStar_Pervasives_Native.krml .output/FStar_Pervasives.krml .output/FStar_Mul.krml .output/FStar_Squash.krml .output/FStar_Classical.krml .output/FStar_Preorder.krml .output/FStar_List_Tot_Base.krml .output/FStar_List_Tot_Properties.krml .output/FStar_StrongExcludedMiddle.krml .output/FStar_List_Tot.krml .output/FStar_Seq_Base.krml .output/FStar_Seq_Properties.krml .output/FStar_Seq.krml .output/FStar_Math_Lib.krml .output/FStar_Math_Lemmas.krml .output/FStar_BitVector.krml .output/FStar_UInt.krml .output/FStar_UInt32.krml .output/FStar_Int.krml .output/FStar_Int16.krml .output/FStar_Ghost.krml .output/FStar_ErasedLogic.krml .output/FStar_UInt64.krml .output/FStar_FunctionalExtensionality.krml .output/FStar_Set.krml .output/FStar_PropositionalExtensionality.krml .output/FStar_PredicateExtensionality.krml .output/FStar_TSet.krml .output/FStar_Monotonic_Heap.krml .output/FStar_Heap.krml .output/FStar_Map.krml .output/FStar_Monotonic_HyperHeap.krml .output/FStar_Monotonic_HyperStack.krml .output/FStar_HyperStack.krml .output/FStar_Monotonic_Witnessed.krml .output/FStar_HyperStack_ST.krml .output/FStar_HyperStack_All.krml .output/FStar_Int64.krml .output/FStar_Int63.krml .output/FStar_Int32.krml .output/FStar_Int8.krml .output/FStar_UInt63.krml .output/FStar_UInt16.krml .output/FStar_UInt8.krml .output/FStar_Int_Cast.krml .output/FStar_UInt128.krml .output/Lib_IntTypes.krml .output/Lib_RawIntTypes.krml .output/Spec_Loops.krml .output/FStar_Universe.krml .output/FStar_GSet.krml .output/FStar_ModifiesGen.krml .output/LowStar_Monotonic_Buffer.krml .output/LowStar_Buffer.krml .output/LowStar_BufferOps.krml .output/C_Loops.krml .output/Lib_Loops.krml .output/Lib_Sequence.krml .output/Lib_Sequence_Lemmas.krml .output/Lib_ByteSequence.krml .output/Lib_PQ_Buffer.krml .output/FStar_Kremlin_Endianness.krml .output/C_Endianness.krml .output/FStar_Exn.krml .output/FStar_ST.krml .output/FStar_All.krml .output/FStar_List.krml .output/C.krml .output/Lib_Endianness.krml .output/FStar_Char.krml .output/FStar_String.krml .output/LowStar_Modifies.krml .output/C_String.krml .output/Hacl_Impl_SHA3.krml .output/Hacl_SHA3.krml .output/Hacl_Test_CSHAKE.krml
 * F* version: f38903cb
 * KreMLin version: 43a44e14
 */

#include "Hacl_SHA3.h"

#if defined(_MSC_VER)
#define SHA3_CONST(x) x
#else
#define SHA3_CONST(x) x##L
#endif

#include "x86intrin.h"

#define ROTL(x,y) __rolq(x,y)

static const unsigned keccakf_rotc[24] = {
    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62,
    18, 39, 61, 20, 44
};


static const unsigned keccakf_piln[24] = {
    10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20,
    14, 22, 9, 6, 1
};

static const uint64_t keccakf_rndc[24] = {
    SHA3_CONST(0x0000000000000001UL), SHA3_CONST(0x0000000000008082UL),
    SHA3_CONST(0x800000000000808aUL), SHA3_CONST(0x8000000080008000UL),
    SHA3_CONST(0x000000000000808bUL), SHA3_CONST(0x0000000080000001UL),
    SHA3_CONST(0x8000000080008081UL), SHA3_CONST(0x8000000000008009UL),
    SHA3_CONST(0x000000000000008aUL), SHA3_CONST(0x0000000000000088UL),
    SHA3_CONST(0x0000000080008009UL), SHA3_CONST(0x000000008000000aUL),
    SHA3_CONST(0x000000008000808bUL), SHA3_CONST(0x800000000000008bUL),
    SHA3_CONST(0x8000000000008089UL), SHA3_CONST(0x8000000000008003UL),
    SHA3_CONST(0x8000000000008002UL), SHA3_CONST(0x8000000000000080UL),
    SHA3_CONST(0x000000000000800aUL), SHA3_CONST(0x800000008000000aUL),
    SHA3_CONST(0x8000000080008081UL), SHA3_CONST(0x8000000000008080UL),
    SHA3_CONST(0x0000000080000001UL), SHA3_CONST(0x8000000080008008UL)
};

inline static void state_permute1(uint64_t *s, int round)
{
  uint64_t _C[5U] = { 0U };
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)5U; i = i + (uint32_t)1U)
    _C[i] =
      s[i
      + (uint32_t)0U]
      ^ s[i + (uint32_t)5U] ^ s[i + (uint32_t)10U] ^ s[i + (uint32_t)15U] ^ s[i + (uint32_t)20U];
  for (uint32_t i0 = (uint32_t)0U; i0 < (uint32_t)5U; i0 = i0 + (uint32_t)1U)
  {
    uint64_t uu____0 = _C[(i0 + (uint32_t)1U) % (uint32_t)5U];
    uint64_t
    _D =
      _C[(i0 + (uint32_t)4U)
      % (uint32_t)5U]
      ^ ROTL(uu____0,1);
    for (uint32_t i = (uint32_t)0U; i < (uint32_t)5U; i = i + (uint32_t)5U)
      s[i0 + i] = s[i0 + i] ^ _D;
  }
  uint64_t current = s[1U];
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)24U; i = i + (uint32_t)1U)
  {
    uint64_t current0 = current;
    uint32_t r = keccakf_rotc[i];
    uint32_t _Y = keccakf_piln[i];
    uint64_t temp = s[_Y];
    s[_Y] = ROTL(current0,r);
    current = temp;
  }
  uint64_t temp[25U] = { 0U };
  memcpy(temp, s, (uint32_t)25U * sizeof s[0U]);
  for (uint32_t i0 = (uint32_t)0U; i0 < (uint32_t)5U; i0 = i0 + (uint32_t)5U)
    for (uint32_t i = (uint32_t)0U; i < (uint32_t)5U; i = i + (uint32_t)1U)
      s[i + i0] =
        temp[i
        + i0]
        ^
          ~temp[(i + (uint32_t)1U)
          % (uint32_t)5U
          + i0]
          & temp[(i + (uint32_t)2U) % (uint32_t)5U + i0];
  s[0U] = s[0U] ^ keccakf_rndc[round];
}

inline static void state_permute(uint64_t *s)
{
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)24U; i = i + (uint32_t)1U)
    state_permute1(s, i);
}

inline static void loadState(uint32_t rateInBytes, uint8_t *input, uint64_t *s)
{
  uint8_t block[200U] = { 0U };
  memcpy(block, input, rateInBytes * sizeof input[0U]);
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)25U; i = i + (uint32_t)1U)
  {
    uint64_t uu____0 = s[i];
    uint64_t u = load64_le(block + i * (uint32_t)8U);
    s[i] = uu____0 ^ u;
  }
}

inline static void storeState(uint32_t rateInBytes, uint64_t *s, uint8_t *res)
{
  uint8_t block[200U] = { 0U };
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)25U; i = i + (uint32_t)1U)
    store64_le(block + i * (uint32_t)8U, s[i]);
  memcpy(res, block, rateInBytes * sizeof block[0U]);
}

inline static void
absorb(
  uint64_t *s,
  uint32_t rateInBytes,
  uint32_t inputByteLen,
  uint8_t *input,
  uint8_t delimitedSuffix
)
{
  uint32_t n1 = inputByteLen / rateInBytes;
  uint32_t rem1 = inputByteLen % rateInBytes;
  for (uint32_t i = (uint32_t)0U; i < n1; i = i + (uint32_t)1U)
  {
    loadState(rateInBytes, input + i * rateInBytes, s);
    state_permute(s);
  }
  KRML_CHECK_SIZE(sizeof (uint8_t), rateInBytes);
  uint8_t lastBlock[rateInBytes];
  memset(lastBlock, 0U, rateInBytes * sizeof lastBlock[0U]);
  uint32_t rem2 = inputByteLen % rateInBytes;
  uint8_t *last1 = input + inputByteLen - rem2;
  memcpy(lastBlock, last1, rem2 * sizeof last1[0U]);
  lastBlock[rem2] = delimitedSuffix;
  loadState(rateInBytes, lastBlock, s);
  if (!((delimitedSuffix & (uint8_t)0x80U) == (uint8_t)0U) && rem1 == rateInBytes - (uint32_t)1U)
    state_permute(s);
  KRML_CHECK_SIZE(sizeof (uint8_t), rateInBytes);
  uint8_t nextBlock[rateInBytes];
  memset(nextBlock, 0U, rateInBytes * sizeof nextBlock[0U]);
  nextBlock[rateInBytes - (uint32_t)1U] = (uint8_t)0x80U;
  loadState(rateInBytes, nextBlock, s);
  state_permute(s);
}

inline static void
squeeze(uint64_t *s, uint32_t rateInBytes, uint32_t outputByteLen, uint8_t *output)
{
  uint32_t outBlocks = outputByteLen / rateInBytes;
  uint32_t remOut = outputByteLen % rateInBytes;
  for (uint32_t i = (uint32_t)0U; i < outBlocks; i = i + (uint32_t)1U)
  {
    storeState(rateInBytes, s, output + i * rateInBytes);
    state_permute(s);
  }
  storeState(remOut, s, output + outputByteLen - remOut);
}

static void
keccak(
  uint32_t rate,
  uint32_t capacity,
  uint32_t inputByteLen,
  uint8_t *input,
  uint8_t delimitedSuffix,
  uint32_t outputByteLen,
  uint8_t *output
)
{
  uint32_t rateInBytes = rate / (uint32_t)8U;
  uint64_t s[25U] = { 0U };
  absorb(s, rateInBytes, inputByteLen, input, delimitedSuffix);
  squeeze(s, rateInBytes, outputByteLen, output);
}

void shake128_hacl(uint32_t inputByteLen, uint8_t *input, uint32_t outputByteLen, uint8_t *output)
{
  keccak((uint32_t)1344U,
    (uint32_t)256U,
    inputByteLen,
    input,
    (uint8_t)0x1FU,
    outputByteLen,
    output);
}

void shake256_hacl(uint32_t inputByteLen, uint8_t *input, uint32_t outputByteLen, uint8_t *output)
{
  keccak((uint32_t)1088U,
    (uint32_t)512U,
    inputByteLen,
    input,
    (uint8_t)0x1FU,
    outputByteLen,
    output);
}

void sha3_224(uint32_t inputByteLen, uint8_t *input, uint8_t *output)
{
  keccak((uint32_t)1152U,
    (uint32_t)448U,
    inputByteLen,
    input,
    (uint8_t)0x06U,
    (uint32_t)28U,
    output);
}

void sha3_256(uint32_t inputByteLen, uint8_t *input, uint8_t *output)
{
  keccak((uint32_t)1088U,
    (uint32_t)512U,
    inputByteLen,
    input,
    (uint8_t)0x06U,
    (uint32_t)32U,
    output);
}

void sha3_384(uint32_t inputByteLen, uint8_t *input, uint8_t *output)
{
  keccak((uint32_t)832U,
    (uint32_t)768U,
    inputByteLen,
    input,
    (uint8_t)0x06U,
    (uint32_t)48U,
    output);
}

void sha3_512(uint32_t inputByteLen, uint8_t *input, uint8_t *output)
{
  keccak((uint32_t)576U,
    (uint32_t)1024U,
    inputByteLen,
    input,
    (uint8_t)0x06U,
    (uint32_t)64U,
    output);
}

void
cshake128_frodo(
  uint32_t input_len,
  uint8_t *input,
  uint16_t cstm,
  uint32_t output_len,
  uint8_t *output
)
{
  uint64_t s[25U] = { 0U };
  s[0U] = (uint64_t)0x10010001a801U | (uint64_t)cstm << (uint32_t)48U;
  state_permute(s);
  absorb(s, (uint32_t)168U, input_len, input, (uint8_t)0x04U);
  squeeze(s, (uint32_t)168U, output_len, output);
}

void
cshake256_frodo(
  uint32_t input_len,
  uint8_t *input,
  uint16_t cstm,
  uint32_t output_len,
  uint8_t *output
)
{
  uint64_t s[25U] = { 0U };
  s[0U] = (uint64_t)0x100100018801U | (uint64_t)cstm << (uint32_t)48U;
  state_permute(s);
  absorb(s, (uint32_t)136U, input_len, input, (uint8_t)0x04U);
  squeeze(s, (uint32_t)136U, output_len, output);
}

