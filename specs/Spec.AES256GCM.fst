module Spec.AES256GCM

open FStar.Seq
open FStar.Endianness
open Spec.AES
open Spec.GF128


#set-options "--z3rlimit 40 --initial_fuel 0 --max_fuel 0"

let keylen =   32 (* in bytes *)
let noncelen = 12 (* in bytes *)

type key = lbytes keylen
type nonce = lbytes noncelen
type bytes = s:seq UInt8.t{length s < pow2 32}

let pad_16 (x:bytes) =
  let l = length x in
  let m = l % 16 in
  if m = 0 then x 
  else x @| create (16-m) 0uy

let gcm_aad (k:key) (n:nonce) (m:bytes) (aad:bytes) =
  let b0 : Spec.GF128.tag = Spec.AES.aes256_block k n 1 in
  let mackey : Spec.GF128.elem = Spec.GF128.encode (Spec.AES.cipher (create 16 0uy) k) in
  let open FStar.Mul in
  let laad = big_bytes 8ul (length aad * 8) in
  let lm = big_bytes 8ul (length m * 8) in
  let to_mac : Spec.GF128.text = encode_bytes (pad_16 aad @| pad_16 m @| laad @| lm) in
  let mac = Spec.GF128.mac to_mac mackey b0 in
  mac

val aead_aes256gcm_encrypt: k:key -> n:nonce -> m:bytes -> aad:bytes ->
  Tot (lbytes (length m) * Spec.GF128.tag)
let aead_aes256gcm_encrypt k n m aad =
  let c = Spec.AES.aes256_encrypt_bytes k n 2 m in
  let mac = gcm_aad k n c aad in
  (c, mac)

val aead_aes256gcm_decrypt: k:key -> n:nonce -> c:bytes -> t:tag -> aad:bytes ->
  Tot (option (lbytes (length c)))
let aead_aes256gcm_decrypt k n c t aad =
  let xmac = gcm_aad k n c aad in
  if xmac = t then
    let p = Spec.AES.aes256_encrypt_bytes k n 2 c in
    Some p
  else None


let k : key = createL [
  0xfeuy; 0xffuy; 0xe9uy; 0x92uy; 0x86uy; 0x65uy; 0x73uy; 0x1cuy;
  0x6duy; 0x6auy; 0x8fuy; 0x94uy; 0x67uy; 0x30uy; 0x83uy; 0x08uy;
  0xfeuy; 0xffuy; 0xe9uy; 0x92uy; 0x86uy; 0x65uy; 0x73uy; 0x1cuy;
  0x6duy; 0x6auy; 0x8fuy; 0x94uy; 0x67uy; 0x30uy; 0x83uy; 0x08uy ]
  
let n : nonce = createL [
  0xcauy; 0xfeuy; 0xbauy; 0xbeuy; 0xfauy; 0xceuy; 0xdbuy; 0xaduy;
  0xdeuy; 0xcauy; 0xf8uy; 0x88uy ]

let p : bytes = createL [
  0xd9uy; 0x31uy; 0x32uy; 0x25uy; 0xf8uy; 0x84uy; 0x06uy; 0xe5uy;
  0xa5uy; 0x59uy; 0x09uy; 0xc5uy; 0xafuy; 0xf5uy; 0x26uy; 0x9auy;
  0x86uy; 0xa7uy; 0xa9uy; 0x53uy; 0x15uy; 0x34uy; 0xf7uy; 0xdauy;
  0x2euy; 0x4cuy; 0x30uy; 0x3duy; 0x8auy; 0x31uy; 0x8auy; 0x72uy;
  0x1cuy; 0x3cuy; 0x0cuy; 0x95uy; 0x95uy; 0x68uy; 0x09uy; 0x53uy;
  0x2fuy; 0xcfuy; 0x0euy; 0x24uy; 0x49uy; 0xa6uy; 0xb5uy; 0x25uy;
  0xb1uy; 0x6auy; 0xeduy; 0xf5uy; 0xaauy; 0x0duy; 0xe6uy; 0x57uy;
  0xbauy; 0x63uy; 0x7buy; 0x39uy ]

let aad : bytes = createL [
  0xfeuy; 0xeduy; 0xfauy; 0xceuy; 0xdeuy; 0xaduy; 0xbeuy; 0xefuy;
  0xfeuy; 0xeduy; 0xfauy; 0xceuy; 0xdeuy; 0xaduy; 0xbeuy; 0xefuy;
  0xabuy; 0xaduy; 0xdauy; 0xd2uy ]

let c : bytes = createL [
  0x52uy; 0x2duy; 0xc1uy; 0xf0uy; 0x99uy; 0x56uy; 0x7duy; 0x07uy;
  0xf4uy; 0x7fuy; 0x37uy; 0xa3uy; 0x2auy; 0x84uy; 0x42uy; 0x7duy;
  0x64uy; 0x3auy; 0x8cuy; 0xdcuy; 0xbfuy; 0xe5uy; 0xc0uy; 0xc9uy;
  0x75uy; 0x98uy; 0xa2uy; 0xbduy; 0x25uy; 0x55uy; 0xd1uy; 0xaauy;
  0x8cuy; 0xb0uy; 0x8euy; 0x48uy; 0x59uy; 0x0duy; 0xbbuy; 0x3duy;
  0xa7uy; 0xb0uy; 0x8buy; 0x10uy; 0x56uy; 0x82uy; 0x88uy; 0x38uy;
  0xc5uy; 0xf6uy; 0x1euy; 0x63uy; 0x93uy; 0xbauy; 0x7auy; 0x0auy;
  0xbcuy; 0xc9uy; 0xf6uy; 0x62uy ]

let t : tag = createL [
  0x76uy; 0xfcuy; 0x6euy; 0xceuy; 0x0fuy; 0x4euy; 0x17uy; 0x68uy;
  0xcduy; 0xdfuy; 0x88uy; 0x53uy; 0xbbuy; 0x2duy; 0x55uy; 0x1buy ]


let test() =
  let (cipher, mac) = aead_aes256gcm_encrypt k n p aad in
  let dec = aead_aes256gcm_decrypt k n cipher mac aad in
  cipher = c && mac = t && dec = Some p
