module Spec.AESGCM.Test

#reset-options "--z3rlimit 100 --initial_fuel 0 --max_fuel 0 --initial_ifuel 0"

open FStar.Mul
open Spec.Lib.IntTypes
open Spec.Lib.RawIntTypes
open Spec.Lib.IntSeq
open Spec.Lib.Stateful

module AEAD = Spec.AESGCM

(*
    key: "feffe9928665731c6d6a8f9467308308"
    msg: "d9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a721c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39"
    aad: "feedfacedeadbeeffeedfacedeadbeefabaddad2"
    n:   "cafebabefacedbaddecaf888"
    hk:  "b83b533708bf535d0aa6e52980d53b78"
    gh:  "698e57f70e6ecc7fd9463b7260a9ae5f"
    exp: "42831ec2217774244b7221b784d0d49ce3aa212f2c02a4e035c17e2329aca12e21d514b25"
     "466931c7d8f6a5aac84aa051ba30b396a0aac973d58e0915bc94fbc3221a5db94fae95ae7"
     "121a47"
*)

let key_length = 16

let testX_key = List.map u8 [
0xfe; 0xff; 0xe9; 0x92; 0x86; 0x65; 0x73; 0x1c; 0x6d; 0x6a; 0x8f; 0x94; 0x67; 0x30; 0x83; 0x08
]

let testX_nonce = List.map u8 [
0xca; 0xfe; 0xba; 0xbe; 0xfa; 0xce; 0xdb; 0xad; 0xde; 0xca; 0xf8; 0x88
]

let testX_msg = List.map u8 [
0xd9; 0x31; 0x32; 0x25; 0xf8; 0x84; 0x06; 0xe5; 0xa5; 0x59; 0x09; 0xc5; 0xaf; 0xf5; 0x26; 0x9a; 0x86; 0xa7; 0xa9; 0x53; 0x15; 0x34; 0xf7; 0xda; 0x2e; 0x4c; 0x30; 0x3d; 0x8a; 0x31; 0x8a; 0x72; 0x1c; 0x3c; 0x0c; 0x95; 0x95; 0x68; 0x09; 0x53; 0x2f; 0xcf; 0x0e; 0x24; 0x49; 0xa6; 0xb5; 0x25; 0xb1; 0x6a; 0xed; 0xf5; 0xaa; 0x0d; 0xe6; 0x57; 0xba; 0x63; 0x7b; 0x39
]

let testX_aad = List.map u8 [
0xfe; 0xed; 0xfa; 0xce; 0xde; 0xad; 0xbe; 0xef; 0xfe; 0xed; 0xfa; 0xce; 0xde; 0xad; 0xbe; 0xef; 0xab; 0xad; 0xda; 0xd2
]

let testX_expected = List.map u8 [
0x42; 0x83; 0x1e; 0xc2; 0x21; 0x77; 0x74; 0x24; 0x4b; 0x72; 0x21; 0xb7; 0x84; 0xd0; 0xd4; 0x9c; 0xe3; 0xaa; 0x21; 0x2f; 0x2c; 0x02; 0xa4; 0xe0; 0x35; 0xc1; 0x7e; 0x23; 0x29; 0xac; 0xa1; 0x2e; 0x21; 0xd5; 0x14; 0xb2; 0x54; 0x66; 0x93; 0x1c; 0x7d; 0x8f; 0x6a; 0x5a; 0xac; 0x84; 0xaa; 0x05; 0x1b; 0xa3; 0x0b; 0x39; 0x6a; 0x0a; 0xac; 0x97; 0x3d; 0x58; 0xe0; 0x91; 0x5b; 0xc9; 0x4f; 0xbc; 0x32; 0x21; 0xa5; 0xdb; 0x94; 0xfa; 0xe9; 0x5a; 0xe7; 0x12; 0x1a; 0x47
]

let testX_ciphertext = List.map u8 [
0x42; 0x83; 0x1e; 0xc2; 0x21; 0x77; 0x74; 0x24; 0x4b; 0x72; 0x21; 0xb7; 0x84; 0xd0; 0xd4; 0x9c; 0xe3; 0xaa; 0x21; 0x2f; 0x2c; 0x02; 0xa4; 0xe0; 0x35; 0xc1; 0x7e; 0x23; 0x29; 0xac; 0xa1; 0x2e; 0x21; 0xd5; 0x14; 0xb2; 0x54; 0x66; 0x93; 0x1c; 0x7d; 0x8f; 0x6a; 0x5a; 0xac; 0x84; 0xaa; 0x05; 0x1b; 0xa3; 0x0b; 0x39; 0x6a; 0x0a; 0xac; 0x97; 0x3d; 0x58; 0xe0; 0x91
]

let testX_hash_key = List.map u8 [
0xb8; 0x3b; 0x53; 0x37; 0x08; 0xbf; 0x53; 0x5d; 0x0a; 0xa6; 0xe5; 0x29; 0x80; 0xd5; 0x3b; 0x78
]

let testX_ghash = List.map u8 [
0x69; 0x8e; 0x57; 0xf7; 0x0e; 0x6e; 0xcc; 0x7f; 0xd9; 0x46; 0x3b; 0x72; 0x60; 0xa9; 0xae; 0x5f
]

let testX_nonce_length: size_nat = 12
let testX_msg_length: size_nat = 60
let testX_aad_length: size_nat = 20
let testX_c_length: size_nat = 60

val test_aesgcm:
  text_len:size_nat ->
  text:lbytes text_len ->
  aad_len:size_nat ->
  aad:lbytes aad_len ->
  n_len:size_nat ->
  n:lbytes n_len ->
  k:lbytes key_length ->
  expected:lbytes (16 + text_len) ->
  FStar.All.ML unit
let test_aesgcm text_len text aad_len aad n_len n k expected =
  let output = AEAD.aead_encrypt k n text_len text aad_len aad in
  let result = for_all2 (fun a b -> uint_to_nat #U8 a = uint_to_nat #U8 b) output expected in
  IO.print_string   "Expected ciphertext: ";
  let test_expected : lbytes key_length = createL expected in
  List.iter (fun a -> IO.print_string (UInt8.to_string (u8_to_UInt8 a));  IO.print_string ":") (as_list test_expected);
  IO.print_string "\nComputed ciphertext: ";
  List.iter (fun a -> IO.print_string (UInt8.to_string (u8_to_UInt8 a));  IO.print_string ":") (as_list output);
  if result then IO.print_string "\nSuccess!\n"
  else IO.print_string "\nFailure :(\n"

val test_ghash:
  expected:lbytes AEAD.blocksize ->
  text_len:size_nat ->
  text:lbytes text_len ->
  aad_len:size_nat ->
  aad:lbytes aad_len ->
  k:lbytes key_length ->
  FStar.All.ML unit
let test_ghash expected text_len text aad_len aad k =
  let output = AEAD.ghash text_len text aad_len aad (create 16 0uy) k in
  let result = for_all2 (fun a b -> uint_to_nat #U8 a = uint_to_nat #U8 b) output expected in
  IO.print_string   "Expected tag: ";
  let test_expected : lbytes key_length = createL expected in
  List.iter (fun a -> IO.print_string (UInt8.to_string (u8_to_UInt8 a));  IO.print_string ":") (as_list test_expected);
  IO.print_string "\nComputed tag: ";
  List.iter (fun a -> IO.print_string (UInt8.to_string (u8_to_UInt8 a));  IO.print_string ":") (as_list output);
  if result then IO.print_string "\nSuccess!\n"
else IO.print_string "\nFailure :(\n"

let test () =
  test_ghash testX_ghash testX_c_length testX_ciphertext testX_aad_length testX_aad testX_key;
  test_aesgcm testX_msg_length testX_msg testX_aad_length testX_aad testX_nonce_length testX_nonce testX_key testX_expected
