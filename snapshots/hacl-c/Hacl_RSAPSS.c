
/* This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
 * KreMLin invocation: /home/mpolubel/work/kremlin/krml -I /home/mpolubel/work/hacl-star/code/lib/kremlin -I /home/mpolubel/work/kremlin/kremlib -I /home/mpolubel/work/hacl-star/specs -I . -ccopt -march=native -verbose -ldopt -flto -verbose -no-prefix C.Loops -drop Prims,FStar,LowStar,C.Loops.Spec.Loops,Hacl.Cast,Hacl.UInt8,Hacl.UInt16,Hacl.UInt32,Hacl.UInt64,Hacl.UInt128 -drop Hacl.Spec.Endianness,Hacl.Endianness,Seq.Create,Spec.* -drop Hacl.SHA256 -add-early-include "Hacl_SHA256.h" -add-include "kremlin/c_string.h" -ccopt -march=native -tmpdir rsa-c -no-prefix Hacl.Test.RSA -skip-compilation -bundle Hacl.RSAPSS=Hacl.Impl.*,Hacl.RSAPSS rsa-c/out.krml -o rsa-c/Hacl_RSAPSS.c
 * F* version: d22c8d7b
 * KreMLin version: bb3cc303
 */

#include "Hacl_RSAPSS.h"
#include "Hacl_SHA2_256.h"
#include <immintrin.h>
#include <x86intrin.h>

inline static bool Hacl_Impl_Lib_bn_is_bit_set(uint32_t len, uint64_t *input, uint32_t ind)
{
  uint32_t i = ind / (uint32_t)64U;
  uint32_t j = ind % (uint32_t)64U;
  uint64_t tmp = input[i];
  uint64_t tmp1 = tmp >> j & (uint64_t)1U;
  return tmp1 == (uint64_t)1U;
}

inline static uint64_t Hacl_Impl_Lib_bval(uint32_t len, uint64_t *b, uint32_t i)
{
  if (i < len)
    return b[i];
  else
    return (uint64_t)0U;
}

inline static void Hacl_Impl_Lib_fill(uint32_t len, uint64_t *b, uint64_t z)
{
  KRML_CHECK_SIZE(sizeof(z), len);
  for (uint32_t i = (uint32_t)0U; i < len; i = i + (uint32_t)1U)
  {
    b[i] = z;
  }
}

inline bool Hacl_Impl_Lib_eq_b(uint32_t len, uint8_t *b1, uint8_t *b2)
{
  KRML_CHECK_SIZE(sizeof(true), (uint32_t)1U);
  bool buf[1U];
  buf[0U] = true;
  for (uint32_t i = (uint32_t)0U; i < len; i = i + (uint32_t)1U)
  {
    bool a1 = buf[0U];
    uint8_t x0 = b1[i];
    uint8_t x1 = b2[i];
    bool a2 = x0 == x1;
    buf[0U] = a1 && a2;
  }
  bool r = buf[0U];
  return r;
}

inline void Hacl_Impl_Convert_text_to_nat(uint32_t len, uint8_t *input, uint64_t *res)
{
  uint32_t num_words = (len - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t tmpLen = (uint32_t)8U * num_words;
  uint32_t m = len % (uint32_t)8U;
  uint32_t ind;
  if (m == (uint32_t)0U)
    ind = (uint32_t)0U;
  else
    ind = (uint32_t)8U - m;
  KRML_CHECK_SIZE(sizeof (uint8_t), tmpLen);
  uint8_t buf[tmpLen];
  memset(buf, 0U, tmpLen * sizeof buf[0U]);
  uint8_t *tmp1 = buf + ind;
  for (uint32_t i = (uint32_t)0U; i < len; i = i + (uint32_t)1U)
  {
    uint8_t src_i = input[i];
    tmp1[i] = src_i;
  }
  for (uint32_t i = (uint32_t)0U; i < num_words; i = i + (uint32_t)1U)
    res[num_words - i - (uint32_t)1U] = load64_be(buf + (uint32_t)8U * i);
}

inline static void Hacl_Impl_Convert_nat_to_text(uint32_t len, uint64_t *input, uint8_t *res)
{
  uint32_t num_words = (len - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t tmpLen = (uint32_t)8U * num_words;
  uint32_t m = len % (uint32_t)8U;
  uint32_t ind;
  if (m == (uint32_t)0U)
    ind = (uint32_t)0U;
  else
    ind = (uint32_t)8U - m;
  KRML_CHECK_SIZE(sizeof (uint8_t), tmpLen);
  uint8_t buf[tmpLen];
  memset(buf, 0U, tmpLen * sizeof buf[0U]);
  for (uint32_t i = (uint32_t)0U; i < num_words; i = i + (uint32_t)1U)
  {
    uint64_t tmp = input[num_words - i - (uint32_t)1U];
    store64_be(buf + (uint32_t)8U * i, tmp);
  }
  uint8_t *tmp1 = buf + ind;
  for (uint32_t i = (uint32_t)0U; i < len; i = i + (uint32_t)1U)
  {
    uint8_t src_i = tmp1[i];
    res[i] = src_i;
  }
}

inline static bool
Hacl_Impl_Comparison_bn_is_less_(
  uint32_t aLen,
  uint64_t *a,
  uint32_t bLen,
  uint64_t *b,
  uint32_t i
)
{
  if (i > (uint32_t)0U)
  {
    uint32_t i1 = i - (uint32_t)1U;
    uint64_t t1 = a[i1];
    uint64_t t2 = Hacl_Impl_Lib_bval(bLen, b, i1);
    if (!(t1 == t2))
      if (t1 < t2)
        return true;
      else
        return false;
    else
      return Hacl_Impl_Comparison_bn_is_less_(aLen, a, bLen, b, i1);
  }
  else
    return false;
}

inline static bool
Hacl_Impl_Comparison_bn_is_less(uint32_t aLen, uint64_t *a, uint32_t bLen, uint64_t *b)
{
  return Hacl_Impl_Comparison_bn_is_less_(aLen, a, bLen, b, aLen);
}

typedef struct K___uint64_t_uint64_t_s
{
  uint64_t fst;
  uint64_t snd;
}
K___uint64_t_uint64_t;

inline static uint64_t
Hacl_Impl_Addition_bn_sub(
  uint32_t aLen,
  uint64_t *a,
  uint32_t bLen,
  uint64_t *b,
  uint64_t *res
)
{
  uint8_t carry2 = 0;
  for(int i = 0; i < aLen; i++) {
    carry2 = _subborrow_u64(carry2,Hacl_Impl_Lib_bval(bLen,b,i),a[i],&res[i]);
  }
  return carry2;
}

inline static uint64_t
Hacl_Impl_Addition_bn_add(
  uint32_t aLen,
  uint64_t *a,
  uint32_t bLen,
  uint64_t *b,
  uint64_t *res
)
{
  uint8_t carry2 = 0;
  for(int i = 0; i < aLen; i++) {
    carry2 = _addcarry_u64(carry2,a[i],Hacl_Impl_Lib_bval(bLen,b,i),&res[i]);
  }
  return carry2;
}

inline static K___uint64_t_uint64_t
Hacl_Impl_Multiplication_bn_mul_by_limb_addj_f(
  uint64_t a_i,
  uint64_t l,
  uint64_t c,
  uint64_t r_ij
)
{
  FStar_UInt128_uint128
  res =
    FStar_UInt128_add(FStar_UInt128_add(FStar_UInt128_mul_wide(a_i, l),
        FStar_UInt128_uint64_to_uint128(c)),
      FStar_UInt128_uint64_to_uint128(r_ij));
  uint64_t r = FStar_UInt128_uint128_to_uint64(res);
  uint64_t c_ = FStar_UInt128_uint128_to_uint64(FStar_UInt128_shift_right(res, (uint32_t)64U));
  return ((K___uint64_t_uint64_t){ .fst = c_, .snd = r });
}

inline static void
Hacl_Impl_Multiplication_bn_mul(
  uint32_t aLen,
  uint64_t *a,
  uint32_t bLen,
  uint64_t *b,
  uint64_t *res
)
{
  uint32_t resLen = aLen + bLen;
  Hacl_Impl_Lib_fill(resLen, res, (uint64_t)0U);
  uint64_t buf[1U] = { 0U };
  for (uint32_t i0 = (uint32_t)0U; i0 < bLen; i0 = i0 + (uint32_t)1U)
  {
    buf[0U] = (uint64_t)0U;
    uint64_t x2 = b[i0];
    for (uint32_t i = (uint32_t)0U; i < aLen; i = i + (uint32_t)1U)
    {
      uint32_t ij = i + i0;
      uint64_t res_ij = res[ij];
      K___uint64_t_uint64_t
      scrut = Hacl_Impl_Multiplication_bn_mul_by_limb_addj_f(a[i], x2, buf[0U], res_ij);
      uint64_t c = scrut.fst;
      uint64_t res_ij1 = scrut.snd;
      buf[0U] = c;
      res[ij] = res_ij1;
    }
    res[aLen + i0] = buf[0U];
  }
}

inline static Hacl_Impl_Multiplication_sign
Hacl_Impl_Multiplication_abs(uint32_t aLen, uint64_t *a, uint64_t *b, uint64_t *res)
{
  if (Hacl_Impl_Comparison_bn_is_less(aLen, a, aLen, b))
  {
    uint64_t uu____0 = Hacl_Impl_Addition_bn_sub(aLen, b, aLen, a, res);
    return Hacl_Impl_Multiplication_Negative;
  }
  else
  {
    uint64_t uu____1 = Hacl_Impl_Addition_bn_sub(aLen, a, aLen, b, res);
    return Hacl_Impl_Multiplication_Positive;
  }
}

bool
__eq__Hacl_Impl_Multiplication_sign(
  Hacl_Impl_Multiplication_sign y,
  Hacl_Impl_Multiplication_sign x
)
{
  switch (x)
  {
    case Hacl_Impl_Multiplication_Positive:
      {
        switch (y)
        {
          case Hacl_Impl_Multiplication_Positive:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    case Hacl_Impl_Multiplication_Negative:
      {
        switch (y)
        {
          case Hacl_Impl_Multiplication_Negative:
            {
              return true;
            }
          default:
            {
              return false;
            }
        }
        break;
      }
    default:
      {
        return false;
      }
  }
}

inline static void
Hacl_Impl_Multiplication_add_sign(
  uint32_t a0Len,
  uint64_t *c0,
  uint64_t *c1,
  uint64_t *c2,
  uint64_t *a0,
  uint64_t *a1,
  uint64_t *a2,
  uint64_t *b0,
  uint64_t *b1,
  uint64_t *b2,
  Hacl_Impl_Multiplication_sign sa2,
  Hacl_Impl_Multiplication_sign sb2,
  uint32_t resLen,
  uint64_t *res
)
{
  uint32_t c0Len = a0Len + a0Len;
  uint64_t *res1 = res;
  uint64_t c = Hacl_Impl_Addition_bn_add(c0Len, c0, c0Len, c1, res1);
  res[c0Len] = c;
  if
  (
    __eq__Hacl_Impl_Multiplication_sign(sa2,
      Hacl_Impl_Multiplication_Positive)
    && __eq__Hacl_Impl_Multiplication_sign(sb2, Hacl_Impl_Multiplication_Positive)
    ||
      __eq__Hacl_Impl_Multiplication_sign(sa2,
        Hacl_Impl_Multiplication_Negative)
      && __eq__Hacl_Impl_Multiplication_sign(sb2, Hacl_Impl_Multiplication_Negative)
  )
  {
    uint64_t uu____0 = Hacl_Impl_Addition_bn_sub(resLen, res, c0Len, c2, res);
  }
  else
  {
    uint64_t uu____1 = Hacl_Impl_Addition_bn_add(resLen, res, c0Len, c2, res);
  }
}

inline static void
Hacl_Impl_Multiplication_karatsuba_(
  uint32_t pow2_i,
  uint32_t aLen,
  uint64_t *a,
  uint64_t *b,
  uint64_t *tmp,
  uint64_t *res
)
{
  uint32_t pow2_i0 = pow2_i / (uint32_t)2U;
  if (aLen < (uint32_t)32U)
    Hacl_Impl_Multiplication_bn_mul(aLen, a, aLen, b, res);
  else
  {
    uint64_t *a0 = a;
    uint64_t *b0 = b;
    uint64_t *tmp0 = tmp;
    uint64_t *c0 = res;
    Hacl_Impl_Multiplication_karatsuba_(pow2_i0, pow2_i0, a0, b0, tmp0, c0);
    uint64_t *a1 = a + pow2_i0;
    uint64_t *b1 = b + pow2_i0;
    uint64_t *tmp01 = tmp;
    uint64_t *c1 = res + pow2_i;
    Hacl_Impl_Multiplication_karatsuba_(pow2_i0, pow2_i0, a1, b1, tmp01, c1);
    uint64_t *a2 = tmp;
    uint64_t *b2 = tmp + pow2_i0;
    Hacl_Impl_Multiplication_sign sa2 = Hacl_Impl_Multiplication_abs(pow2_i0, a0, a1, a2);
    Hacl_Impl_Multiplication_sign sb2 = Hacl_Impl_Multiplication_abs(pow2_i0, b0, b1, b2);
    uint64_t *c2 = tmp + pow2_i;
    uint64_t *tmp02 = tmp + (uint32_t)4U * pow2_i0;
    Hacl_Impl_Multiplication_karatsuba_(pow2_i0, pow2_i0, a2, b2, tmp02, c2);
    uint32_t tmp1Len = pow2_i + (uint32_t)1U;
    uint64_t *tmp1 = tmp + (uint32_t)4U * pow2_i0;
    Hacl_Impl_Multiplication_add_sign(pow2_i0,
      c0,
      c1,
      c2,
      a0,
      a1,
      a2,
      b0,
      b1,
      b2,
      sa2,
      sb2,
      tmp1Len,
      tmp1);
    uint32_t res1Len = pow2_i0 + pow2_i;
    uint64_t *res1 = res + pow2_i0;
    uint64_t uu____0 = Hacl_Impl_Addition_bn_add(res1Len, res1, tmp1Len, tmp1, res1);
  }
}

inline static void
Hacl_Impl_Multiplication_karatsuba(
  uint32_t pow2_i,
  uint32_t aLen,
  uint64_t *a,
  uint64_t *b,
  uint64_t *st_kara
)
{
  uint64_t *res = st_kara;
  uint64_t *st_mult = st_kara + aLen + aLen;
  if (!(pow2_i == aLen))
    Hacl_Impl_Multiplication_bn_mul(aLen, a, aLen, b, res);
  else
    Hacl_Impl_Multiplication_karatsuba_(pow2_i, aLen, a, b, st_mult, res);
}

inline static uint64_t Hacl_Impl_Montgomery_mod_inv_u64(uint64_t n0)
{
  uint64_t alpha = (uint64_t)1U << (uint32_t)63U;
  uint64_t beta = n0;
  uint64_t buf[2U] = { 0U };
  buf[0U] = (uint64_t)1U;
  buf[1U] = (uint64_t)0U;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)64U; i = i + (uint32_t)1U)
  {
    uint64_t ub = buf[0U];
    uint64_t vb = buf[1U];
    uint64_t u_is_odd = (uint64_t)0U - (ub & (uint64_t)1U);
    uint64_t beta_if_u_is_odd = beta & u_is_odd;
    buf[0U] = ((ub ^ beta_if_u_is_odd) >> (uint32_t)1U) + (ub & beta_if_u_is_odd);
    uint64_t alpha_if_u_is_odd = alpha & u_is_odd;
    buf[1U] = (vb >> (uint32_t)1U) + alpha_if_u_is_odd;
  }
  uint64_t r = buf[1U];
  return r;
}

inline static void
Hacl_Impl_Montgomery_mont_reduction_a(
  uint32_t nLen,
  uint32_t rLen,
  uint64_t *c,
  uint64_t *n1,
  uint64_t nInv_u64
)
{
  uint64_t buf[1U] = { 0U };
  for (uint32_t i = (uint32_t)0U; i < rLen; i = i + (uint32_t)1U)
  {
    buf[0U] = (uint64_t)0U;
    uint64_t ci = c[i];
    uint64_t qi = nInv_u64 * ci;
    uint32_t x4 = nLen + rLen;
    for (uint32_t i0 = (uint32_t)0U; i0 < nLen; i0 = i0 + (uint32_t)1U)
    {
      uint32_t ij = i0 + i;
      uint64_t res_ij = c[ij];
      K___uint64_t_uint64_t
      scrut = Hacl_Impl_Multiplication_bn_mul_by_limb_addj_f(n1[i0], qi, buf[0U], res_ij);
      uint64_t c0 = scrut.fst;
      uint64_t res_ij1 = scrut.snd;
      buf[0U] = c0;
      c[ij] = res_ij1;
    }
    uint32_t res1Len = x4 - (nLen + i);
    uint64_t *res1 = c + nLen + i;
    uint64_t uu____0 = Hacl_Impl_Addition_bn_add(res1Len, res1, (uint32_t)1U, buf, res1);
  }
}

inline static void
Hacl_Impl_Montgomery_mont_reduction(
  uint32_t nLen,
  uint32_t rLen,
  uint64_t *n1,
  uint64_t nInv_u64,
  uint64_t *c,
  uint64_t *tmp,
  uint64_t *res
)
{
  uint32_t nLen2 = nLen + nLen;
  uint64_t *tmp1 = tmp;
  for (uint32_t i = (uint32_t)0U; i < nLen2; i = i + (uint32_t)1U)
  {
    uint64_t src_i = c[i];
    tmp1[i] = src_i;
  }
  tmp[nLen2] = (uint64_t)0U;
  Hacl_Impl_Montgomery_mont_reduction_a(nLen, rLen, tmp, n1, nInv_u64);
  uint64_t *tmp11 = tmp + rLen;
  for (uint32_t i = (uint32_t)0U; i < nLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = tmp11[i];
    res[i] = src_i;
  }
}

inline static void
Hacl_Impl_Montgomery_to_mont(
  uint32_t nLen,
  uint32_t rLen,
  uint32_t pow2_i,
  uint64_t *n1,
  uint64_t nInv_u64,
  uint64_t *r2,
  uint64_t *a,
  uint64_t *st_kara,
  uint64_t *aM
)
{
  uint32_t cLen = nLen + nLen;
  uint64_t *c = st_kara;
  Hacl_Impl_Multiplication_karatsuba(pow2_i, nLen, a, r2, st_kara);
  uint64_t *tmp = st_kara + cLen;
  Hacl_Impl_Montgomery_mont_reduction(nLen, rLen, n1, nInv_u64, c, tmp, aM);
}

inline static void
Hacl_Impl_Montgomery_from_mont(
  uint32_t nLen,
  uint32_t rLen,
  uint32_t pow2_i,
  uint64_t *n1,
  uint64_t nInv_u64,
  uint64_t *aM,
  uint64_t *tmp,
  uint64_t *a
)
{
  uint32_t tmpLen = nLen + rLen;
  Hacl_Impl_Lib_fill(tmpLen, tmp, (uint64_t)0U);
  uint64_t *tmp1 = tmp;
  for (uint32_t i = (uint32_t)0U; i < nLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = aM[i];
    tmp1[i] = src_i;
  }
  Hacl_Impl_Montgomery_mont_reduction_a(nLen, rLen, tmp, n1, nInv_u64);
  uint64_t *tmp11 = tmp + rLen;
  for (uint32_t i = (uint32_t)0U; i < nLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = tmp11[i];
    a[i] = src_i;
  }
}

inline static void
Hacl_Impl_Exponentiation_mul_mod_mont(
  uint32_t nLen,
  uint32_t rLen,
  uint32_t pow2_i,
  uint64_t *n1,
  uint64_t nInv_u64,
  uint64_t *st_kara,
  uint64_t *aM,
  uint64_t *bM,
  uint64_t *resM
)
{
  uint32_t cLen = nLen + nLen;
  uint64_t *c = st_kara;
  uint64_t *tmp = st_kara + cLen;
  Hacl_Impl_Multiplication_karatsuba(pow2_i, nLen, aM, bM, st_kara);
  Hacl_Impl_Montgomery_mont_reduction(nLen, rLen, n1, nInv_u64, c, tmp, resM);
}

inline static void
Hacl_Impl_Exponentiation_mod_exp_(
  uint32_t nLen,
  uint32_t rLen,
  uint32_t pow2_i,
  uint64_t *n1,
  uint64_t nInv_u64,
  uint64_t *st_kara,
  uint64_t *st_exp,
  uint32_t bBits,
  uint32_t bLen,
  uint64_t *b
)
{
  uint64_t *aM = st_exp;
  uint64_t *accM = st_exp + nLen;
  for (uint32_t i = (uint32_t)0U; i < bBits; i = i + (uint32_t)1U)
  {
    if (Hacl_Impl_Lib_bn_is_bit_set(bLen, b, i))
      Hacl_Impl_Exponentiation_mul_mod_mont(nLen,
        rLen,
        pow2_i,
        n1,
        nInv_u64,
        st_kara,
        aM,
        accM,
        accM);
    Hacl_Impl_Exponentiation_mul_mod_mont(nLen, rLen, pow2_i, n1, nInv_u64, st_kara, aM, aM, aM);
  }
}

inline static void
Hacl_Impl_Exponentiation_mod_exp(
  uint32_t pow2_i,
  uint32_t modBits,
  uint32_t nLen,
  uint64_t *n1,
  uint64_t *r2,
  uint64_t *a,
  uint32_t bBits,
  uint64_t *b,
  uint64_t *res
)
{
  uint32_t rLen = nLen + (uint32_t)1U;
  uint32_t bLen = (bBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint32_t karaLen = nLen + nLen + (uint32_t)4U * pow2_i;
  uint32_t stLen = nLen + nLen + nLen + karaLen;
  KRML_CHECK_SIZE(sizeof (uint64_t), stLen);
  uint64_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  uint64_t *acc = buf;
  uint64_t *aM = buf + nLen;
  uint64_t *accM = buf + nLen + nLen;
  uint64_t *st_exp = buf + nLen;
  uint64_t *st_kara = buf + nLen + nLen + nLen;
  uint64_t *tmp = buf + nLen + nLen + nLen;
  acc[0U] = (uint64_t)1U;
  uint64_t n0 = n1[0U];
  uint64_t nInv_u64 = Hacl_Impl_Montgomery_mod_inv_u64(n0);
  Hacl_Impl_Montgomery_to_mont(nLen, rLen, pow2_i, n1, nInv_u64, r2, a, st_kara, aM);
  Hacl_Impl_Montgomery_to_mont(nLen, rLen, pow2_i, n1, nInv_u64, r2, acc, st_kara, accM);
  Hacl_Impl_Exponentiation_mod_exp_(nLen,
    rLen,
    pow2_i,
    n1,
    nInv_u64,
    st_kara,
    st_exp,
    bBits,
    bLen,
    b);
  Hacl_Impl_Montgomery_from_mont(nLen, rLen, pow2_i, n1, nInv_u64, accM, tmp, res);
}

static void Hacl_Impl_MGF_hash_sha256(uint8_t *mHash, uint32_t len, uint8_t *m)
{
  Hacl_SHA2_256_hash(mHash, m, len);
}


inline static void
Hacl_Impl_MGF_mgf_sha256(uint32_t mgfseedLen, uint8_t *mgfseed, uint32_t maskLen, uint8_t *res)
{
  uint32_t count_max = (maskLen - (uint32_t)1U) / (uint32_t)32U + (uint32_t)1U;
  uint32_t accLen = count_max * (uint32_t)32U;
  uint32_t mgfseed_counterLen0 = mgfseedLen + (uint32_t)4U;
  uint32_t stLen = mgfseed_counterLen0 + (uint32_t)32U + accLen;
  KRML_CHECK_SIZE(sizeof (uint8_t), stLen);
  uint8_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  uint8_t *mgfseed_counter0 = buf;
  uint8_t *mgfseed_st = mgfseed_counter0;
  for (uint32_t i = (uint32_t)0U; i < mgfseedLen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = mgfseed[i];
    mgfseed_st[i] = src_i;
  }
  for (uint32_t i0 = (uint32_t)0U; i0 < count_max; i0 = i0 + (uint32_t)1U)
  {
    uint32_t mgfseed_counterLen = mgfseedLen + (uint32_t)4U;
    uint8_t *mgfseed_counter = buf;
    uint8_t *mHash = buf + mgfseed_counterLen;
    uint8_t *acc = buf + mgfseed_counterLen + (uint32_t)32U;
    uint8_t *c = mgfseed_counter + mgfseedLen;
    c[0U] = (uint8_t)(i0 >> (uint32_t)24U);
    c[1U] = (uint8_t)(i0 >> (uint32_t)16U);
    c[2U] = (uint8_t)(i0 >> (uint32_t)8U);
    c[3U] = (uint8_t)i0;
    Hacl_Impl_MGF_hash_sha256(mHash, mgfseed_counterLen, mgfseed_counter);
    uint8_t *acc_ = acc + (uint32_t)32U * i0;
    for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
    {
      uint8_t src_i = mHash[i];
      acc_[i] = src_i;
    }
  }
  uint8_t *acc = buf + mgfseed_counterLen0 + (uint32_t)32U;
  uint8_t *acc1 = acc;
  for (uint32_t i = (uint32_t)0U; i < maskLen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = acc1[i];
    res[i] = src_i;
  }
}

inline static void Hacl_Impl_RSA_xor_bytes(uint32_t len, uint8_t *b1, uint8_t *b2)
{
  for (uint32_t i = (uint32_t)0U; i < len; i = i + (uint32_t)1U)
  {
    uint8_t i1 = b1[i];
    uint8_t i2 = b2[i];
    b1[i] = i1 ^ i2;
  }
}

static void
Hacl_Impl_RSA_pss_encode(
  uint32_t sLen,
  uint8_t *salt,
  uint32_t msgLen,
  uint8_t *msg,
  uint32_t emBits,
  uint8_t *em
)
{
  uint32_t emLen = (emBits - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t msBits = emBits % (uint32_t)8U;
  uint32_t m1Len = (uint32_t)40U + sLen;
  uint32_t dbLen = emLen - (uint32_t)32U - (uint32_t)1U;
  uint32_t stLen = (uint32_t)32U + m1Len + (uint32_t)32U + dbLen + dbLen;
  KRML_CHECK_SIZE(sizeof (uint8_t), stLen);
  uint8_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  uint8_t *mHash = buf;
  uint8_t *m1 = buf + (uint32_t)32U;
  uint8_t *m1Hash = buf + (uint32_t)32U + m1Len;
  uint8_t *db = buf + (uint32_t)32U + m1Len + (uint32_t)32U;
  uint8_t *dbMask = buf + stLen - dbLen;
  Hacl_Impl_MGF_hash_sha256(mHash, msgLen, msg);
  uint8_t *m1_hash = m1 + (uint32_t)8U;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
  {
    uint8_t src_i = mHash[i];
    m1_hash[i] = src_i;
  }
  uint8_t *m1_salt = m1 + (uint32_t)40U;
  for (uint32_t i = (uint32_t)0U; i < sLen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = salt[i];
    m1_salt[i] = src_i;
  }
  Hacl_Impl_MGF_hash_sha256(m1Hash, m1Len, m1);
  uint32_t last_before_salt = dbLen - sLen - (uint32_t)1U;
  db[last_before_salt] = (uint8_t)1U;
  uint8_t *db_salt = db + last_before_salt + (uint32_t)1U;
  for (uint32_t i = (uint32_t)0U; i < sLen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = salt[i];
    db_salt[i] = src_i;
  }
  Hacl_Impl_MGF_mgf_sha256((uint32_t)32U, m1Hash, dbLen, dbMask);
  Hacl_Impl_RSA_xor_bytes(dbLen, db, dbMask);
  if (msBits > (uint32_t)0U)
  {
    uint32_t shift_bits = (uint32_t)8U - msBits;
    db[0U] = db[0U] & (uint8_t)0xffU >> shift_bits;
  }
  uint8_t *em_db = em;
  for (uint32_t i = (uint32_t)0U; i < dbLen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = db[i];
    em_db[i] = src_i;
  }
  uint8_t *em_hash = em + dbLen;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
  {
    uint8_t src_i = m1Hash[i];
    em_hash[i] = src_i;
  }
  em[emLen - (uint32_t)1U] = (uint8_t)0xbcU;
}

inline static bool
Hacl_Impl_RSA_pss_verify(
  uint32_t sLen,
  uint32_t msgLen,
  uint8_t *msg,
  uint32_t emBits,
  uint8_t *em
)
{
  uint32_t emLen = (emBits - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t msBits = emBits % (uint32_t)8U;
  uint8_t em_0;
  if (msBits > (uint32_t)0U)
    em_0 = em[0U] & (uint8_t)0xffU << msBits;
  else
    em_0 = (uint8_t)0U;
  uint8_t em_last = em[emLen - (uint32_t)1U];
  uint32_t padLen = emLen - sLen - (uint32_t)32U - (uint32_t)1U;
  uint32_t dbLen = emLen - (uint32_t)32U - (uint32_t)1U;
  uint32_t m1Len = (uint32_t)40U + sLen;
  uint32_t stLen = (uint32_t)32U + padLen + dbLen + m1Len + (uint32_t)32U;
  KRML_CHECK_SIZE(sizeof (uint8_t), stLen);
  uint8_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  bool r;
  if (!(em_0 == (uint8_t)0U && em_last == (uint8_t)0xbcU))
    r = false;
  else
  {
    uint8_t *mHash = buf;
    uint8_t *pad2 = buf + (uint32_t)32U;
    uint8_t *dbMask = buf + (uint32_t)32U + padLen;
    uint8_t *m1 = buf + (uint32_t)32U + padLen + dbLen;
    uint8_t *m1Hash_ = buf + stLen - (uint32_t)32U;
    uint8_t *maskedDB = em;
    uint8_t *m1Hash = em + dbLen;
    Hacl_Impl_MGF_hash_sha256(mHash, msgLen, msg);
    Hacl_Impl_MGF_mgf_sha256((uint32_t)32U, m1Hash, dbLen, dbMask);
    Hacl_Impl_RSA_xor_bytes(dbLen, dbMask, maskedDB);
    if (msBits > (uint32_t)0U)
    {
      uint32_t shift_bits = (uint32_t)8U - msBits;
      dbMask[0U] = dbMask[0U] & (uint8_t)0xffU >> shift_bits;
    }
    pad2[padLen - (uint32_t)1U] = (uint8_t)0x01U;
    uint8_t *pad = dbMask;
    uint8_t *salt = dbMask + padLen;
    uint8_t *m1_hash = m1 + (uint32_t)8U;
    for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
    {
      uint8_t src_i = mHash[i];
      m1_hash[i] = src_i;
    }
    uint8_t *m1_salt = m1 + (uint32_t)40U;
    for (uint32_t i = (uint32_t)0U; i < sLen; i = i + (uint32_t)1U)
    {
      uint8_t src_i = salt[i];
      m1_salt[i] = src_i;
    }
    Hacl_Impl_MGF_hash_sha256(m1Hash_, m1Len, m1);
    bool ite;
    if (!Hacl_Impl_Lib_eq_b(padLen, pad, pad2))
      ite = false;
    else
      ite = Hacl_Impl_Lib_eq_b((uint32_t)32U, m1Hash, m1Hash_);
    r = ite;
  }
  return r;
}

static void
Hacl_Impl_RSA_rsa_sign(
  uint32_t pow2_i,
  uint32_t modBits,
  uint32_t eBits,
  uint32_t dBits,
  uint32_t pLen,
  uint32_t qLen,
  uint64_t *skey,
  uint64_t rBlind,
  uint32_t sLen,
  uint8_t *salt,
  uint32_t msgLen,
  uint8_t *msg,
  uint8_t *sgnt
)
{
  uint32_t nLen = (modBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint32_t eLen = (eBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint32_t dLen = (dBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint32_t pkeyLen = nLen + eLen + nLen;
  uint64_t *n1 = skey;
  uint64_t *r2 = skey + nLen + eLen;
  uint64_t *d = skey + pkeyLen;
  uint64_t *p = skey + pkeyLen + dLen;
  uint64_t *q = skey + pkeyLen + dLen + pLen;
  uint32_t k = (modBits - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t emBits = modBits - (uint32_t)1U;
  uint32_t emLen = (emBits - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t n2Len = nLen + nLen;
  uint32_t pqLen = pLen + qLen;
  uint32_t stLen = n2Len + pqLen + pqLen + (uint32_t)2U;
  KRML_CHECK_SIZE(sizeof (uint8_t), emLen);
  uint8_t buf[emLen];
  memset(buf, 0U, emLen * sizeof buf[0U]);
  Hacl_Impl_RSA_pss_encode(sLen, salt, msgLen, msg, emBits, buf);
  KRML_CHECK_SIZE(sizeof (uint64_t), stLen);
  uint64_t buf1[stLen];
  memset(buf1, 0U, stLen * sizeof buf1[0U]);
  uint64_t *m = buf1;
  uint64_t *s = buf1 + nLen;
  uint64_t *phi_n = buf1 + n2Len;
  uint64_t *p1 = buf1 + n2Len + pqLen;
  uint64_t *q1 = buf1 + n2Len + pqLen + pLen;
  uint32_t dLen_ = pLen + qLen + (uint32_t)1U;
  uint64_t *d_ = buf1 + n2Len + pqLen;
  uint32_t bn1_start = n2Len + pqLen + pLen + qLen + (uint32_t)1U;
  uint64_t *bn1 = buf1 + bn1_start;
  Hacl_Impl_Convert_text_to_nat(emLen, buf, m);
  bn1[0U] = (uint64_t)1U;
  uint64_t uu____0 = Hacl_Impl_Addition_bn_sub(pLen, p, (uint32_t)1U, bn1, p1);
  uint64_t uu____1 = Hacl_Impl_Addition_bn_sub(qLen, q, (uint32_t)1U, bn1, q1);
  Hacl_Impl_Multiplication_bn_mul(pLen, p1, qLen, q1, phi_n);
  bn1[0U] = rBlind;
  Hacl_Impl_Multiplication_bn_mul(pqLen, phi_n, (uint32_t)1U, bn1, d_);
  uint64_t uu____2 = Hacl_Impl_Addition_bn_add(dLen_, d_, dLen, d, d_);
  Hacl_Impl_Exponentiation_mod_exp(pow2_i,
    modBits,
    nLen,
    n1,
    r2,
    m,
    dLen_ * (uint32_t)64U,
    d_,
    s);
  Hacl_Impl_Convert_nat_to_text(k, s, sgnt);
}

static bool
Hacl_Impl_RSA_rsa_verify(
  uint32_t pow2_i,
  uint32_t modBits,
  uint32_t eBits,
  uint64_t *pkey,
  uint32_t sLen,
  uint8_t *sgnt,
  uint32_t msgLen,
  uint8_t *msg
)
{
  uint32_t nLen = (modBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint32_t eLen = (eBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint64_t *n1 = pkey;
  uint64_t *e = pkey + nLen;
  uint64_t *r2 = pkey + nLen + eLen;
  uint32_t k = (modBits - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t emBits = modBits - (uint32_t)1U;
  uint32_t emLen = (emBits - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t n2Len = nLen + nLen;
  KRML_CHECK_SIZE(sizeof (uint64_t), n2Len);
  uint64_t buf[n2Len];
  memset(buf, 0U, n2Len * sizeof buf[0U]);
  KRML_CHECK_SIZE(sizeof (uint8_t), k);
  uint8_t buf1[k];
  memset(buf1, 0U, k * sizeof buf1[0U]);
  uint64_t *m = buf;
  uint64_t *s = buf + nLen;
  Hacl_Impl_Convert_text_to_nat(k, sgnt, s);
  bool r;
  if (Hacl_Impl_Comparison_bn_is_less(nLen, s, nLen, n1))
  {
    Hacl_Impl_Exponentiation_mod_exp(pow2_i, modBits, nLen, n1, r2, s, eBits, e, m);
    Hacl_Impl_Convert_nat_to_text(emLen, m, buf1);
    r = Hacl_Impl_RSA_pss_verify(sLen, msgLen, msg, emBits, buf1);
  }
  else
    r = false;
  bool r0 = r;
  return r0;
}

void
Hacl_RSAPSS_rsa_pss_sign(
  uint32_t pow2_i,
  uint32_t modBits,
  uint32_t eBits,
  uint32_t dBits,
  uint32_t pLen,
  uint32_t qLen,
  uint64_t *skey,
  uint64_t rBlind,
  uint32_t sLen,
  uint8_t *salt,
  uint32_t msgLen,
  uint8_t *msg,
  uint8_t *sgnt
)
{
  Hacl_Impl_RSA_rsa_sign(pow2_i,
    modBits,
    eBits,
    dBits,
    pLen,
    qLen,
    skey,
    rBlind,
    sLen,
    salt,
    msgLen,
    msg,
    sgnt);
}

bool
Hacl_RSAPSS_rsa_pss_verify(
  uint32_t pow2_i,
  uint32_t modBits,
  uint32_t eBits,
  uint64_t *pkey,
  uint32_t sLen,
  uint8_t *sgnt,
  uint32_t msgLen,
  uint8_t *msg
)
{
  bool res = Hacl_Impl_RSA_rsa_verify(pow2_i, modBits, eBits, pkey, sLen, sgnt, msgLen, msg);
  return res;
}
