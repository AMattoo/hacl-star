/* This file was auto-generated by KreMLin! */

#include "Hacl_RSAPSS.h"
#include <immintrin.h>
#include <x86intrin.h>
#include "Hacl_SHA2_256.h"

inline static bool
Hacl_Impl_Lib_bn_is_bit_set(Prims_nat len, uint32_t clen, uint64_t *input, uint32_t ind)
{
  uint32_t i = ind / (uint32_t)64U;
  uint32_t j = ind % (uint32_t)64U;
  uint64_t tmp = input[i];
  uint64_t x0 = tmp >> j & (uint64_t)1U;
  return x0 == (uint64_t)1U;
}

inline static void
Hacl_Impl_Lib_bn_set_bit(Prims_nat len, uint32_t clen, uint64_t *input, uint32_t ind)
{
  uint32_t i = ind / (uint32_t)64U;
  uint32_t j = ind % (uint32_t)64U;
  uint64_t tmp = input[i];
  input[i] = tmp | (uint64_t)1U << j;
}


inline static void Hacl_Impl_Lib_fill(Prims_nat len, uint32_t clen, uint64_t *b, uint64_t z)
{
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
    b[i] = z;
}

inline static bool
Hacl_Impl_Lib_eq_b_(Prims_nat len, uint32_t clen, uint8_t *b1, uint8_t *b2, uint32_t i)
{
  if (i < clen)
  {
    uint8_t uu____851 = b1[i];
    uint8_t uu____888 = b2[i];
    bool uu____850 = uu____851 == uu____888;
    if (uu____850)
      return Hacl_Impl_Lib_eq_b_(len, clen, b1, b2, i + (uint32_t)1U);
    else
      return false;
  }
  else
    return true;
}

inline bool Hacl_Impl_Lib_eq_b(Prims_nat len, uint32_t clen, uint8_t *b1, uint8_t *b2)
{
  return Hacl_Impl_Lib_eq_b_(len, clen, b1, b2, (uint32_t)0U);
}

static inline uint64_t bval(uint32_t cbLen, uint64_t* b, uint32_t i) {
  return (i < cbLen? b[i]: 0);
}


inline static void
Hacl_Impl_Addition_bn_sub_(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint32_t i,
  uint64_t carry,
  uint64_t *res
)
{
  uint8_t carry2 = carry;
  /*
  int mul4 = (caLen / 4) * 4;
  for(int i = 0; i < mul4; i=i+4) {
    carry2 = _subborrow_u64(carry2,bval(cbLen,b,i),a[i],&res[i]);
    carry2 = _subborrow_u64(carry2,bval(cbLen,b,i+1),a[i+1],&res[i+1]);
    carry2 = _subborrow_u64(carry2,bval(cbLen,b,i+2),a[i+2],&res[i+2]);
    carry2 = _subborrow_u64(carry2,bval(cbLen,b,i+3),a[i+3],&res[i+3]);
  }
  */
  for(int i = 0; i < caLen; i++) {
    carry2 = _subborrow_u64(carry2,bval(cbLen,b,i),a[i],&res[i]);
  }
  return carry2;
}

inline static void
Hacl_Impl_Addition_bn_sub(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint64_t *res
)
{
  Hacl_Impl_Addition_bn_sub_(aLen, bLen, caLen, a, cbLen, b, (uint32_t)0U, (uint64_t)0U, res);
}

inline static uint64_t
Hacl_Impl_Addition_bn_add_(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint32_t i,
  uint8_t carry,
  uint64_t *res
)
{
  uint8_t carry2 = carry;
  int mul4 = (caLen / 4) * 4;
  for(int i = 0; i < mul4; i=i+4) {
    carry2 = _addcarry_u64(carry2,a[i],bval(cbLen,b,i),&res[i]);
    carry2 = _addcarry_u64(carry2,a[i+1],bval(cbLen,b,i+1),&res[i+1]);
    carry2 = _addcarry_u64(carry2,a[i+2],bval(cbLen,b,i+2),&res[i+2]);
    carry2 = _addcarry_u64(carry2,a[i+3],bval(cbLen,b,i+3),&res[i+3]);
  }
  for(int i = mul4; i < caLen; i++) {
    carry2 = _addcarry_u64(carry2,a[i],bval(cbLen,b,i),&res[i]);
  }
  return carry2;
}

inline static void
Hacl_Impl_Addition_bn_add(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint64_t *res
)
{
  (void)Hacl_Impl_Addition_bn_add_(aLen,
    bLen,
    caLen,
    a,
    cbLen,
    b,
    (uint32_t)0U,
    (uint8_t)0U,
    res);
}

inline static void
Hacl_Impl_Addition_bn_add_carry(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint64_t *res
)
{
  uint64_t *res_ = res;
  uint64_t
  carry =
    Hacl_Impl_Addition_bn_add_(aLen,
      bLen,
      caLen,
      a,
      cbLen,
      b,
      (uint32_t)0U,
      (uint64_t)0U,
      res_);
  res[caLen] = carry;
}

inline static void
Hacl_Impl_Addition_bn_sub_u64_(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t carry,
  uint32_t i,
  uint64_t *res
)
{
  if (i < aaLen)
  {
    uint64_t t1 = a[i];
    uint64_t res_i = t1 - carry;
    res[i] = res_i;
    uint64_t carry1;
    if (t1 < carry)
      carry1 = (uint64_t)1U;
    else
      carry1 = (uint64_t)0U;
    Hacl_Impl_Addition_bn_sub_u64_(aLen, aaLen, a, carry1, i + (uint32_t)1U, res);
  }
}

inline static void
Hacl_Impl_Addition_bn_sub_u64(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t b,
  uint64_t *res
)
{
  Hacl_Impl_Addition_bn_sub_u64_(aLen, aaLen, a, b, (uint32_t)0U, res);
}

inline static bool
Hacl_Impl_Comparison_bn_is_less_(
  Prims_nat len,
  uint32_t clen,
  uint64_t *a,
  uint64_t *b,
  uint32_t i
)
{
  for (int j = i-1; j >= 0; j--) {
    uint64_t t1 = a[j];
    uint64_t t2 = b[j];
    if (!(t1 == t2))
      if (t1 < t2)
        return true;
      else
        return false;
  }
  return false;
}

inline static bool
Hacl_Impl_Comparison_bn_is_less(Prims_nat len, uint32_t clen, uint64_t *a, uint64_t *b)
{
  return Hacl_Impl_Comparison_bn_is_less_(len, clen, a, b, clen);
}

inline static bool
Hacl_Impl_Comparison_bn_is_less_ds_(
  Prims_nat a0Len,
  Prims_nat a1Len,
  uint32_t aa0Len,
  uint64_t *a0,
  uint32_t aa1Len,
  uint64_t *a1,
  uint32_t i
)
{
  if (i > (uint32_t)0U)
  {
    uint32_t i1 = i - (uint32_t)1U;
    uint64_t t1 = a0[i1];
    uint64_t t2;
    if (i1 < aa1Len)
      t2 = a1[i1];
    else
      t2 = (uint64_t)0U;
    if (!(t1 == t2))
      if (t1 < t2)
        return true;
      else
        return false;
    else
      return Hacl_Impl_Comparison_bn_is_less_ds_(a0Len, a1Len, aa0Len, a0, aa1Len, a1, i1);
  }
  else
    return false;
}

inline static bool
Hacl_Impl_Comparison_bn_is_less_ds(
  Prims_nat a0Len,
  Prims_nat a1len,
  uint32_t aa0Len,
  uint64_t *a0,
  uint32_t aa1Len,
  uint64_t *a1
)
{
  return Hacl_Impl_Comparison_bn_is_less_ds_(a0Len, a1len, aa0Len, a0, aa1Len, a1, aa0Len);
}

inline static void
Hacl_Impl_Convert_text_to_nat_(
  Prims_nat len,
  uint32_t clen,
  uint8_t *input,
  uint32_t resLen,
  uint64_t *res,
  uint32_t i
)
{
  if (i < resLen)
  {
    uint64_t inputi = load64_be(input + (uint32_t)8U * i);
    uint32_t ind = resLen - i - (uint32_t)1U;
    res[ind] = inputi;
    Hacl_Impl_Convert_text_to_nat_(len, clen, input, resLen, res, i + (uint32_t)1U);
  }
}

void Hacl_Impl_Convert_text_to_nat(Prims_nat len, uint32_t clen, uint8_t *input, uint64_t *res)
{
  uint32_t num_words = (clen - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t tmpLen = (uint32_t)8U * num_words;
  uint32_t m = clen % (uint32_t)8U;
  uint32_t ind;
  if (m == (uint32_t)0U)
    ind = (uint32_t)0U;
  else
    ind = (uint32_t)8U - m;
  KRML_CHECK_SIZE((uint8_t)0U, tmpLen);
  uint8_t buf[tmpLen];
  memset(buf, 0U, tmpLen * sizeof buf[0U]);
  (void)(tmpLen - ind);
  uint8_t *tmp_ = buf + ind;
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = input[i];
    tmp_[i] = src_i;
  }
  Hacl_Impl_Convert_text_to_nat_((tmpLen),
    tmpLen,
    buf,
    num_words,
    res,
    (uint32_t)0U);
}

inline static void
Hacl_Impl_Convert_nat_to_text_(
  Prims_nat len,
  uint32_t clen,
  uint64_t *input,
  uint32_t resLen,
  uint8_t *res,
  uint32_t i
)
{
  if (i < clen)
  {
    uint32_t ind = clen - i - (uint32_t)1U;
    uint64_t tmp = input[ind];
    store64_be(res + (uint32_t)8U * i, tmp);
    Hacl_Impl_Convert_nat_to_text_(len, clen, input, resLen, res, i + (uint32_t)1U);
  }
}

inline static void
Hacl_Impl_Convert_nat_to_text(Prims_nat len, uint32_t clen, uint64_t *input, uint8_t *res)
{
  uint32_t num_words = (clen - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t tmpLen = (uint32_t)8U * num_words;
  uint32_t m = clen % (uint32_t)8U;
  uint32_t ind;
  if (m == (uint32_t)0U)
    ind = (uint32_t)0U;
  else
    ind = (uint32_t)8U - m;
  KRML_CHECK_SIZE((uint8_t)0U, tmpLen);
  uint8_t buf[tmpLen];
  memset(buf, 0U, tmpLen * sizeof buf[0U]);
  Hacl_Impl_Convert_nat_to_text_(((clen - (uint32_t)1U)
      / (uint32_t)8U
      + (uint32_t)1U),
    num_words,
    input,
    tmpLen,
    buf,
    (uint32_t)0U);
  (void)(tmpLen - ind);
  uint8_t *tmp_ = buf + ind;
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = tmp_[i];
    res[i] = src_i;
  }
}

inline static void
Hacl_Impl_Multiplication_bn_mult_by_limb_addj(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t l,
  uint32_t i,
  uint32_t j,
  uint32_t resLen,
  uint64_t carry,
  uint64_t *res
)
{
  uint32_t ij = i + j;
  if (i < aaLen)
  {
    uint64_t res_ij = res[ij];
    uint64_t uu____258 = a[i];
    FStar_UInt128_t u =
      FStar_UInt128_add(FStar_UInt128_add(FStar_UInt128_mul_wide(uu____258,
                  l),
                FStar_UInt128_uint64_to_uint128(carry)),
			FStar_UInt128_uint64_to_uint128(res_ij));
    uint64_t carry_ = FStar_UInt128_uint128_to_uint64(FStar_UInt128_shift_right(u,(uint32_t)64U));
    uint64_t res_ij1 = FStar_UInt128_uint128_to_uint64(u);
    res[ij] = res_ij1;
    Hacl_Impl_Multiplication_bn_mult_by_limb_addj(aLen,
      aaLen,
      a,
      l,
      i + (uint32_t)1U,
      j,
      resLen,
      carry_,
      res);
  }
  else
    res[ij] = carry;
}

inline static void
Hacl_Impl_Multiplication_bn_mult_(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t bbLen,
  uint64_t *b,
  uint32_t j,
  uint32_t resLen,
  uint64_t *res
)
{
  if (j < bbLen)
  {
    uint64_t uu____705 = b[j];
    Hacl_Impl_Multiplication_bn_mult_by_limb_addj(aLen,
      aaLen,
      a,
      uu____705,
      (uint32_t)0U,
      j,
      resLen,
      (uint64_t)0U,
      res);
    Hacl_Impl_Multiplication_bn_mult_(aLen,
      bLen,
      aaLen,
      a,
      bbLen,
      b,
      j + (uint32_t)1U,
      resLen,
      res);
  }
}

inline static void
Hacl_Impl_Multiplication_bn_mul(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t bbLen,
  uint64_t *b,
  uint64_t *res
)
{
  uint32_t resLen = aaLen + bbLen;
  //  Hacl_Impl_Lib_fill(Prims_op_Addition(aLen, bLen), resLen, res, (uint64_t)0U);
  memset(res,0,8*resLen);
  Hacl_Impl_Multiplication_bn_mult_(aLen, bLen, aaLen, a, bbLen, b, (uint32_t)0U, resLen, res);
}

static void
Hacl_Impl_Multiplication_bn_mul_u64(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t b,
  uint64_t *res
)
{
  uint32_t resLen = aaLen + (uint32_t)1U;
  memset(res,0,8*resLen);
  //  Hacl_Impl_Lib_fill(Prims_op_Addition(aLen, (krml_checked_int_t)1), resLen, res, (uint64_t)0U);
  Hacl_Impl_Multiplication_bn_mult_by_limb_addj(aLen,
    aaLen,
    a,
    b,
    (uint32_t)0U,
    (uint32_t)0U,
    resLen,
    (uint64_t)0U,
    res);
}

static void
Hacl_Impl_Multiplication_abs(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t bbLen,
  uint64_t *b,
  uint64_t *res
)
{
  bool uu____1859 = Hacl_Impl_Comparison_bn_is_less_ds(aLen, aLen, aaLen, a, bbLen, b);
  if (uu____1859)
    Hacl_Impl_Addition_bn_sub(aLen, aLen, bbLen, b, aaLen, a, res);
  else
    Hacl_Impl_Addition_bn_sub(aLen, aLen, aaLen, a, bbLen, b, res);
}

static void
Hacl_Impl_Multiplication_add_sign(
  Prims_nat a0Len,
  Prims_nat a1Len,
  Prims_nat resLen,
  uint32_t aa0Len,
  uint32_t aa1Len,
  uint32_t rresLen,
  uint64_t *c0,
  uint64_t *c1,
  uint64_t *c2,
  uint64_t *a0,
  uint64_t *a1,
  uint64_t *a2,
  uint64_t *b0,
  uint64_t *b1,
  uint64_t *b2,
  uint64_t *res
)
{
  uint32_t c0Len = aa0Len + aa0Len;
  uint32_t c1Len = aa1Len + aa1Len;
  bool uu____2867 = Hacl_Impl_Comparison_bn_is_less_ds(a0Len, a1Len, aa0Len, a0, aa1Len, a1);
  Hacl_Impl_Multiplication_sign sa2;
  if (uu____2867)
    sa2 = Hacl_Impl_Multiplication_Negative;
  else
    sa2 = Hacl_Impl_Multiplication_Positive;
  bool uu____2952 = Hacl_Impl_Comparison_bn_is_less_ds(a0Len, a1Len, aa0Len, b0, aa1Len, b1);
  Hacl_Impl_Multiplication_sign sb2;
  if (uu____2952)
    sb2 = Hacl_Impl_Multiplication_Negative;
  else
    sb2 = Hacl_Impl_Multiplication_Positive;
  Hacl_Impl_Addition_bn_add_carry(Prims_op_Addition(a0Len, a0Len),
    Prims_op_Addition(a1Len, a1Len),
    c0Len,
    c0,
    c1Len,
    c1,
    res);
  if
  (sa2
  == Hacl_Impl_Multiplication_Positive
  && sb2 == Hacl_Impl_Multiplication_Positive
  || sa2 == Hacl_Impl_Multiplication_Negative && sb2 == Hacl_Impl_Multiplication_Negative)
    Hacl_Impl_Addition_bn_sub((rresLen),
      Prims_op_Addition(a0Len, a0Len),
      rresLen,
      res,
      c0Len,
      c2,
      res);
  else
    Hacl_Impl_Addition_bn_add((rresLen),
      Prims_op_Addition(a0Len, a0Len),
      rresLen,
      res,
      c0Len,
      c2,
      res);
}

static void
Hacl_Impl_Multiplication_karatsuba_(
  Prims_nat aLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t *b,
  uint64_t *tmp,
  uint64_t *res
)
{
  (void)((uint32_t)4U * pow2_i);
  (void)(aaLen + aaLen);
  uint32_t pow2_i0 = pow2_i / (uint32_t)2U;
  uint32_t pow2_i1 = pow2_i0 - iLen;
  if (aaLen < (uint32_t)32U)
    Hacl_Impl_Multiplication_bn_mul(aLen, aLen, aaLen, a, aaLen, b, res);
  else
  {
    uint64_t *a0 = a;
    uint64_t *a1 = a + pow2_i0;
    uint64_t *b0 = b;
    uint64_t *b1 = b + pow2_i0;
    uint64_t *tmp0 = tmp;
    uint64_t *c0 = res;
    Hacl_Impl_Multiplication_karatsuba_((pow2_i0),
      pow2_i0,
      (uint32_t)0U,
      pow2_i0,
      a0,
      b0,
      tmp0,
      c0);
    if (pow2_i1 == (uint32_t)1U)
    {
      uint64_t a1_0 = a1[0U];
      uint64_t b1_0 = b1[0U];
      FStar_UInt128_t c1 = FStar_UInt128_mul_wide(a1_0, b1_0);
      uint64_t c1_0 = FStar_UInt128_uint128_to_uint64(c1);
      uint64_t c1_1 = FStar_UInt128_uint128_to_uint64(FStar_UInt128_shift_right(c1, (uint32_t)64U));
      uint32_t c0Len = (uint32_t)2U * pow2_i0;
      res[c0Len] = c1_0;
      res[c0Len + (uint32_t)1U] = c1_1;
      uint64_t *tmp01 = tmp;
      Hacl_Impl_Multiplication_bn_mul_u64((pow2_i0), pow2_i0, a0, b1_0, tmp01);
      uint64_t *tmp1 = tmp + pow2_i0 + (uint32_t)1U;
      Hacl_Impl_Multiplication_bn_mul_u64((pow2_i0), pow2_i0, b0, a1_0, tmp1);
      uint32_t tmp1Len = pow2_i0 + (uint32_t)1U;
      uint32_t tmp1Len2 = tmp1Len + tmp1Len;
      uint32_t tmp2Len = pow2_i0 + (uint32_t)2U;
      uint64_t *tmp2 = tmp + tmp1Len2;
      Hacl_Impl_Addition_bn_add_carry((tmp1Len),
        (tmp1Len),
        tmp1Len,
        tmp01,
        tmp1Len,
        tmp1,
        tmp2);
      uint32_t res1Len = pow2_i0 + (uint32_t)2U;
      uint64_t *res1 = res + pow2_i0;
      Hacl_Impl_Addition_bn_add((res1Len),
        (tmp2Len),
        res1Len,
        res1,
        tmp2Len,
        tmp2,
        res1);
    }
    else
    {
      if (pow2_i0 / (uint32_t)2U <= iLen)
        (void)(iLen - pow2_i0 / (uint32_t)2U);
      uint64_t *tmp01 = tmp;
      uint64_t *c1 = res + (uint32_t)2U * pow2_i0;
      Hacl_Impl_Multiplication_karatsuba_((pow2_i1),
        pow2_i0,
        iLen,
        pow2_i1,
        a1,
        b1,
        tmp01,
        c1);
      uint64_t *a2 = tmp;
      uint64_t *b2 = tmp + pow2_i0;
      Hacl_Impl_Multiplication_abs((pow2_i0),
        (pow2_i1),
        pow2_i0,
        a0,
        pow2_i1,
        a1,
        a2);
      Hacl_Impl_Multiplication_abs((pow2_i0),
        (pow2_i1),
        pow2_i0,
        b0,
        pow2_i1,
        b1,
        b2);
      uint64_t *c2 = tmp + (uint32_t)2U * pow2_i0;
      uint64_t *tmp02 = tmp + (uint32_t)4U * pow2_i0;
      Hacl_Impl_Multiplication_karatsuba_((pow2_i0),
        pow2_i0,
        (uint32_t)0U,
        pow2_i0,
        a2,
        b2,
        tmp02,
        c2);
      uint32_t tmp1Len = pow2_i + (uint32_t)1U;
      uint64_t *tmp1 = tmp + (uint32_t)4U * pow2_i0;
      Hacl_Impl_Multiplication_add_sign((pow2_i0),
        (pow2_i1),
        (tmp1Len),
        pow2_i0,
        pow2_i1,
        tmp1Len,
        c0,
        c1,
        c2,
        a0,
        a1,
        a2,
        b0,
        b1,
        b2,
        tmp1);
      uint32_t res1Len = pow2_i0 + pow2_i1 + pow2_i1;
      uint64_t *res1 = res + pow2_i0;
      Hacl_Impl_Addition_bn_add((res1Len),
        (tmp1Len),
        res1Len,
        res1,
        tmp1Len,
        tmp1,
        res1);
    }
  }
}

static void
Hacl_Impl_Multiplication_karatsuba(
  Prims_nat aLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t *b,
  uint64_t *st_mult,
  uint64_t *res
)
{
  if (aaLen < (uint32_t)32U)
    Hacl_Impl_Multiplication_bn_mul(aLen, aLen, aaLen, a, aaLen, b, res);
  else
    Hacl_Impl_Multiplication_karatsuba_(aLen, pow2_i, iLen, aaLen, a, b, st_mult, res);
}

static const uint64_t Hacl_Impl_Shift_bn_tbit = (uint64_t)0x8000000000000000U;

static void
Hacl_Impl_Shift_bn_lshift_(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t count1,
  uint32_t nw,
  uint32_t lb,
  uint64_t *res
)
{
  if (count1 > (uint32_t)0U)
  {
    uint32_t i = nw + count1;
    uint64_t tmp = res[i];
    uint32_t count2 = i - (uint32_t)1U;
    uint64_t t1 = a[count2];
    uint32_t rb = (uint32_t)64U - lb;
    res[i] = tmp | t1 >> rb;
    res[i - (uint32_t)1U] = t1 << lb;
    Hacl_Impl_Shift_bn_lshift_(aLen, aaLen, a, count2, nw, lb, res);
  }
}

static void
Hacl_Impl_Shift_bn_lshift(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t nCount,
  uint64_t *res
)
{
  if (nCount == (uint32_t)0U)
    for (uint32_t i = (uint32_t)0U; i < aaLen; i = i + (uint32_t)1U)
    {
      uint64_t src_i = a[i];
      res[i] = src_i;
    }
  else
  {
    uint32_t nw = nCount / (uint32_t)64U;
    uint32_t lb = nCount % (uint32_t)64U;
    if (lb == (uint32_t)0U)
    {
      memset(res,0,8*aaLen);
      //      Hacl_Impl_Lib_fill(aLen, aaLen, res, (uint64_t)0U);
      uint32_t aLen_ = aaLen - nw;
      uint64_t *a_ = a;
      uint64_t *res_ = res + nw;
      for (uint32_t i = (uint32_t)0U; i < aLen_; i = i + (uint32_t)1U)
      {
        uint64_t src_i = a_[i];
        res_[i] = src_i;
      }
    }
    else
    {
      uint32_t count1 = aaLen - (nw - (uint32_t)1U);
      Hacl_Impl_Shift_bn_lshift_(aLen, aaLen, a, count1, nw, lb, res);
    }
  }
}

static void
Hacl_Impl_Shift_bn_lshift1_(
  Prims_nat aLen,
  uint32_t caLen,
  uint64_t *a,
  uint64_t carry,
  uint32_t i,
  uint64_t *res
)
{
  if (i < caLen)
  {
    uint64_t tmp = a[i];
    res[i] = tmp << (uint32_t)1U | carry;
    uint64_t carry1;
    uint64_t x0 = tmp & Hacl_Impl_Shift_bn_tbit;
    if (x0 == Hacl_Impl_Shift_bn_tbit)
      carry1 = (uint64_t)1U;
    else
      carry1 = (uint64_t)0U;
    Hacl_Impl_Shift_bn_lshift1_(aLen, caLen, a, carry1, i + (uint32_t)1U, res);
  }
}

static void
Hacl_Impl_Shift_bn_lshift1(Prims_nat aLen, uint32_t caLen, uint64_t *a, uint64_t *res)
{
  Hacl_Impl_Shift_bn_lshift1_(aLen, caLen, a, (uint64_t)0U, (uint32_t)0U, res);
}

static void
Hacl_Impl_Shift_bn_rshift_(
  Prims_nat aLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t i,
  uint32_t nw,
  uint32_t rb,
  uint64_t l,
  uint64_t *res
)
{
  if (i < caLen - nw)
  {
    uint64_t tmp = l >> rb;
    uint64_t l1 = a[nw + i];
    uint32_t lb = (uint32_t)64U - rb;
    res[i - (uint32_t)1U] = tmp | l1 << lb;
    Hacl_Impl_Shift_bn_rshift_(aLen, caLen, a, i + (uint32_t)1U, nw, rb, l1, res);
  }
  else
    res[i - (uint32_t)1U] = l >> rb;
}

static void
Hacl_Impl_Shift_bn_rshift(
  Prims_nat aLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t nCount,
  uint64_t *res
)
{
  if (nCount == (uint32_t)0U)
    for (uint32_t i = (uint32_t)0U; i < caLen; i = i + (uint32_t)1U)
    {
      uint64_t src_i = a[i];
      res[i] = src_i;
    }
  else
  {
    uint32_t nw = nCount / (uint32_t)64U;
    uint32_t rb = nCount % (uint32_t)64U;
    if (rb == (uint32_t)0U)
    {
      uint32_t a_Len = caLen - nw;
      uint64_t *a_ = a + nw;
      uint64_t *res_ = res;
      for (uint32_t i = (uint32_t)0U; i < a_Len; i = i + (uint32_t)1U)
      {
        uint64_t src_i = a_[i];
        res_[i] = src_i;
      }
    }
    else
    {
      uint64_t l = a[nw];
      Hacl_Impl_Shift_bn_rshift_(aLen, caLen, a, (uint32_t)1U, nw, rb, l, res);
    }
  }
}

static void
Hacl_Impl_Shift_bn_mod_pow2_n(
  Prims_nat aLen,
  Prims_nat resLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t nCount,
  uint32_t cresLen,
  uint64_t *res
)
{
  uint32_t nw = nCount / (uint32_t)64U;
  uint32_t nb = nCount % (uint32_t)64U;
  uint64_t *a_ = a;
  for (uint32_t i = (uint32_t)0U; i < cresLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = a_[i];
    res[i] = src_i;
  }
  uint32_t start_i;
  if (nb > (uint32_t)0U)
  {
    uint32_t lb = (uint32_t)64U - nb;
    uint64_t uu____2843 = res[nw];
    uint64_t uu____2842 = uu____2843 & (uint64_t)0xffffffffffffffffU >> lb;
    res[nw] = uu____2842;
    start_i = nw + (uint32_t)1U;
  }
  else
    start_i = nw;
  if (start_i < cresLen)
  {
    uint32_t res_Len = cresLen - start_i;
    uint64_t *res_ = res + start_i;
    memset(res_,0,8*res_Len);
    //    Hacl_Impl_Lib_fill((res_Len), res_Len, res_, (uint64_t)0U);
  }
}

static void
Hacl_Impl_Montgomery_bn_pow2_mod_n_(
  Prims_nat rLen,
  uint32_t clen,
  uint64_t *a,
  uint32_t i,
  uint32_t p,
  uint64_t *r
)
{
  if (i < p)
  {
    Hacl_Impl_Shift_bn_lshift1(rLen, clen, r, r);
    bool uu____251 = Hacl_Impl_Comparison_bn_is_less(rLen, clen, r, a);
    bool uu____250 = !uu____251;
    if (uu____250)
      Hacl_Impl_Addition_bn_sub(rLen, rLen, clen, r, clen, a, r);
    Hacl_Impl_Montgomery_bn_pow2_mod_n_(rLen, clen, a, i + (uint32_t)1U, p, r);
  }
}

static void
Hacl_Impl_Montgomery_bn_pow2_mod_n(
  Prims_nat rLen,
  uint32_t aBits,
  uint32_t rLen1,
  uint64_t *a,
  uint32_t p,
  uint64_t *r
)
{
  Hacl_Impl_Lib_bn_set_bit(rLen, rLen1, r, aBits);
  Hacl_Impl_Addition_bn_sub(rLen, rLen, rLen1, r, rLen1, a, r);
  Hacl_Impl_Montgomery_bn_pow2_mod_n_(rLen, rLen1, a, aBits, p, r);
}

static inline uint32_t
Hacl_Impl_Montgomery_degree_(Prims_nat aLen, uint32_t aaLen, uint64_t *a, uint32_t i)
{
  if (i == (uint32_t)0U)
    return (uint32_t)0U;
  else
  {
    bool uu____1044 = Hacl_Impl_Lib_bn_is_bit_set(aLen, aaLen, a, i);
    if (uu____1044)
      return i;
    else
      return Hacl_Impl_Montgomery_degree_(aLen, aaLen, a, i - (uint32_t)1U);
  }
}

static inline uint32_t
Hacl_Impl_Montgomery_degree(Prims_nat aLen, uint32_t aaLen, uint64_t *a, uint32_t aBits)
{
  return Hacl_Impl_Montgomery_degree_(aLen, aaLen, a, aBits);
}

static void
Hacl_Impl_Montgomery_shift_euclidean_mod_inv_f(
  Prims_nat rLen,
  uint32_t rrLen,
  uint64_t *m,
  uint64_t *tmp,
  uint32_t f1,
  uint32_t i
)
{
  if (i < f1)
  {
    Hacl_Impl_Addition_bn_add(rLen, rLen, rrLen, tmp, rrLen, tmp, tmp);
    bool uu____1563 = Hacl_Impl_Comparison_bn_is_less(rLen, rrLen, m, tmp);
    if (uu____1563)
      Hacl_Impl_Addition_bn_sub(rLen, rLen, rrLen, tmp, rrLen, m, tmp);
    Hacl_Impl_Montgomery_shift_euclidean_mod_inv_f(rLen, rrLen, m, tmp, f1, i + (uint32_t)1U);
  }
}

static void
Hacl_Impl_Montgomery_shift_euclidean_mod_inv_(
  Prims_nat rLen,
  uint32_t rrLen,
  uint32_t uBits,
  uint64_t *ub,
  uint32_t vBits,
  uint64_t *vb,
  uint64_t *r,
  uint64_t *s,
  uint64_t *m,
  uint64_t *st_inv,
  uint64_t *res
)
{
  (void)(rrLen + rrLen);
  uint64_t *v_shift_f = st_inv;
  uint64_t *tmp = st_inv + rrLen;
  uint32_t du = Hacl_Impl_Montgomery_degree(rLen, rrLen, ub, uBits);
  uint32_t dv = Hacl_Impl_Montgomery_degree(rLen, rrLen, vb, vBits);
  if (dv > (uint32_t)0U)
  {
    uint32_t f1 = du - dv;
    Hacl_Impl_Shift_bn_lshift(rLen, rrLen, vb, f1, v_shift_f);
    bool uu____2592 = Hacl_Impl_Comparison_bn_is_less(rLen, rrLen, ub, v_shift_f);
    uint32_t f20;
    if (uu____2592)
    {
      uint32_t f2 = f1 - (uint32_t)1U;
      Hacl_Impl_Shift_bn_lshift(rLen, rrLen, vb, f2, v_shift_f);
      f20 = f2;
    }
    else
      f20 = f1;
    Hacl_Impl_Addition_bn_sub(rLen, rLen, rrLen, ub, rrLen, v_shift_f, ub);
    for (uint32_t i = (uint32_t)0U; i < rrLen; i = i + (uint32_t)1U)
    {
      uint64_t src_i = s[i];
      tmp[i] = src_i;
    }
    if (f20 > (uint32_t)0U)
      Hacl_Impl_Montgomery_shift_euclidean_mod_inv_f(rLen, rrLen, m, tmp, f20, (uint32_t)0U);
    bool uu____2879 = Hacl_Impl_Comparison_bn_is_less(rLen, rrLen, r, tmp);
    if (uu____2879)
    {
      Hacl_Impl_Addition_bn_add(rLen, rLen, rrLen, r, rrLen, m, r);
      Hacl_Impl_Addition_bn_sub(rLen, rLen, rrLen, r, rrLen, tmp, r);
    }
    else
      Hacl_Impl_Addition_bn_sub(rLen, rLen, rrLen, r, rrLen, tmp, r);
    uint32_t du1 = Hacl_Impl_Montgomery_degree(rLen, rrLen, ub, uBits);
    bool uu____3255 = Hacl_Impl_Comparison_bn_is_less(rLen, rrLen, ub, vb);
    if (uu____3255)
      Hacl_Impl_Montgomery_shift_euclidean_mod_inv_(rLen,
        rrLen,
        dv,
        vb,
        du1,
        ub,
        s,
        r,
        m,
        st_inv,
        res);
    else
      Hacl_Impl_Montgomery_shift_euclidean_mod_inv_(rLen,
        rrLen,
        du1,
        ub,
        dv,
        vb,
        r,
        s,
        m,
        st_inv,
        res);
  }
  else
    for (uint32_t i = (uint32_t)0U; i < rrLen; i = i + (uint32_t)1U)
    {
      uint64_t src_i = s[i];
      res[i] = src_i;
    }
}

static void
Hacl_Impl_Montgomery_shift_euclidean_mod_inv(
  Prims_nat rLen,
  uint32_t rrLen,
  uint32_t aBits,
  uint64_t *a,
  uint32_t mBits,
  uint64_t *m,
  uint64_t *res
)
{
  uint32_t stLen = (uint32_t)6U * rrLen;
  KRML_CHECK_SIZE((uint64_t)0U, stLen);
  uint64_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  uint64_t *ub = buf;
  uint64_t *vb = buf + rrLen;
  uint64_t *r = buf + rrLen + rrLen;
  uint64_t *s = buf + (uint32_t)3U * rrLen;
  uint64_t *st_inv = buf + (uint32_t)4U * rrLen;
  for (uint32_t i = (uint32_t)0U; i < rrLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = m[i];
    ub[i] = src_i;
  }
  for (uint32_t i = (uint32_t)0U; i < rrLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = a[i];
    vb[i] = src_i;
  }
  s[0U] = (uint64_t)1U;
  Hacl_Impl_Montgomery_shift_euclidean_mod_inv_(rLen,
    rrLen,
    mBits,
    ub,
    aBits,
    vb,
    r,
    s,
    m,
    st_inv,
    res);
}

static void
Hacl_Impl_Montgomery_mont_reduction(
  Prims_nat rLen,
  Prims_nat cLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t exp_r,
  uint32_t rrLen,
  uint64_t *st_mont,
  uint64_t *st,
  uint64_t *st_kara,
  uint32_t ccLen,
  uint64_t *c,
  uint64_t *res
)
{
  uint32_t r2Len = rrLen + rrLen;
  (void)((uint32_t)3U * rrLen);
  uint64_t *tmp1 = st;
  uint64_t *m = st + r2Len;
  uint64_t *r = st_mont;
  uint64_t *n1 = st_mont + rrLen;
  uint64_t *nInv = st_mont + r2Len;
  uint64_t *c1 = c;
  Hacl_Impl_Multiplication_karatsuba(rLen, pow2_i, iLen, rrLen, c1, nInv, st_kara, tmp1);
  Hacl_Impl_Shift_bn_mod_pow2_n((r2Len), rLen, r2Len, tmp1, exp_r, rrLen, m);
  Hacl_Impl_Addition_bn_sub(rLen, rLen, rrLen, r, rrLen, m, m);
  Hacl_Impl_Multiplication_karatsuba(rLen, pow2_i, iLen, rrLen, m, n1, st_kara, tmp1);
  Hacl_Impl_Addition_bn_add((r2Len), cLen, r2Len, tmp1, ccLen, c, tmp1);
  Hacl_Impl_Shift_bn_rshift((r2Len), r2Len, tmp1, exp_r, tmp1);
  uint64_t *tmp1_ = tmp1;
  for (uint32_t i = (uint32_t)0U; i < rrLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = tmp1_[i];
    res[i] = src_i;
  }
}

static void
Hacl_Impl_Montgomery_to_mont(
  Prims_nat rLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t exp_r,
  uint32_t rrLen,
  uint64_t *st_mont,
  uint64_t *st,
  uint64_t *st_kara,
  uint64_t *r2,
  uint64_t *a,
  uint64_t *aM
)
{
  uint32_t cLen = rrLen + rrLen;
  (void)((uint32_t)3U * rrLen);
  uint64_t *c = st;
  uint64_t *st1 = st + cLen;
  Hacl_Impl_Multiplication_karatsuba(rLen, pow2_i, iLen, rrLen, a, r2, st_kara, c);
  Hacl_Impl_Montgomery_mont_reduction(rLen,
    (cLen),
    pow2_i,
    iLen,
    exp_r,
    rrLen,
    st_mont,
    st1,
    st_kara,
    cLen,
    c,
    aM);
}

static void
Hacl_Impl_Montgomery_from_mont(
  Prims_nat rLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t exp_r,
  uint32_t rrLen,
  uint64_t *st_mont,
  uint64_t *st,
  uint64_t *st_kara,
  uint64_t *aM,
  uint64_t *a
)
{
  uint32_t r2Len = rrLen + rrLen;
  (void)((uint32_t)3U * rrLen);
  uint64_t *tmp = st;
  uint64_t *m = st + r2Len;
  uint64_t *r = st_mont;
  uint64_t *n1 = st_mont + rrLen;
  uint64_t *nInv = st_mont + r2Len;
  Hacl_Impl_Multiplication_karatsuba(rLen, pow2_i, iLen, rrLen, aM, nInv, st_kara, tmp);
  Hacl_Impl_Shift_bn_mod_pow2_n((r2Len), rLen, r2Len, tmp, exp_r, rrLen, m);
  Hacl_Impl_Addition_bn_sub(rLen, rLen, rrLen, r, rrLen, m, m);
  Hacl_Impl_Multiplication_karatsuba(rLen, pow2_i, iLen, rrLen, m, n1, st_kara, tmp);
  Hacl_Impl_Addition_bn_add((r2Len), rLen, r2Len, tmp, rrLen, aM, tmp);
  Hacl_Impl_Shift_bn_rshift((r2Len), r2Len, tmp, exp_r, tmp);
  uint64_t *tmp_ = tmp;
  for (uint32_t i = (uint32_t)0U; i < rrLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = tmp_[i];
    a[i] = src_i;
  }
}

static void
Hacl_Impl_Exponentiation_mul_mod_mont(
  Prims_nat rLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t exp_r,
  uint32_t rrLen,
  uint64_t *st_mont,
  uint64_t *st_m,
  uint64_t *st_kara,
  uint64_t *aM,
  uint64_t *bM,
  uint64_t *resM
)
{
  uint32_t cLen = rrLen + rrLen;
  uint32_t stKLen = (uint32_t)4U * pow2_i;
  (void)(cLen + stKLen);
  uint64_t *c = st_kara;
  uint64_t *st_k = st_kara + cLen;
  Hacl_Impl_Multiplication_karatsuba(rLen, pow2_i, iLen, rrLen, aM, bM, st_k, c);
  Hacl_Impl_Montgomery_mont_reduction(rLen,
    (cLen),
    pow2_i,
    iLen,
    exp_r,
    rrLen,
    st_mont,
    st_m,
    st_k,
    cLen,
    c,
    resM);
}

static void
Hacl_Impl_Exponentiation_mod_exp_(
  Prims_nat rLen,
  Prims_nat bLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t exp_r,
  uint32_t rrLen,
  uint64_t *st_mont,
  uint64_t *st_exp,
  uint64_t *st_m,
  uint64_t *st_kara,
  uint32_t bBits,
  uint32_t bbLen,
  uint64_t *b,
  uint32_t count1
)
{
  uint64_t *aM = st_exp;
  uint64_t *accM = st_exp + rrLen;
  if (count1 < bBits)
  {
    bool uu____1172 = Hacl_Impl_Lib_bn_is_bit_set(bLen, bbLen, b, count1);
    if (uu____1172)
      Hacl_Impl_Exponentiation_mul_mod_mont(rLen,
        pow2_i,
        iLen,
        exp_r,
        rrLen,
        st_mont,
        st_m,
        st_kara,
        aM,
        accM,
        accM);
    Hacl_Impl_Exponentiation_mul_mod_mont(rLen,
      pow2_i,
      iLen,
      exp_r,
      rrLen,
      st_mont,
      st_m,
      st_kara,
      aM,
      aM,
      aM);
    Hacl_Impl_Exponentiation_mod_exp_(rLen,
      bLen,
      pow2_i,
      iLen,
      exp_r,
      rrLen,
      st_mont,
      st_exp,
      st_m,
      st_kara,
      bBits,
      bbLen,
      b,
      count1 + (uint32_t)1U);
  }
}

static void
Hacl_Impl_Exponentiation_mod_exp_mont(
  Prims_nat rLen,
  Prims_nat stLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t bBits,
  uint64_t *b,
  uint32_t exp_r,
  uint32_t rrLen,
  uint32_t sstLen,
  uint64_t *st
)
{
  uint32_t bLen = (bBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  (void)(st + (uint32_t)2U * rrLen);
  uint64_t *r2 = st + (uint32_t)3U * rrLen;
  uint64_t *a1 = st + (uint32_t)4U * rrLen;
  uint64_t *acc = st + (uint32_t)5U * rrLen;
  uint64_t *aM = st + (uint32_t)6U * rrLen;
  uint64_t *accM = st + (uint32_t)7U * rrLen;
  uint64_t *res1 = st + (uint32_t)8U * rrLen;
  uint64_t *st_mont = st;
  uint64_t *st_exp = st + (uint32_t)6U * rrLen;
  uint32_t stKLen = (uint32_t)2U * rrLen + (uint32_t)4U * pow2_i;
  uint64_t *st_kara = st + (uint32_t)9U * rrLen;
  uint32_t stLLen = stKLen + (uint32_t)9U * rrLen;
  uint64_t *st_t = st + stLLen;
  uint64_t *st_f = st + stLLen;
  Hacl_Impl_Montgomery_to_mont(rLen,
    pow2_i,
    iLen,
    exp_r,
    rrLen,
    st_mont,
    st_t,
    st_kara,
    r2,
    a1,
    aM);
  Hacl_Impl_Montgomery_to_mont(rLen,
    pow2_i,
    iLen,
    exp_r,
    rrLen,
    st_mont,
    st_t,
    st_kara,
    r2,
    acc,
    accM);
  Hacl_Impl_Exponentiation_mod_exp_(rLen,
    ((bBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U),
    pow2_i,
    iLen,
    exp_r,
    rrLen,
    st_mont,
    st_exp,
    st_f,
    st_kara,
    bBits,
    bLen,
    b,
    (uint32_t)0U);
  Hacl_Impl_Montgomery_from_mont(rLen,
    pow2_i,
    iLen,
    exp_r,
    rrLen,
    st_mont,
    st_f,
    st_kara,
    accM,
    res1);
}

void
Hacl_Impl_Exponentiation_mod_exp(
  Prims_nat nLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t modBits,
  uint32_t nnLen,
  uint64_t *n1,
  uint64_t *a,
  uint32_t bBits,
  uint64_t *b,
  uint64_t *res
)
{
  uint32_t exp_r = modBits + (uint32_t)2U;
  uint32_t rBits = modBits + (uint32_t)3U;
  uint32_t rLen = (rBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint32_t stLenKara = (uint32_t)2U * rLen + (uint32_t)4U * pow2_i;
  uint32_t stLen_ = (uint32_t)14U * rLen;
  uint32_t stLen = stLenKara + stLen_;
  (void)((uint32_t)3U * rLen);
  uint32_t exp2 = exp_r + exp_r;
  KRML_CHECK_SIZE((uint64_t)0U, stLen);
  uint64_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  uint64_t *r = buf;
  uint64_t *n11 = buf + rLen;
  uint64_t *nInv = buf + (uint32_t)2U * rLen;
  uint64_t *r2 = buf + (uint32_t)3U * rLen;
  uint64_t *a1 = buf + (uint32_t)4U * rLen;
  uint64_t *acc = buf + (uint32_t)5U * rLen;
  uint64_t *res1 = buf + (uint32_t)8U * rLen;
  uint64_t *n1_ = n11;
  uint64_t *a1_ = a1;
  uint64_t *res1_ = res1;
  for (uint32_t i = (uint32_t)0U; i < nnLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = n1[i];
    n1_[i] = src_i;
  }
  for (uint32_t i = (uint32_t)0U; i < nnLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = a[i];
    a1_[i] = src_i;
  }
  acc[0U] = (uint64_t)1U;
  Hacl_Impl_Lib_bn_set_bit((rLen), rLen, r, exp_r);
  Hacl_Impl_Montgomery_bn_pow2_mod_n((rLen), modBits, rLen, n11, exp2, r2);
  Hacl_Impl_Montgomery_shift_euclidean_mod_inv((rLen),
    rLen,
    modBits,
    n11,
    rBits,
    r,
    nInv);
  Hacl_Impl_Exponentiation_mod_exp_mont((rLen),
    (stLen),
    pow2_i,
    iLen,
    bBits,
    b,
    exp_r,
    rLen,
    stLen,
    buf);
  for (uint32_t i = (uint32_t)0U; i < nnLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = res1_[i];
    res[i] = src_i;
  }
}

static const uint32_t Hacl_Impl_MGF_hLen = (uint32_t)32U;

void Hacl_Impl_MGF_hash_sha256(Prims_nat x0, uint8_t *mHash, uint32_t len, uint8_t *m)
{
  Hacl_SHA2_256_hash(mHash, m, len);
}

static void
Hacl_Impl_MGF_mgf_(
  Prims_nat accLen,
  Prims_nat stLen,
  uint32_t count_max,
  uint8_t *mgfseed,
  uint32_t aaccLen,
  uint32_t sstLen,
  uint8_t *st,
  uint32_t counter
)
{
  if (counter < count_max)
  {
    uint8_t *mgfseed_counter = st;
    uint8_t *c = st + Hacl_Impl_MGF_hLen + (uint32_t)4U;
    uint8_t *mHash = st + Hacl_Impl_MGF_hLen + (uint32_t)8U;
    uint8_t *acc = st + Hacl_Impl_MGF_hLen + (uint32_t)8U + Hacl_Impl_MGF_hLen;
    c[0U] = (uint8_t)(counter >> (uint32_t)24U);
    c[1U] = (uint8_t)(counter >> (uint32_t)16U);
    c[2U] = (uint8_t)(counter >> (uint32_t)8U);
    c[3U] = (uint8_t)counter;
    uint8_t *mgfseed_counter_ = mgfseed_counter + Hacl_Impl_MGF_hLen;
    for (uint32_t i = (uint32_t)0U; i < (uint32_t)4U; i = i + (uint32_t)1U)
    {
      uint8_t src_i = c[i];
      mgfseed_counter_[i] = src_i;
    }
    Hacl_Impl_MGF_hash_sha256(Prims_op_Addition((Hacl_Impl_MGF_hLen),
        (krml_checked_int_t)4),
      mHash,
      Hacl_Impl_MGF_hLen + (uint32_t)4U,
      mgfseed_counter);
    uint8_t *acc_ = acc + Hacl_Impl_MGF_hLen * counter;
    for (uint32_t i = (uint32_t)0U; i < Hacl_Impl_MGF_hLen; i = i + (uint32_t)1U)
    {
      uint8_t src_i = mHash[i];
      acc_[i] = src_i;
    }
    Hacl_Impl_MGF_mgf_(accLen,
      stLen,
      count_max,
      mgfseed,
      aaccLen,
      sstLen,
      st,
      counter + (uint32_t)1U);
  }
}

static void
Hacl_Impl_MGF_mgf_sha256(Prims_nat len, uint8_t *mgfseed, uint32_t clen, uint8_t *res)
{
  uint32_t count_max = (clen - (uint32_t)1U) / Hacl_Impl_MGF_hLen + (uint32_t)1U;
  uint32_t accLen = Hacl_Impl_MGF_hLen * count_max;
  uint32_t stLen = Hacl_Impl_MGF_hLen + (uint32_t)8U + Hacl_Impl_MGF_hLen + accLen;
  KRML_CHECK_SIZE((uint8_t)0U, stLen);
  uint8_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  uint8_t *mgfseed_counter = buf;
  uint8_t *acc = buf + Hacl_Impl_MGF_hLen + (uint32_t)8U + Hacl_Impl_MGF_hLen;
  uint8_t *mgfseed_counter_ = mgfseed_counter;
  for (uint32_t i = (uint32_t)0U; i < Hacl_Impl_MGF_hLen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = mgfseed[i];
    mgfseed_counter_[i] = src_i;
  }
  Hacl_Impl_MGF_mgf_((accLen),
    (stLen),
    count_max,
    mgfseed,
    accLen,
    stLen,
    buf,
    (uint32_t)0U);
  uint8_t *acc_ = acc;
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = acc_[i];
    res[i] = src_i;
  }
}

static void Hacl_Impl_RSA_xor_bytes(Prims_nat len, uint32_t clen, uint8_t *b1, uint8_t *b2)
{
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
  {
    uint8_t i1 = b1[i];
    uint8_t i2 = b2[i];
    b1[i] = i1 ^ i2;
  }
}

static void
Hacl_Impl_RSA_pss_encode_(
  Prims_nat sLen,
  Prims_nat msgLen,
  Prims_nat emLen,
  uint32_t ssLen,
  uint8_t *salt,
  uint32_t mmsgLen,
  uint8_t *msg,
  uint32_t eemLen,
  uint8_t *em
)
{
  uint32_t m1_size = (uint32_t)40U + ssLen;
  uint32_t db_size = eemLen - (uint32_t)32U - (uint32_t)1U;
  uint32_t stLen = (uint32_t)32U + m1_size + (uint32_t)32U + db_size + db_size;
  KRML_CHECK_SIZE((uint8_t)0U, stLen);
  uint8_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  (void)(stLen);
  uint8_t *mHash = buf;
  Hacl_Impl_MGF_hash_sha256(msgLen, mHash, mmsgLen, msg);
  uint8_t *m1 = buf + (uint32_t)32U;
  uint8_t *m1_ = m1 + (uint32_t)8U;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
  {
    uint8_t src_i = mHash[i];
    m1_[i] = src_i;
  }
  uint8_t *m1_1 = m1 + (uint32_t)40U;
  for (uint32_t i = (uint32_t)0U; i < ssLen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = salt[i];
    m1_1[i] = src_i;
  }
  uint8_t *m1Hash0 = buf + (uint32_t)32U + m1_size;
  Hacl_Impl_MGF_hash_sha256((m1_size), m1Hash0, m1_size, m1);
  uint8_t *db = buf + (uint32_t)32U + m1_size + (uint32_t)32U;
  uint32_t last_before_salt = db_size - ssLen - (uint32_t)1U;
  db[last_before_salt] = (uint8_t)1U;
  uint8_t *db_ = db + last_before_salt + (uint32_t)1U;
  for (uint32_t i = (uint32_t)0U; i < ssLen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = salt[i];
    db_[i] = src_i;
  }
  uint8_t *dbMask = buf + (uint32_t)32U + m1_size + (uint32_t)32U + db_size;
  Hacl_Impl_MGF_mgf_sha256((db_size), m1Hash0, db_size, dbMask);
  Hacl_Impl_RSA_xor_bytes((db_size), db_size, db, dbMask);
  uint8_t *db0 = buf + (uint32_t)32U + m1_size + (uint32_t)32U;
  uint8_t *em_ = em;
  for (uint32_t i = (uint32_t)0U; i < db_size; i = i + (uint32_t)1U)
  {
    uint8_t src_i = db0[i];
    em_[i] = src_i;
  }
  uint8_t *em_1 = em + db_size;
  uint8_t *m1Hash = buf + (uint32_t)32U + m1_size;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
  {
    uint8_t src_i = m1Hash[i];
    em_1[i] = src_i;
  }
  em[eemLen - (uint32_t)1U] = (uint8_t)0xbcU;
}

static void
Hacl_Impl_RSA_pss_encode(
  Prims_nat sLen,
  Prims_nat msgLen,
  Prims_nat emLen,
  uint32_t msBits,
  uint32_t ssLen,
  uint8_t *salt,
  uint32_t mmsgLen,
  uint8_t *msg,
  uint32_t eemLen,
  uint8_t *em
)
{
  if (msBits == (uint32_t)0U)
  {
    uint8_t *em_ = em + (uint32_t)1U;
    Hacl_Impl_RSA_pss_encode_(sLen,
      msgLen,
      Prims_op_Subtraction(emLen, (krml_checked_int_t)1),
      ssLen,
      salt,
      mmsgLen,
      msg,
      eemLen - (uint32_t)1U,
      em_);
  }
  else
  {
    Hacl_Impl_RSA_pss_encode_(sLen, msgLen, emLen, ssLen, salt, mmsgLen, msg, eemLen, em);
    uint32_t shift_ = (uint32_t)8U - msBits;
    uint8_t uu____2574 = em[0U];
    uint8_t uu____2573 = uu____2574 & (uint8_t)0xffU >> shift_;
    em[0U] = uu____2573;
  }
}

static bool
Hacl_Impl_RSA_pss_verify_(
  Prims_nat sLen,
  Prims_nat msgLen,
  Prims_nat emLen,
  uint32_t ssLen,
  uint32_t msBits,
  uint32_t eemLen,
  uint8_t *em,
  uint32_t mmsgLen,
  uint8_t *msg
)
{
  uint32_t pad_size = eemLen - ssLen - (uint32_t)32U - (uint32_t)1U;
  uint32_t db_size = eemLen - (uint32_t)32U - (uint32_t)1U;
  uint32_t m1_size = (uint32_t)40U + ssLen;
  uint32_t stLen = (uint32_t)32U + pad_size + db_size + m1_size + (uint32_t)32U;
  KRML_CHECK_SIZE((uint8_t)0U, stLen);
  uint8_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  (void)(stLen);
  uint8_t *mHash = buf;
  Hacl_Impl_MGF_hash_sha256(msgLen, mHash, mmsgLen, msg);
  uint8_t *pad2 = buf + (uint32_t)32U;
  pad2[pad_size - (uint32_t)1U] = (uint8_t)0x01U;
  uint8_t *maskedDB = em;
  uint8_t *m1Hash = em + db_size;
  uint8_t *dbMask = buf + (uint32_t)32U + pad_size;
  Hacl_Impl_MGF_mgf_sha256((db_size), m1Hash, db_size, dbMask);
  Hacl_Impl_RSA_xor_bytes((db_size), db_size, dbMask, maskedDB);
  if (msBits > (uint32_t)0U)
  {
    uint32_t shift_ = (uint32_t)8U - msBits;
    uint8_t uu____3419 = dbMask[0U];
    uint8_t uu____3418 = uu____3419 & (uint8_t)0xffU >> shift_;
    dbMask[0U] = uu____3418;
  }
  uint8_t *pad = buf + (uint32_t)32U + pad_size;
  uint8_t *salt = dbMask + pad_size;
  uint8_t *m1 = buf + (uint32_t)32U + pad_size + db_size;
  uint8_t *m1Hash_ = buf + (uint32_t)32U + pad_size + db_size + m1_size;
  bool uu____3594 = Hacl_Impl_Lib_eq_b((pad_size), pad_size, pad, pad2);
  bool uu____3593 = !uu____3594;
  bool r;
  if (uu____3593)
    r = false;
  else
  {
    uint8_t *m1_ = m1 + (uint32_t)8U;
    for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
    {
      uint8_t src_i = mHash[i];
      m1_[i] = src_i;
    }
    uint8_t *m1_1 = m1 + (uint32_t)40U;
    for (uint32_t i = (uint32_t)0U; i < ssLen; i = i + (uint32_t)1U)
    {
      uint8_t src_i = salt[i];
      m1_1[i] = src_i;
    }
    Hacl_Impl_MGF_hash_sha256((m1_size), m1Hash_, m1_size, m1);
    r = Hacl_Impl_Lib_eq_b(((uint32_t)32U), (uint32_t)32U, m1Hash, m1Hash_);
  }
  return r;
}

static bool
Hacl_Impl_RSA_pss_verify(
  Prims_nat sLen,
  Prims_nat msgLen,
  Prims_nat emLen,
  uint32_t ssLen,
  uint32_t msBits,
  uint32_t eemLen,
  uint8_t *em,
  uint32_t mmsgLen,
  uint8_t *msg
)
{
  uint8_t uu____4319 = em[0U];
  uint8_t em_0 = uu____4319 & (uint8_t)0xffU << msBits;
  uint8_t em_last = em[eemLen - (uint32_t)1U];
  if (!(em_0 == (uint8_t)0U && em_last == (uint8_t)0xbcU))
    return false;
  else
  {
    uint32_t eemLen1;
    if (msBits == (uint32_t)0U)
      eemLen1 = eemLen - (uint32_t)1U;
    else
      eemLen1 = eemLen;
    uint8_t *em1;
    if (msBits == (uint32_t)0U)
      em1 = em + (uint32_t)1U;
    else
      em1 = em;
    if (eemLen1 < ssLen + (uint32_t)32U + (uint32_t)2U)
      return false;
    else
      return
        Hacl_Impl_RSA_pss_verify_(sLen,
          msgLen,
          (eemLen1),
          ssLen,
          msBits,
          eemLen1,
          em1,
          mmsgLen,
          msg);
  }
}

void
Hacl_RSAPSS_rsa_pss_sign(
  Prims_nat sLen,
  Prims_nat msgLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t modBits,
  uint32_t eBits,
  uint32_t dBits,
  uint32_t pLen,
  uint32_t qLen,
  uint64_t *skey,
  uint64_t rBlind,
  uint32_t ssLen,
  uint8_t *salt,
  uint32_t mmsgLen,
  uint8_t *msg,
  uint8_t *sgnt
)
{
  uint32_t nLen = (modBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint32_t eLen = (eBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint32_t dLen = (dBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  (void)(nLen + eLen + dLen + pLen + qLen);
  uint32_t k = (modBits - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t msBits = (modBits - (uint32_t)1U) % (uint32_t)8U;
  uint32_t n2Len = nLen + nLen;
  uint32_t pqLen = pLen + qLen;
  uint32_t stLen = n2Len + pqLen + pqLen + (uint32_t)1U;
  KRML_CHECK_SIZE((uint8_t)0U, k);
  uint8_t buf[k];
  memset(buf, 0U, k * sizeof buf[0U]);
  Hacl_Impl_RSA_pss_encode(sLen,
    msgLen,
    (k),
    msBits,
    ssLen,
    salt,
    mmsgLen,
    msg,
    k,
    buf);
  KRML_CHECK_SIZE((uint64_t)0U, stLen);
  uint64_t buf1[stLen];
  memset(buf1, 0U, stLen * sizeof buf1[0U]);
  uint64_t *n1 = skey;
  uint64_t *d = skey + nLen + eLen;
  uint64_t *p = skey + nLen + eLen + dLen;
  uint64_t *q = skey + nLen + eLen + dLen + pLen;
  uint64_t *m = buf1;
  uint64_t *s = buf1 + nLen;
  uint64_t *phi_n = buf1 + n2Len;
  uint64_t *p1 = buf1 + n2Len + pqLen;
  uint64_t *q1 = buf1 + n2Len + pqLen + pLen;
  uint32_t dLen_ = pLen + qLen + (uint32_t)1U;
  uint64_t *d_ = buf1 + n2Len + pqLen;
  Hacl_Impl_Convert_text_to_nat((k), k, buf, m);
  Hacl_Impl_Addition_bn_sub_u64((pLen), pLen, p, (uint64_t)1U, p1);
  Hacl_Impl_Addition_bn_sub_u64((qLen), qLen, q, (uint64_t)1U, q1);
  Hacl_Impl_Multiplication_bn_mul((pLen),
    (qLen),
    pLen,
    p1,
    qLen,
    q1,
    phi_n);
  Hacl_Impl_Multiplication_bn_mul_u64((pqLen), pqLen, phi_n, rBlind, d_);
  Hacl_Impl_Addition_bn_add((dLen_), (dLen), dLen_, d_, dLen, d, d_);
  Hacl_Impl_Exponentiation_mod_exp((nLen),
    pow2_i,
    iLen,
    modBits,
    nLen,
    n1,
    m,
    dLen_ * (uint32_t)64U,
    d_,
    s);
  Hacl_Impl_Convert_nat_to_text(((modBits - (uint32_t)1U)
      / (uint32_t)8U
      + (uint32_t)1U),
    k,
    s,
    sgnt);
}

bool
Hacl_RSAPSS_rsa_pss_verify(
  Prims_nat sLen,
  Prims_nat msgLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t modBits,
  uint32_t eBits,
  uint64_t *pkey,
  uint32_t ssLen,
  uint8_t *sgnt,
  uint32_t mmsgLen,
  uint8_t *msg
)
{
  uint32_t nLen = (modBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint32_t eLen = (eBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  (void)(nLen + eLen);
  uint32_t k = (modBits - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t msBits = (modBits - (uint32_t)1U) % (uint32_t)8U;
  uint32_t n2Len = nLen + nLen;
  KRML_CHECK_SIZE((uint64_t)0U, n2Len);
  uint64_t buf[n2Len];
  memset(buf, 0U, n2Len * sizeof buf[0U]);
  uint64_t *s = buf + nLen;
  Hacl_Impl_Convert_text_to_nat(((modBits - (uint32_t)1U)
      / (uint32_t)8U
      + (uint32_t)1U),
    k,
    sgnt,
    s);
  KRML_CHECK_SIZE((uint8_t)0U, k);
  uint8_t buf1[k];
  memset(buf1, 0U, k * sizeof buf1[0U]);
  uint64_t *m = buf;
  uint64_t *s1 = buf + nLen;
  uint64_t *n1 = pkey;
  uint64_t *e = pkey + nLen;
  bool uu____5968 = Hacl_Impl_Comparison_bn_is_less((nLen), nLen, s1, n1);
  bool res;
  if (uu____5968)
  {
    Hacl_Impl_Exponentiation_mod_exp((nLen),
      pow2_i,
      iLen,
      modBits,
      nLen,
      n1,
      s1,
      eBits,
      e,
      m);
    Hacl_Impl_Convert_nat_to_text((k), k, m, buf1);
    res =
      Hacl_Impl_RSA_pss_verify(sLen,
        msgLen,
        (k),
        ssLen,
        msBits,
        k,
        buf1,
        mmsgLen,
        msg);
  }
  else
    res = false;
  return res;
}

