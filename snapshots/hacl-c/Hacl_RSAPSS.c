/* This file was auto-generated by KreMLin! */

#include "Hacl_RSAPSS.h"
#include <immintrin.h>
#include <x86intrin.h>
#include "Hacl_SHA2_256.h"

inline static bool
Hacl_Impl_Lib_bn_is_bit_set(Prims_nat len, uint32_t clen, uint64_t *input, uint32_t ind)
{
  uint32_t i = ind / (uint32_t)64U;
  uint32_t j = ind % (uint32_t)64U;
  uint64_t tmp = input[i];
  uint64_t x0 = tmp >> j & (uint64_t)1U;
  return x0 == (uint64_t)1U;
}

inline static void
Hacl_Impl_Lib_bn_set_bit(Prims_nat len, uint32_t clen, uint64_t *input, uint32_t ind)
{
  uint32_t i = ind / (uint32_t)64U;
  uint32_t j = ind % (uint32_t)64U;
  uint64_t tmp = input[i];
  input[i] = tmp | (uint64_t)1U << j;
}

inline static uint64_t
Hacl_Impl_Lib_bval(Prims_nat bLen, uint32_t cbLen, uint64_t *b, uint32_t i)
{
  if (i < cbLen)
    return b[i];
  else
    return (uint64_t)0U;
}

inline static void Hacl_Impl_Lib_fill(Prims_nat len, uint32_t clen, uint64_t *b, uint64_t z)
{
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
    b[i] = z;
}

inline static bool
Hacl_Impl_Lib_eq_b_(Prims_nat len, uint32_t clen, uint8_t *b1, uint8_t *b2, uint32_t i)
{
  if (i < clen)
  {
    uint8_t uu____988 = b1[i];
    uint8_t uu____1025 = b2[i];
    bool uu____987 = uu____988 == uu____1025;
    if (uu____987)
      return Hacl_Impl_Lib_eq_b_(len, clen, b1, b2, i + (uint32_t)1U);
    else
      return false;
  }
  else
    return true;
}

inline bool Hacl_Impl_Lib_eq_b(Prims_nat len, uint32_t clen, uint8_t *b1, uint8_t *b2)
{
  return Hacl_Impl_Lib_eq_b_(len, clen, b1, b2, (uint32_t)0U);
}

inline static void
Hacl_Impl_Addition_bn_sub_(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint32_t i,
  uint64_t carry,
  uint64_t *res
)
{
  uint8_t carry2 = carry;
  for(int i = 0; i < caLen; i++) {
    carry2 = _subborrow_u64(carry2,Hacl_Impl_Lib_bval(cbLen,cbLen,b,i),a[i],&res[i]);
  }
}

inline static void
Hacl_Impl_Addition_bn_sub(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint64_t *res
)
{
  Hacl_Impl_Addition_bn_sub_(aLen, bLen, caLen, a, cbLen, b, (uint32_t)0U, (uint64_t)0U, res);
}

inline static uint64_t
Hacl_Impl_Addition_bn_add_(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint32_t i,
  uint8_t carry,
  uint64_t *res
)
{
  uint8_t carry2 = carry;
  for(int i = 0; i < caLen; i++) {
    carry2 = _addcarry_u64(carry2,a[i],Hacl_Impl_Lib_bval(cbLen, cbLen,b,i),&res[i]);
  }
  return carry2;
}

inline static void
Hacl_Impl_Addition_bn_add(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint64_t *res
)
{
  (void)Hacl_Impl_Addition_bn_add_(aLen,
    bLen,
    caLen,
    a,
    cbLen,
    b,
    (uint32_t)0U,
    (uint64_t)0U,
    res);
}

inline static void
Hacl_Impl_Addition_bn_add_carry(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint64_t *res
)
{
  uint64_t *res_ = res;
  uint64_t
  carry =
    Hacl_Impl_Addition_bn_add_(aLen,
      bLen,
      caLen,
      a,
      cbLen,
      b,
      (uint32_t)0U,
      (uint64_t)0U,
      res_);
  res[caLen] = carry;
}

inline static void
Hacl_Impl_Addition_bn_sub_u64_(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t carry,
  uint32_t i,
  uint64_t *res
)
{
  if (i < aaLen)
  {
    uint64_t t1 = a[i];
    uint64_t res_i = t1 - carry;
    res[i] = res_i;
    uint64_t carry1;
    if (t1 < carry)
      carry1 = (uint64_t)1U;
    else
      carry1 = (uint64_t)0U;
    Hacl_Impl_Addition_bn_sub_u64_(aLen, aaLen, a, carry1, i + (uint32_t)1U, res);
  }
}

inline static void
Hacl_Impl_Addition_bn_sub_u64(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t b,
  uint64_t *res
)
{
  Hacl_Impl_Addition_bn_sub_u64_(aLen, aaLen, a, b, (uint32_t)0U, res);
}

inline static bool
Hacl_Impl_Comparison_bn_is_less_(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t bbLen,
  uint64_t *b,
  uint32_t i
)
{
  if (i > (uint32_t)0U)
  {
    uint32_t i1 = i - (uint32_t)1U;
    uint64_t t1 = a[i1];
    uint64_t t2 = Hacl_Impl_Lib_bval(bLen, bbLen, b, i1);
    if (!(t1 == t2))
      if (t1 < t2)
        return true;
      else
        return false;
    else
      return Hacl_Impl_Comparison_bn_is_less_(aLen, bLen, aaLen, a, bbLen, b, i1);
  }
  else
    return false;
}

inline static bool
Hacl_Impl_Comparison_bn_is_less(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t bbLen,
  uint64_t *b
)
{
  return Hacl_Impl_Comparison_bn_is_less_(aLen, bLen, aaLen, a, bbLen, b, aaLen);
}

inline static void
Hacl_Impl_Convert_text_to_nat_(
  Prims_nat len,
  uint32_t clen,
  uint8_t *input,
  uint32_t resLen,
  uint64_t *res,
  uint32_t i
)
{
  if (i < resLen)
  {
    uint64_t inputi = load64_be(input + (uint32_t)8U * i);
    uint32_t ind = resLen - i - (uint32_t)1U;
    res[ind] = inputi;
    Hacl_Impl_Convert_text_to_nat_(len, clen, input, resLen, res, i + (uint32_t)1U);
  }
}

inline void
Hacl_Impl_Convert_text_to_nat(Prims_nat len, uint32_t clen, uint8_t *input, uint64_t *res)
{
  uint32_t num_words = (clen - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t tmpLen = (uint32_t)8U * num_words;
  uint32_t m = clen % (uint32_t)8U;
  uint32_t ind;
  if (m == (uint32_t)0U)
    ind = (uint32_t)0U;
  else
    ind = (uint32_t)8U - m;
  KRML_CHECK_SIZE((uint8_t)0U, tmpLen);
  uint8_t buf[tmpLen];
  memset(buf, 0U, tmpLen * sizeof buf[0U]);
  (void)(tmpLen - ind);
  uint8_t *tmp_ = buf + ind;
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = input[i];
    tmp_[i] = src_i;
  }
  Hacl_Impl_Convert_text_to_nat_(FStar_UInt32_v(tmpLen),
    tmpLen,
    buf,
    num_words,
    res,
    (uint32_t)0U);
}

inline static void
Hacl_Impl_Convert_nat_to_text_(
  Prims_nat len,
  uint32_t clen,
  uint64_t *input,
  uint32_t resLen,
  uint8_t *res,
  uint32_t i
)
{
  if (i < clen)
  {
    uint32_t ind = clen - i - (uint32_t)1U;
    uint64_t tmp = input[ind];
    store64_be(res + (uint32_t)8U * i, tmp);
    Hacl_Impl_Convert_nat_to_text_(len, clen, input, resLen, res, i + (uint32_t)1U);
  }
}

inline static void
Hacl_Impl_Convert_nat_to_text(Prims_nat len, uint32_t clen, uint64_t *input, uint8_t *res)
{
  uint32_t num_words = (clen - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t tmpLen = (uint32_t)8U * num_words;
  uint32_t m = clen % (uint32_t)8U;
  uint32_t ind;
  if (m == (uint32_t)0U)
    ind = (uint32_t)0U;
  else
    ind = (uint32_t)8U - m;
  KRML_CHECK_SIZE((uint8_t)0U, tmpLen);
  uint8_t buf[tmpLen];
  memset(buf, 0U, tmpLen * sizeof buf[0U]);
  Hacl_Impl_Convert_nat_to_text_(FStar_UInt32_v((clen - (uint32_t)1U)
      / (uint32_t)8U
      + (uint32_t)1U),
    num_words,
    input,
    tmpLen,
    buf,
    (uint32_t)0U);
  (void)(tmpLen - ind);
  uint8_t *tmp_ = buf + ind;
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = tmp_[i];
    res[i] = src_i;
  }
}

inline static void
Hacl_Impl_Multiplication_bn_mult_by_limb_addj(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t l,
  uint32_t i,
  uint32_t j,
  uint32_t resLen,
  uint64_t carry,
  uint64_t *res
)
{
  uint32_t ij = i + j;
  if (i < aaLen)
  {
    uint64_t res_ij = res[ij];
    uint64_t uu____258 = a[i];
    FStar_UInt128_t u =
      FStar_UInt128_add(FStar_UInt128_add(FStar_UInt128_mul_wide(uu____258,
                  l),
                FStar_UInt128_uint64_to_uint128(carry)),
			FStar_UInt128_uint64_to_uint128(res_ij));
    uint64_t carry_ = FStar_UInt128_uint128_to_uint64(FStar_UInt128_shift_right(u,(uint32_t)64U));
    uint64_t res_ij1 = FStar_UInt128_uint128_to_uint64(u);
    res[ij] = res_ij1;
    Hacl_Impl_Multiplication_bn_mult_by_limb_addj(aLen,
      aaLen,
      a,
      l,
      i + (uint32_t)1U,
      j,
      resLen,
      carry_,
      res);
  }
  else
    res[ij] = carry;
}

inline static void
Hacl_Impl_Multiplication_bn_mult_(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t bbLen,
  uint64_t *b,
  uint32_t j,
  uint32_t resLen,
  uint64_t *res
)
{
  if (j < bbLen)
  {
    uint64_t uu____705 = b[j];
    Hacl_Impl_Multiplication_bn_mult_by_limb_addj(aLen,
      aaLen,
      a,
      uu____705,
      (uint32_t)0U,
      j,
      resLen,
      (uint64_t)0U,
      res);
    Hacl_Impl_Multiplication_bn_mult_(aLen,
      bLen,
      aaLen,
      a,
      bbLen,
      b,
      j + (uint32_t)1U,
      resLen,
      res);
  }
}

inline static void
Hacl_Impl_Multiplication_bn_mul(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t bbLen,
  uint64_t *b,
  uint64_t *res
)
{
  uint32_t resLen = aaLen + bbLen;
  Hacl_Impl_Lib_fill(Prims_op_Addition(aLen, bLen), resLen, res, (uint64_t)0U);
  Hacl_Impl_Multiplication_bn_mult_(aLen, bLen, aaLen, a, bbLen, b, (uint32_t)0U, resLen, res);
}

inline static void
Hacl_Impl_Multiplication_bn_mul_u64(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t b,
  uint64_t *res
)
{
  uint32_t resLen = aaLen + (uint32_t)1U;
  Hacl_Impl_Lib_fill(Prims_op_Addition(aLen, (krml_checked_int_t)1), resLen, res, (uint64_t)0U);
  Hacl_Impl_Multiplication_bn_mult_by_limb_addj(aLen,
    aaLen,
    a,
    b,
    (uint32_t)0U,
    (uint32_t)0U,
    resLen,
    (uint64_t)0U,
    res);
}

inline static Hacl_Impl_Multiplication_sign
Hacl_Impl_Multiplication_abs(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t *b,
  uint64_t *res
)
{
  bool uu____1849 = Hacl_Impl_Comparison_bn_is_less(aLen, aLen, aaLen, a, aaLen, b);
  if (uu____1849)
  {
    Hacl_Impl_Addition_bn_sub(aLen, aLen, aaLen, b, aaLen, a, res);
    return Hacl_Impl_Multiplication_Negative;
  }
  else
  {
    Hacl_Impl_Addition_bn_sub(aLen, aLen, aaLen, a, aaLen, b, res);
    return Hacl_Impl_Multiplication_Positive;
  }
}

inline static void
Hacl_Impl_Multiplication_add_sign(
  Prims_nat a0Len,
  uint32_t aa0Len,
  uint64_t *c0,
  uint64_t *c1,
  uint64_t *c2,
  uint64_t *a0,
  uint64_t *a1,
  uint64_t *a2,
  uint64_t *b0,
  uint64_t *b1,
  uint64_t *b2,
  Hacl_Impl_Multiplication_sign sa2,
  Hacl_Impl_Multiplication_sign sb2,
  uint32_t rresLen,
  uint64_t *res
)
{
  uint32_t c0Len = aa0Len + aa0Len;
  Hacl_Impl_Addition_bn_add_carry(Prims_op_Addition(a0Len, a0Len),
    Prims_op_Addition(a0Len, a0Len),
    c0Len,
    c0,
    c0Len,
    c1,
    res);
  if
  (sa2
  == Hacl_Impl_Multiplication_Positive
  && sb2 == Hacl_Impl_Multiplication_Positive
  || sa2 == Hacl_Impl_Multiplication_Negative && sb2 == Hacl_Impl_Multiplication_Negative)
    Hacl_Impl_Addition_bn_sub(FStar_UInt32_v(rresLen),
      Prims_op_Addition(a0Len, a0Len),
      rresLen,
      res,
      c0Len,
      c2,
      res);
  else
    Hacl_Impl_Addition_bn_add(FStar_UInt32_v(rresLen),
      Prims_op_Addition(a0Len, a0Len),
      rresLen,
      res,
      c0Len,
      c2,
      res);
}

inline static void
Hacl_Impl_Multiplication_karatsuba_(
  Prims_nat aLen,
  uint32_t pow2_i,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t *b,
  uint64_t *tmp,
  uint64_t *res
)
{
  (void)((uint32_t)4U * pow2_i);
  (void)(aaLen + aaLen);
  uint32_t pow2_i0 = pow2_i / (uint32_t)2U;
  if (aaLen < (uint32_t)32U)
    Hacl_Impl_Multiplication_bn_mul(aLen, aLen, aaLen, a, aaLen, b, res);
  else
  {
    uint64_t *a0 = a;
    uint64_t *b0 = b;
    uint64_t *tmp0 = tmp;
    uint64_t *c0 = res;
    Hacl_Impl_Multiplication_karatsuba_(FStar_UInt32_v(pow2_i0),
      pow2_i0,
      pow2_i0,
      a0,
      b0,
      tmp0,
      c0);
    uint64_t *a1 = a + pow2_i0;
    uint64_t *b1 = b + pow2_i0;
    uint64_t *tmp01 = tmp;
    uint64_t *c1 = res + pow2_i;
    Hacl_Impl_Multiplication_karatsuba_(FStar_UInt32_v(pow2_i0),
      pow2_i0,
      pow2_i0,
      a1,
      b1,
      tmp01,
      c1);
    uint64_t *a2 = tmp;
    uint64_t *b2 = tmp + pow2_i0;
    Hacl_Impl_Multiplication_sign
    sa2 = Hacl_Impl_Multiplication_abs(FStar_UInt32_v(pow2_i0), pow2_i0, a0, a1, a2);
    Hacl_Impl_Multiplication_sign
    sb2 = Hacl_Impl_Multiplication_abs(FStar_UInt32_v(pow2_i0), pow2_i0, b0, b1, b2);
    uint64_t *c2 = tmp + pow2_i;
    uint64_t *tmp02 = tmp + (uint32_t)4U * pow2_i0;
    Hacl_Impl_Multiplication_karatsuba_(FStar_UInt32_v(pow2_i0),
      pow2_i0,
      pow2_i0,
      a2,
      b2,
      tmp02,
      c2);
    uint32_t tmp1Len = pow2_i + (uint32_t)1U;
    uint64_t *tmp1 = tmp + (uint32_t)4U * pow2_i0;
    Hacl_Impl_Multiplication_add_sign(FStar_UInt32_v(pow2_i0),
      pow2_i0,
      c0,
      c1,
      c2,
      a0,
      a1,
      a2,
      b0,
      b1,
      b2,
      sa2,
      sb2,
      tmp1Len,
      tmp1);
    uint32_t res1Len = pow2_i0 + pow2_i;
    uint64_t *res1 = res + pow2_i0;
    Hacl_Impl_Addition_bn_add(FStar_UInt32_v(res1Len),
      FStar_UInt32_v(tmp1Len),
      res1Len,
      res1,
      tmp1Len,
      tmp1,
      res1);
  }
}

inline static void
Hacl_Impl_Multiplication_karatsuba(
  Prims_nat aLen,
  uint32_t pow2_i,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t *b,
  uint64_t *st_kara
)
{
  (void)(aaLen + aaLen + (uint32_t)4U * pow2_i);
  uint64_t *res = st_kara;
  uint64_t *st_mult = st_kara + aaLen + aaLen;
  if (!(pow2_i == aaLen))
    Hacl_Impl_Multiplication_bn_mul(aLen, aLen, aaLen, a, aaLen, b, res);
  else
    Hacl_Impl_Multiplication_karatsuba_(aLen, pow2_i, aaLen, a, b, st_mult, res);
}

inline static void
Hacl_Impl_Shift_bn_lshift1_(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t carry,
  uint32_t i,
  uint64_t *res
)
{
  if (i < aaLen)
  {
    uint64_t tmp = a[i];
    res[i] = tmp << (uint32_t)1U | carry;
    uint64_t carry1;
    uint64_t x0 = tmp & (uint64_t)0x8000000000000000U;
    if (x0 == (uint64_t)0x8000000000000000U)
      carry1 = (uint64_t)1U;
    else
      carry1 = (uint64_t)0U;
    Hacl_Impl_Shift_bn_lshift1_(aLen, aaLen, a, carry1, i + (uint32_t)1U, res);
  }
}

inline static void
Hacl_Impl_Shift_bn_lshift1(Prims_nat aLen, uint32_t aaLen, uint64_t *a, uint64_t *res)
{
  Hacl_Impl_Shift_bn_lshift1_(aLen, aaLen, a, (uint64_t)0U, (uint32_t)0U, res);
}

inline static void
Hacl_Impl_Montgomery_bn_pow2_mod_n_(
  Prims_nat aLen,
  Prims_nat rLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t i,
  uint32_t p,
  uint32_t rrLen,
  uint64_t *res
)
{
  if (i < p)
  {
    Hacl_Impl_Shift_bn_lshift1(rLen, rrLen, res, res);
    bool uu____289 = Hacl_Impl_Comparison_bn_is_less(rLen, aLen, rrLen, res, aaLen, a);
    bool uu____288 = !uu____289;
    if (uu____288)
      Hacl_Impl_Addition_bn_sub(rLen, aLen, rrLen, res, aaLen, a, res);
    Hacl_Impl_Montgomery_bn_pow2_mod_n_(aLen, rLen, aaLen, a, i + (uint32_t)1U, p, rrLen, res);
  }
}

inline static void
Hacl_Impl_Montgomery_bn_pow2_mod_n(
  Prims_nat aLen,
  uint32_t aaLen,
  uint32_t aBits,
  uint64_t *a,
  uint32_t p,
  uint64_t *res
)
{
  uint32_t rLen = aaLen + (uint32_t)1U;
  KRML_CHECK_SIZE((uint64_t)0U, rLen);
  uint64_t buf[rLen];
  memset(buf, 0U, rLen * sizeof buf[0U]);
  Hacl_Impl_Lib_bn_set_bit(FStar_UInt32_v(rLen), rLen, buf, aBits);
  Hacl_Impl_Addition_bn_sub(FStar_UInt32_v(rLen), aLen, rLen, buf, aaLen, a, buf);
  Hacl_Impl_Montgomery_bn_pow2_mod_n_(aLen, FStar_UInt32_v(rLen), aaLen, a, aBits, p, rLen, buf);
  uint64_t *tmp_ = buf;
  for (uint32_t i = (uint32_t)0U; i < aaLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = tmp_[i];
    res[i] = src_i;
  }
}

static uint64_t
Hacl_Impl_Montgomery_mod_inv_u64_(
  uint64_t alpha,
  uint64_t beta,
  uint64_t ub,
  uint64_t vb,
  uint32_t i
)
{
  if (i < (uint32_t)64U)
    return
      Hacl_Impl_Montgomery_mod_inv_u64_(alpha,
        beta,
        ((ub ^ beta & (uint64_t)0U - (ub & (uint64_t)1U)) >> (uint32_t)1U)
        + (ub & beta & (uint64_t)0U - (ub & (uint64_t)1U)),
        (vb >> (uint32_t)1U) + (alpha & (uint64_t)0U - (ub & (uint64_t)1U)),
        i + (uint32_t)1U);
  else
    return vb;
}

static uint64_t Hacl_Impl_Montgomery_mod_inv_u64(uint64_t n0)
{
  return
    Hacl_Impl_Montgomery_mod_inv_u64_((uint64_t)1U << (uint32_t)63U,
      n0,
      (uint64_t)1U,
      (uint64_t)0U,
      (uint32_t)0U);
}

inline static uint64_t
Hacl_Impl_Montgomery_bn_mult_by_limb_addj_carry(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t l,
  uint64_t carry,
  uint32_t i,
  uint32_t j,
  uint32_t resLen,
  uint64_t *res
)
{
  uint32_t ij = i + j;
  if (i < aaLen)
  {
    uint64_t res_ij = res[ij];
    uint64_t uu____1228 = a[i];

    FStar_UInt128_t u =
      FStar_UInt128_add(FStar_UInt128_add(FStar_UInt128_mul_wide(uu____1228,
                  l),
                FStar_UInt128_uint64_to_uint128(carry)),
			FStar_UInt128_uint64_to_uint128(res_ij));
    uint64_t carry_ = FStar_UInt128_uint128_to_uint64(FStar_UInt128_shift_right(u,(uint32_t)64U));
    uint64_t res_ij1 = FStar_UInt128_uint128_to_uint64(u);
    res[ij] = res_ij1;
    return
      Hacl_Impl_Montgomery_bn_mult_by_limb_addj_carry(aLen,
        aaLen,
        a,
        l,
        carry_,
        i + (uint32_t)1U,
        j,
        resLen,
        res);
  }
  else
  {
    uint8_t c_ = _addcarry_u64((uint8_t)0U,res[ij],carry,&res[ij]);
    return c_;
  }
}

inline static void
Hacl_Impl_Montgomery_mont_reduction_(
  Prims_nat nLen,
  Prims_nat rLen,
  uint32_t nnLen,
  uint32_t rrLen,
  uint64_t *c,
  uint64_t *n1,
  uint64_t nInv_u64,
  uint32_t i
)
{
  if (i < nnLen)
  {
    uint64_t ci = c[i];
    uint64_t qi = nInv_u64 * ci;
    uint64_t
    carry =
      Hacl_Impl_Montgomery_bn_mult_by_limb_addj_carry(nLen,
        nnLen,
        n1,
        qi,
        (uint64_t)0U,
        (uint32_t)0U,
        i,
        nnLen + rrLen,
        c);
    uint64_t c_i1 = c[nnLen + i + (uint32_t)1U];
    c[nnLen + i + (uint32_t)1U] = c_i1 + carry;
    Hacl_Impl_Montgomery_mont_reduction_(nLen,
      rLen,
      nnLen,
      rrLen,
      c,
      n1,
      nInv_u64,
      i + (uint32_t)1U);
  }
  else
  {
    uint64_t ci = c[i];
    uint64_t qi = nInv_u64 * ci;
    (void)Hacl_Impl_Montgomery_bn_mult_by_limb_addj_carry(nLen,
      nnLen,
      n1,
      qi,
      (uint64_t)0U,
      (uint32_t)0U,
      i,
      nnLen + rrLen,
      c);
  }
}

inline static void
Hacl_Impl_Montgomery_mont_reduction(
  Prims_nat nLen,
  Prims_nat rLen,
  uint32_t nnLen,
  uint32_t rrLen,
  uint64_t *n1,
  uint64_t nInv_u64,
  uint64_t *c,
  uint64_t *tmp,
  uint64_t *res
)
{
  uint32_t nLen2 = nnLen + nnLen;
  uint64_t *tmp_ = tmp;
  for (uint32_t i = (uint32_t)0U; i < nLen2; i = i + (uint32_t)1U)
  {
    uint64_t src_i = c[i];
    tmp_[i] = src_i;
  }
  tmp[nLen2] = (uint64_t)0U;
  Hacl_Impl_Montgomery_mont_reduction_(nLen,
    rLen,
    nnLen,
    rrLen,
    tmp,
    n1,
    nInv_u64,
    (uint32_t)0U);
  uint64_t *tmp_1 = tmp + rrLen;
  for (uint32_t i = (uint32_t)0U; i < nnLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = tmp_1[i];
    res[i] = src_i;
  }
}

inline static void
Hacl_Impl_Montgomery_to_mont(
  Prims_nat nLen,
  Prims_nat rLen,
  uint32_t nnLen,
  uint32_t rrLen,
  uint32_t pow2_i,
  uint64_t *n1,
  uint64_t nInv_u64,
  uint64_t *r2,
  uint64_t *a,
  uint64_t *st_kara,
  uint64_t *aM
)
{
  uint32_t cLen = nnLen + nnLen;
  (void)(cLen + (uint32_t)4U * pow2_i);
  uint64_t *c = st_kara;
  Hacl_Impl_Multiplication_karatsuba(nLen, pow2_i, nnLen, a, r2, st_kara);
  uint64_t *tmp = st_kara + cLen;
  Hacl_Impl_Montgomery_mont_reduction(nLen, rLen, nnLen, rrLen, n1, nInv_u64, c, tmp, aM);
}

inline static void
Hacl_Impl_Montgomery_from_mont(
  Prims_nat nLen,
  Prims_nat rLen,
  uint32_t nnLen,
  uint32_t rrLen,
  uint32_t pow2_i,
  uint64_t *n1,
  uint64_t nInv_u64,
  uint64_t *aM,
  uint64_t *tmp,
  uint64_t *a
)
{
  uint32_t tmpLen = nnLen + rrLen;
  Hacl_Impl_Lib_fill(Prims_op_Addition(nLen, rLen), tmpLen, tmp, (uint64_t)0U);
  uint64_t *tmp_ = tmp;
  for (uint32_t i = (uint32_t)0U; i < nnLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = aM[i];
    tmp_[i] = src_i;
  }
  Hacl_Impl_Montgomery_mont_reduction_(nLen,
    rLen,
    nnLen,
    rrLen,
    tmp,
    n1,
    nInv_u64,
    (uint32_t)0U);
  uint64_t *tmp_1 = tmp + rrLen;
  for (uint32_t i = (uint32_t)0U; i < nnLen; i = i + (uint32_t)1U)
  {
    uint64_t src_i = tmp_1[i];
    a[i] = src_i;
  }
}

inline static void
Hacl_Impl_Exponentiation_mul_mod_mont(
  Prims_nat nLen,
  Prims_nat rLen,
  uint32_t nnLen,
  uint32_t rrLen,
  uint32_t pow2_i,
  uint64_t *n1,
  uint64_t nInv_u64,
  uint64_t *st_kara,
  uint64_t *aM,
  uint64_t *bM,
  uint64_t *resM
)
{
  uint32_t cLen = nnLen + nnLen;
  (void)(cLen + (uint32_t)4U * pow2_i);
  uint64_t *c = st_kara;
  uint64_t *tmp = st_kara + cLen;
  Hacl_Impl_Multiplication_karatsuba(nLen, pow2_i, nnLen, aM, bM, st_kara);
  Hacl_Impl_Montgomery_mont_reduction(nLen, rLen, nnLen, rrLen, n1, nInv_u64, c, tmp, resM);
}

inline static void
Hacl_Impl_Exponentiation_mod_exp_(
  Prims_nat nLen,
  Prims_nat rLen,
  uint32_t nnLen,
  uint32_t rrLen,
  uint32_t pow2_i,
  uint64_t *n1,
  uint64_t nInv_u64,
  uint64_t *st_kara,
  uint64_t *st_exp,
  uint32_t bBits,
  uint32_t bLen,
  uint64_t *b,
  uint32_t i
)
{
  uint64_t *aM = st_exp;
  uint64_t *accM = st_exp + nnLen;
  if (i < bBits)
  {
    bool uu____1430 = Hacl_Impl_Lib_bn_is_bit_set(FStar_UInt32_v(bLen), bLen, b, i);
    if (uu____1430)
      Hacl_Impl_Exponentiation_mul_mod_mont(nLen,
        rLen,
        nnLen,
        rrLen,
        pow2_i,
        n1,
        nInv_u64,
        st_kara,
        aM,
        accM,
        accM);
    Hacl_Impl_Exponentiation_mul_mod_mont(nLen,
      rLen,
      nnLen,
      rrLen,
      pow2_i,
      n1,
      nInv_u64,
      st_kara,
      aM,
      aM,
      aM);
    Hacl_Impl_Exponentiation_mod_exp_(nLen,
      rLen,
      nnLen,
      rrLen,
      pow2_i,
      n1,
      nInv_u64,
      st_kara,
      st_exp,
      bBits,
      bLen,
      b,
      i + (uint32_t)1U);
  }
}

inline static void
Hacl_Impl_Exponentiation_mod_exp(
  Prims_nat nLen,
  uint32_t pow2_i,
  uint32_t modBits,
  uint32_t nnLen,
  uint64_t *n1,
  uint64_t *a,
  uint32_t bBits,
  uint64_t *b,
  uint64_t *res
)
{
  uint32_t rrLen = nnLen + (uint32_t)1U;
  uint32_t exp_r = (uint32_t)64U * rrLen;
  uint32_t exp2 = exp_r + exp_r;
  uint32_t bLen = (bBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint32_t karaLen = nnLen + nnLen + (uint32_t)4U * pow2_i;
  uint32_t stLen = (uint32_t)4U * nnLen + karaLen;
  KRML_CHECK_SIZE((uint64_t)0U, stLen);
  uint64_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  uint64_t *r2 = buf;
  uint64_t *acc = buf + nnLen;
  uint64_t *aM = buf + (uint32_t)2U * nnLen;
  uint64_t *accM = buf + (uint32_t)3U * nnLen;
  uint64_t *st_exp = buf + (uint32_t)2U * nnLen;
  uint64_t *st_kara = buf + (uint32_t)4U * nnLen;
  uint64_t *tmp = buf + (uint32_t)4U * nnLen;
  acc[0U] = (uint64_t)1U;
  Hacl_Impl_Montgomery_bn_pow2_mod_n(nLen, nnLen, modBits, n1, exp2, r2);
  uint64_t n0 = n1[0U];
  uint64_t nInv_u64 = Hacl_Impl_Montgomery_mod_inv_u64(n0);
  Hacl_Impl_Montgomery_to_mont(nLen,
    FStar_UInt32_v(rrLen),
    nnLen,
    rrLen,
    pow2_i,
    n1,
    nInv_u64,
    r2,
    a,
    st_kara,
    aM);
  Hacl_Impl_Montgomery_to_mont(nLen,
    FStar_UInt32_v(rrLen),
    nnLen,
    rrLen,
    pow2_i,
    n1,
    nInv_u64,
    r2,
    acc,
    st_kara,
    accM);
  Hacl_Impl_Exponentiation_mod_exp_(nLen,
    FStar_UInt32_v(rrLen),
    nnLen,
    rrLen,
    pow2_i,
    n1,
    nInv_u64,
    st_kara,
    st_exp,
    bBits,
    bLen,
    b,
    (uint32_t)0U);
  Hacl_Impl_Montgomery_from_mont(nLen,
    FStar_UInt32_v(rrLen),
    nnLen,
    rrLen,
    pow2_i,
    n1,
    nInv_u64,
    accM,
    tmp,
    res);
}

void Hacl_Impl_MGF_hash_sha256(Prims_nat x0, uint8_t *mHash, uint32_t len, uint8_t *m)
{
  Hacl_SHA2_256_hash(mHash, m, len);
}

inline static void
Hacl_Impl_MGF_mgf_sha256_(
  uint32_t count_max,
  uint32_t accLen,
  uint32_t stLen,
  uint8_t *st,
  uint32_t counter
)
{
  if (counter < count_max)
  {
    uint32_t mgfseed_counter_len = (uint32_t)36U;
    uint8_t *mgfseed_counter = st;
    uint8_t *mHash = st + mgfseed_counter_len;
    uint8_t *acc = st + mgfseed_counter_len + (uint32_t)32U;
    uint8_t *c = mgfseed_counter + (uint32_t)32U;
    c[0U] = (uint8_t)(counter >> (uint32_t)24U);
    c[1U] = (uint8_t)(counter >> (uint32_t)16U);
    c[2U] = (uint8_t)(counter >> (uint32_t)8U);
    c[3U] = (uint8_t)counter;
    Hacl_Impl_MGF_hash_sha256(FStar_UInt32_v(mgfseed_counter_len),
      mHash,
      mgfseed_counter_len,
      mgfseed_counter);
    uint8_t *acc_ = acc + (uint32_t)32U * counter;
    for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
    {
      uint8_t src_i = mHash[i];
      acc_[i] = src_i;
    }
    Hacl_Impl_MGF_mgf_sha256_(count_max, accLen, stLen, st, counter + (uint32_t)1U);
  }
}

inline static void
Hacl_Impl_MGF_mgf_sha256(Prims_nat len, uint8_t *mgfseed, uint32_t clen, uint8_t *res)
{
  uint32_t count_max = (clen - (uint32_t)1U) / (uint32_t)32U + (uint32_t)1U;
  uint32_t accLen = (uint32_t)32U * count_max;
  uint32_t mgfseed_counter_len = (uint32_t)36U;
  uint32_t stLen = mgfseed_counter_len + (uint32_t)32U + accLen;
  KRML_CHECK_SIZE((uint8_t)0U, stLen);
  uint8_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  uint8_t *mgfseed_counter = buf;
  uint8_t *mgfseed_counter_ = mgfseed_counter;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
  {
    uint8_t src_i = mgfseed[i];
    mgfseed_counter_[i] = src_i;
  }
  uint8_t *acc = buf + mgfseed_counter_len + (uint32_t)32U;
  Hacl_Impl_MGF_mgf_sha256_(count_max, accLen, stLen, buf, (uint32_t)0U);
  uint8_t *acc_ = acc;
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = acc_[i];
    res[i] = src_i;
  }
}

inline static void
Hacl_Impl_RSA_xor_bytes(Prims_nat len, uint32_t clen, uint8_t *b1, uint8_t *b2)
{
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
  {
    uint8_t i1 = b1[i];
    uint8_t i2 = b2[i];
    b1[i] = i1 ^ i2;
  }
}

inline static void
Hacl_Impl_RSA_pss_encode_(
  Prims_nat sLen,
  Prims_nat msgLen,
  Prims_nat emLen,
  uint32_t ssLen,
  uint8_t *salt,
  uint32_t mmsgLen,
  uint8_t *msg,
  uint32_t eemLen,
  uint8_t *em
)
{
  uint32_t m1_size = (uint32_t)40U + ssLen;
  uint32_t db_size = eemLen - (uint32_t)32U - (uint32_t)1U;
  uint32_t stLen = (uint32_t)32U + m1_size + (uint32_t)32U + db_size + db_size;
  KRML_CHECK_SIZE((uint8_t)0U, stLen);
  uint8_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  uint8_t *mHash = buf;
  uint8_t *m1 = buf + (uint32_t)32U;
  uint8_t *m1Hash = buf + (uint32_t)32U + m1_size;
  uint8_t *db = buf + (uint32_t)32U + m1_size + (uint32_t)32U;
  uint8_t *dbMask = buf + (uint32_t)32U + m1_size + (uint32_t)32U + db_size;
  Hacl_Impl_MGF_hash_sha256(msgLen, mHash, mmsgLen, msg);
  uint8_t *m1_ = m1 + (uint32_t)8U;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
  {
    uint8_t src_i = mHash[i];
    m1_[i] = src_i;
  }
  uint8_t *m1_1 = m1 + (uint32_t)40U;
  for (uint32_t i = (uint32_t)0U; i < ssLen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = salt[i];
    m1_1[i] = src_i;
  }
  Hacl_Impl_MGF_hash_sha256(FStar_UInt32_v(m1_size), m1Hash, m1_size, m1);
  uint32_t last_before_salt = db_size - ssLen - (uint32_t)1U;
  db[last_before_salt] = (uint8_t)1U;
  uint8_t *db_ = db + last_before_salt + (uint32_t)1U;
  for (uint32_t i = (uint32_t)0U; i < ssLen; i = i + (uint32_t)1U)
  {
    uint8_t src_i = salt[i];
    db_[i] = src_i;
  }
  Hacl_Impl_MGF_mgf_sha256(FStar_UInt32_v(db_size), m1Hash, db_size, dbMask);
  Hacl_Impl_RSA_xor_bytes(FStar_UInt32_v(db_size), db_size, db, dbMask);
  uint8_t *em_ = em;
  for (uint32_t i = (uint32_t)0U; i < db_size; i = i + (uint32_t)1U)
  {
    uint8_t src_i = db[i];
    em_[i] = src_i;
  }
  uint8_t *em_1 = em + db_size;
  for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
  {
    uint8_t src_i = m1Hash[i];
    em_1[i] = src_i;
  }
  em[eemLen - (uint32_t)1U] = (uint8_t)0xbcU;
}

inline static void
Hacl_Impl_RSA_pss_encode(
  Prims_nat sLen,
  Prims_nat msgLen,
  Prims_nat emLen,
  uint32_t msBits,
  uint32_t ssLen,
  uint8_t *salt,
  uint32_t mmsgLen,
  uint8_t *msg,
  uint32_t eemLen,
  uint8_t *em
)
{
  if (msBits == (uint32_t)0U)
  {
    uint8_t *em_ = em + (uint32_t)1U;
    Hacl_Impl_RSA_pss_encode_(sLen,
      msgLen,
      Prims_op_Subtraction(emLen, (krml_checked_int_t)1),
      ssLen,
      salt,
      mmsgLen,
      msg,
      eemLen - (uint32_t)1U,
      em_);
  }
  else
  {
    Hacl_Impl_RSA_pss_encode_(sLen, msgLen, emLen, ssLen, salt, mmsgLen, msg, eemLen, em);
    uint32_t shift_ = (uint32_t)8U - msBits;
    uint8_t uu____1956 = em[0U];
    uint8_t uu____1955 = uu____1956 & (uint8_t)0xffU >> shift_;
    em[0U] = uu____1955;
  }
}

inline static bool
Hacl_Impl_RSA_pss_verify_(
  Prims_nat sLen,
  Prims_nat msgLen,
  Prims_nat emLen,
  uint32_t ssLen,
  uint32_t msBits,
  uint32_t eemLen,
  uint8_t *em,
  uint32_t mmsgLen,
  uint8_t *msg
)
{
  uint32_t pad_size = eemLen - ssLen - (uint32_t)32U - (uint32_t)1U;
  uint32_t db_size = eemLen - (uint32_t)32U - (uint32_t)1U;
  uint32_t m1_size = (uint32_t)40U + ssLen;
  uint32_t stLen = (uint32_t)32U + pad_size + db_size + m1_size + (uint32_t)32U;
  KRML_CHECK_SIZE((uint8_t)0U, stLen);
  uint8_t buf[stLen];
  memset(buf, 0U, stLen * sizeof buf[0U]);
  uint8_t *mHash = buf;
  uint8_t *pad2 = buf + (uint32_t)32U;
  uint8_t *dbMask = buf + (uint32_t)32U + pad_size;
  uint8_t *m1 = buf + (uint32_t)32U + pad_size + db_size;
  uint8_t *m1Hash_ = buf + (uint32_t)32U + pad_size + db_size + m1_size;
  Hacl_Impl_MGF_hash_sha256(msgLen, mHash, mmsgLen, msg);
  pad2[pad_size - (uint32_t)1U] = (uint8_t)0x01U;
  uint8_t *maskedDB = em;
  uint8_t *m1Hash = em + db_size;
  Hacl_Impl_MGF_mgf_sha256(FStar_UInt32_v(db_size), m1Hash, db_size, dbMask);
  Hacl_Impl_RSA_xor_bytes(FStar_UInt32_v(db_size), db_size, dbMask, maskedDB);
  if (msBits > (uint32_t)0U)
  {
    uint32_t shift_ = (uint32_t)8U - msBits;
    uint8_t uu____2595 = dbMask[0U];
    uint8_t uu____2594 = uu____2595 & (uint8_t)0xffU >> shift_;
    dbMask[0U] = uu____2594;
  }
  uint8_t *pad = dbMask;
  uint8_t *salt = dbMask + pad_size;
  bool uu____2626 = Hacl_Impl_Lib_eq_b(FStar_UInt32_v(pad_size), pad_size, pad, pad2);
  bool uu____2625 = !uu____2626;
  bool res;
  if (uu____2625)
    res = false;
  else
  {
    uint8_t *m1_ = m1 + (uint32_t)8U;
    for (uint32_t i = (uint32_t)0U; i < (uint32_t)32U; i = i + (uint32_t)1U)
    {
      uint8_t src_i = mHash[i];
      m1_[i] = src_i;
    }
    uint8_t *m1_1 = m1 + (uint32_t)40U;
    for (uint32_t i = (uint32_t)0U; i < ssLen; i = i + (uint32_t)1U)
    {
      uint8_t src_i = salt[i];
      m1_1[i] = src_i;
    }
    Hacl_Impl_MGF_hash_sha256(FStar_UInt32_v(m1_size), m1Hash_, m1_size, m1);
    res = Hacl_Impl_Lib_eq_b(FStar_UInt32_v((uint32_t)32U), (uint32_t)32U, m1Hash, m1Hash_);
  }
  bool r = res;
  return r;
}

inline static bool
Hacl_Impl_RSA_pss_verify(
  Prims_nat sLen,
  Prims_nat msgLen,
  Prims_nat emLen,
  uint32_t ssLen,
  uint32_t msBits,
  uint32_t eemLen,
  uint8_t *em,
  uint32_t mmsgLen,
  uint8_t *msg
)
{
  uint8_t uu____2985 = em[0U];
  uint8_t em_0 = uu____2985 & (uint8_t)0xffU << msBits;
  uint8_t em_last = em[eemLen - (uint32_t)1U];
  if (!(em_0 == (uint8_t)0U && em_last == (uint8_t)0xbcU))
    return false;
  else
  {
    uint32_t eemLen1;
    if (msBits == (uint32_t)0U)
      eemLen1 = eemLen - (uint32_t)1U;
    else
      eemLen1 = eemLen;
    uint8_t *em1;
    if (msBits == (uint32_t)0U)
      em1 = em + (uint32_t)1U;
    else
      em1 = em;
    if (eemLen1 < ssLen + (uint32_t)32U + (uint32_t)2U)
      return false;
    else
      return
        Hacl_Impl_RSA_pss_verify_(sLen,
          msgLen,
          FStar_UInt32_v(eemLen1),
          ssLen,
          msBits,
          eemLen1,
          em1,
          mmsgLen,
          msg);
  }
}

void
Hacl_RSAPSS_rsa_pss_sign(
  Prims_nat sLen,
  Prims_nat msgLen,
  Prims_nat nLen,
  uint32_t pow2_i,
  uint32_t modBits,
  uint32_t eBits,
  uint32_t dBits,
  uint32_t pLen,
  uint32_t qLen,
  uint64_t *skey,
  uint64_t rBlind,
  uint32_t ssLen,
  uint8_t *salt,
  uint32_t mmsgLen,
  uint8_t *msg,
  uint8_t *sgnt
)
{
  uint32_t k = (modBits - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t msBits = (modBits - (uint32_t)1U) % (uint32_t)8U;
  uint32_t nLen1 = (k - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t eLen = (eBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  uint32_t dLen = (dBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  (void)(nLen1 + eLen + dLen + pLen + qLen);
  uint64_t *n1 = skey;
  uint64_t *d = skey + nLen1 + eLen;
  uint64_t *p = skey + nLen1 + eLen + dLen;
  uint64_t *q = skey + nLen1 + eLen + dLen + pLen;
  uint32_t n2Len = nLen1 + nLen1;
  uint32_t pqLen = pLen + qLen;
  uint32_t stLen = n2Len + pqLen + pqLen + (uint32_t)1U;
  KRML_CHECK_SIZE((uint8_t)0U, k);
  uint8_t buf[k];
  memset(buf, 0U, k * sizeof buf[0U]);
  Hacl_Impl_RSA_pss_encode(sLen,
    msgLen,
    FStar_UInt32_v(k),
    msBits,
    ssLen,
    salt,
    mmsgLen,
    msg,
    k,
    buf);
  KRML_CHECK_SIZE((uint64_t)0U, stLen);
  uint64_t buf1[stLen];
  memset(buf1, 0U, stLen * sizeof buf1[0U]);
  uint64_t *m = buf1;
  uint64_t *s = buf1 + nLen1;
  uint64_t *phi_n = buf1 + n2Len;
  uint64_t *p1 = buf1 + n2Len + pqLen;
  uint64_t *q1 = buf1 + n2Len + pqLen + pLen;
  uint32_t dLen_ = pLen + qLen + (uint32_t)1U;
  uint64_t *d_ = buf1 + n2Len + pqLen;
  Hacl_Impl_Convert_text_to_nat(FStar_UInt32_v(k), k, buf, m);
  Hacl_Impl_Addition_bn_sub_u64(FStar_UInt32_v(pLen), pLen, p, (uint64_t)1U, p1);
  Hacl_Impl_Addition_bn_sub_u64(FStar_UInt32_v(qLen), qLen, q, (uint64_t)1U, q1);
  Hacl_Impl_Multiplication_bn_mul(FStar_UInt32_v(pLen),
    FStar_UInt32_v(qLen),
    pLen,
    p1,
    qLen,
    q1,
    phi_n);
  Hacl_Impl_Multiplication_bn_mul_u64(FStar_UInt32_v(pqLen), pqLen, phi_n, rBlind, d_);
  Hacl_Impl_Addition_bn_add(FStar_UInt32_v(dLen_), FStar_UInt32_v(dLen), dLen_, d_, dLen, d, d_);
  Hacl_Impl_Exponentiation_mod_exp(FStar_UInt32_v(nLen1),
    pow2_i,
    modBits,
    nLen1,
    n1,
    m,
    dLen_ * (uint32_t)64U,
    d_,
    s);
  Hacl_Impl_Convert_nat_to_text(FStar_UInt32_v((modBits - (uint32_t)1U)
      / (uint32_t)8U
      + (uint32_t)1U),
    k,
    s,
    sgnt);
}

bool
Hacl_RSAPSS_rsa_pss_verify(
  Prims_nat sLen,
  Prims_nat msgLen,
  Prims_nat nLen,
  uint32_t pow2_i,
  uint32_t modBits,
  uint32_t eBits,
  uint64_t *pkey,
  uint32_t ssLen,
  uint8_t *sgnt,
  uint32_t mmsgLen,
  uint8_t *msg
)
{
  uint32_t k = (modBits - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t msBits = (modBits - (uint32_t)1U) % (uint32_t)8U;
  uint32_t nLen1 = (k - (uint32_t)1U) / (uint32_t)8U + (uint32_t)1U;
  uint32_t eLen = (eBits - (uint32_t)1U) / (uint32_t)64U + (uint32_t)1U;
  (void)(nLen1 + eLen);
  uint64_t *n1 = pkey;
  uint64_t *e = pkey + nLen1;
  uint32_t n2Len = nLen1 + nLen1;
  KRML_CHECK_SIZE((uint64_t)0U, n2Len);
  uint64_t buf[n2Len];
  memset(buf, 0U, n2Len * sizeof buf[0U]);
  KRML_CHECK_SIZE((uint8_t)0U, k);
  uint8_t buf1[k];
  memset(buf1, 0U, k * sizeof buf1[0U]);
  uint64_t *m = buf;
  uint64_t *s = buf + nLen1;
  Hacl_Impl_Convert_text_to_nat(FStar_UInt32_v((modBits - (uint32_t)1U)
      / (uint32_t)8U
      + (uint32_t)1U),
    k,
    sgnt,
    s);
  bool
  uu____4649 =
    Hacl_Impl_Comparison_bn_is_less(FStar_UInt32_v(nLen1),
      FStar_UInt32_v(nLen1),
      nLen1,
      s,
      nLen1,
      n1);
  bool res;
  if (uu____4649)
  {
    Hacl_Impl_Exponentiation_mod_exp(FStar_UInt32_v(nLen1),
      pow2_i,
      modBits,
      nLen1,
      n1,
      s,
      eBits,
      e,
      m);
    Hacl_Impl_Convert_nat_to_text(FStar_UInt32_v(k), k, m, buf1);
    res =
      Hacl_Impl_RSA_pss_verify(sLen,
        msgLen,
        FStar_UInt32_v(k),
        ssLen,
        msBits,
        k,
        buf1,
        mmsgLen,
        msg);
  }
  else
    res = false;
  return res;
}

