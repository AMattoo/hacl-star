## 0. A Simple Example in F\*

The purpose of this example is to show F* code for a simple bignum operation.
Here we assume that we are computing on arrays of size 5 (useful for instance for curve25519_donna_c64).

The type definition is `type felem = b:buffer u64{length b = 5}`.
It is broken down as follows:
- `type felem` defines a type alias for the right hand side of the `=` sign.
- `u64` is a type (alias) for unsigned 64bits integers.
- `buffer u64` is thus an array of `u64`
- `{length b = 5}` is a refinement on the previous buffer type. It specifies that any inhabitant `b` of that type satisfies that condition. Here this is the type of arrays of unsigned 64bits integers of size 5.

In F* top-level declarations can have both a `val` declaration, and a `let` declaration. Intuitively the `val` declares the type of the object, while the `let` gives its definition. E.g:
```F#
val plus: a:int{a > 3} -> b:int{b >= 2} -> Tot (c:int{c >= 6})
let plus a b = a + b
```
NB: F* also supports an "all-in-let" syntax, where the `let` contains both all type declarations and the top-level definition.
can also be condensed into `let plus (a:int{a > 3}) (b:int{b >= 2}) : Tot (c:int{c >= 6}) = a + b`.

In the previous example, note the `Tot` annotation before the resulting type `(c:int{c >= 6})`.
It is an effect, a key feature of the F* language. F* has a user-customizable lattice of effects for different monads.
Here `Tot` means that the function is both *pure* (no side effects), and terminating.

## FSum

See the `fsum` function in [FSum].
The function's behavior is straightforward: it computes the sum of the contents of `a` and `b` limb to limb and stores the result inplace in `a`.

The `fsum` function is declared to have an effect called `Stack`. This means that the function is:
- effectful,
- only performs stack allocations (no heap allocation).
The `requires` and `ensures` clauses are pre- and post-conditions; they relate the function's output value to its input
and the state of the heap (program memory) before and after execution.

[FSum]: https://github.com/mitls/hacl-star/blob/master/doc/tutorial/0-coding-field-arithmetic-in-fstar/Hacl.Bignum.Fsum.fst

The code of this example can be typechecked using `make verify` in this directory.
The code can be extracted using `make extract-c` in this directory.

The result C code is split into a header file:
```c
/* This file auto-generated by KreMLin! */
#ifndef __Hacl_Bignum_Fsum_H
#define __Hacl_Bignum_Fsum_H


#include "kremlib.h"

typedef uint64_t Hacl_Bignum_Fsum_u64;

typedef uint64_t *Hacl_Bignum_Fsum_felem;

void Hacl_Bignum_Fsum_fsum(uint64_t *a, uint64_t *b);
#endif
```
and a .c file:
```c
#include "Hacl_Bignum_Fsum.h"

void Hacl_Bignum_Fsum_fsum(uint64_t *a, uint64_t *b)
{
  uint64_t a0 = a[(uint32_t )0];
  uint64_t a1 = a[(uint32_t )1];
  uint64_t a2 = a[(uint32_t )2];
  uint64_t a3 = a[(uint32_t )3];
  uint64_t a4 = a[(uint32_t )4];
  uint64_t b0 = b[(uint32_t )0];
  uint64_t b1 = b[(uint32_t )1];
  uint64_t b2 = b[(uint32_t )2];
  uint64_t b3 = b[(uint32_t )3];
  uint64_t b4 = b[(uint32_t )4];
  a[(uint32_t )0] = a0 + b0;
  a[(uint32_t )1] = a1 + b1;
  a[(uint32_t )2] = a2 + b2;
  a[(uint32_t )3] = a3 + b3;
  a[(uint32_t )4] = a4 + b4;
}

```
