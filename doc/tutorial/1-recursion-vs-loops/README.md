## 1. Tail recursive functions for generic code

This example presents a function which input/output behavior is identical to that of 
[example 0](https://github.com/mitls/hacl-star/tree/master/doc/tutorial/0-coding-field-arithmetic-in-fstar) : 
it computes a limb to limb addition of the contents of `a` and `b` and stores the result inplace in `a`.

The difference however is that the function is not hard-coded to work only for 5 limbs. 
It is recursively defined to work on limb arrays of any length.
Crucially, for performance, the code is [tail recursive](https://en.wikipedia.org/wiki/Tail_call)
and so the recursive call does not requre a new stack frame. 

The resulting C code, (which can be obtained running `make extract-c` in this directory) is the following.
Hacl_Bignum_Fsum.h:
```c
/* This file auto-generated by KreMLin! */
#ifndef __Hacl_Bignum_Fsum_H
#define __Hacl_Bignum_Fsum_H



#include "kremlib.h"

typedef uint32_t Hacl_Bignum_Fsum_u32;

typedef uint64_t Hacl_Bignum_Fsum_u64;

typedef uint64_t *Hacl_Bignum_Fsum_felem;

void Hacl_Bignum_Fsum_fsum(uint64_t *a, uint64_t *b, uint32_t i);
#endif
```
and Hacl_Bignum.Fsum.c:
```c
#include "Hacl_Bignum_Fsum.h"

void Hacl_Bignum_Fsum_fsum(uint64_t *a, uint64_t *b, uint32_t i)
{
  if (i == (uint32_t )0)
    return;
  else
  {
    uint32_t i0 = i - (uint32_t )1;
    uint64_t ai = a[i0];
    uint64_t bi = b[i0];
    a[i0] = ai + bi;
    Hacl_Bignum_Fsum_fsum(a, b, i0);
    return;
  }
}
```

## Recursion vs. loops

Instead of using recursion, we could have used a for-loop, but in F*,
recursion has much better verification support.  Recursion is the most
natural way of writing proofs in many situations. Invariants are often
simpler to write in a recursive context than with pure inlined code.

The main drawback to recursion is performance, since each recursive 
call is a function call, and it may require a additional stack frame.
However, we primarily use tail recursion, which can be optimized by
C compilers to code that looks very much like a while-loop.

In our experience, GCC is quite good a optimizing recursive tail-calls (with
the argument `-O3`, and will unroll tail recursive functions a certain
number of times. In our code, we rely on no more than 5 or 10 unrollings
which seems to be within the abilities of GCC. Consequently, in most of
our code, we incur no performance cost for using generic recursive coe.

We note, however, that CLANG seems to be much worse at optimizing our tail-recursive
code, and the optimization of small recursive functions is sometimes unpredictable.

