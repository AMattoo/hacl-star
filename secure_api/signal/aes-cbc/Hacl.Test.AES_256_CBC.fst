module Hacl.Test.AES_256_CBC

open FStar.HyperStack.All

open Lib.IntTypes
open Lib.RawIntTypes
open Lib.Buffer
open Lib.ByteBuffer

let key1 : b:ilbuffer uint8 (size 32){recallable b} =
  let l = [
    0x60; 0x3d; 0xeb; 0x10; 0x15; 0xca; 0x71; 0xbe;
    0x2b; 0x73; 0xae; 0xf0; 0x85; 0x7d; 0x77; 0x81;
    0x1f; 0x35; 0x2c; 0x07; 0x3b; 0x61; 0x08; 0xd7;
    0x2d; 0x98; 0x10; 0xa3; 0x09; 0x14; 0xdf; 0xf4
  ] in
  assert_norm(List.Tot.length l == 32);
  createL_global (List.Tot.map u8 l)

let iv1 : b:ilbuffer uint8 (size 16){recallable b} =
  let l = [
    0x00; 0x01; 0x02; 0x03; 0x04; 0x05; 0x06; 0x07;
    0x08; 0x09; 0x0A; 0x0B; 0x0C; 0x0D; 0x0E; 0x0F
  ] in
  assert_norm(List.Tot.length l == 16);
  createL_global (List.Tot.map u8 l)

let input1 : b:ilbuffer uint8 (size 16){recallable b} =
  let l = [
    0x6b; 0xc1; 0xbe; 0xe2; 0x2e; 0x40; 0x9f; 0x96;
    0xe9; 0x3d; 0x7e; 0x11; 0x73; 0x93; 0x17; 0x2a
  ] in
  assert_norm(List.Tot.length l == 16);
  createL_global (List.Tot.map u8 l)

let cip1 : b:ilbuffer uint8 (size 16){recallable b} =
  let l = [
    0xf5; 0x8c; 0x4c; 0x04; 0xd6; 0xe5; 0xf1; 0xba;
    0x77; 0x9e; 0xab; 0xfb; 0x5f; 0x7b; 0xfb; 0xd6
  ] in
  assert_norm(List.Tot.length l == 16);
  createL_global (List.Tot.map u8 l)

let key2 : b:ilbuffer uint8 (size 32){recallable b} =
  let l = [
    0x60; 0x3d; 0xeb; 0x10; 0x15; 0xca; 0x71; 0xbe;
    0x2b; 0x73; 0xae; 0xf0; 0x85; 0x7d; 0x77; 0x81;
    0x1f; 0x35; 0x2c; 0x07; 0x3b; 0x61; 0x08; 0xd7;
    0x2d; 0x98; 0x10; 0xa3; 0x09; 0x14; 0xdf; 0xf4
   ] in
  assert_norm(List.Tot.length l == 32);
  createL_global (List.Tot.map u8 l)

let iv2 : b:ilbuffer uint8 (size 16){recallable b} =
  let l = [
    0x00; 0x01; 0x02; 0x03; 0x04; 0x05; 0x06; 0x07;
    0x08; 0x09; 0x0A; 0x0B; 0x0C; 0x0D; 0x0E; 0x0F
  ] in
  assert_norm(List.Tot.length l == 16);
  createL_global (List.Tot.map u8 l)

let input2 : b:ilbuffer uint8 (size 64){recallable b} =
  let l = [
    0x6b; 0xc1; 0xbe; 0xe2; 0x2e; 0x40; 0x9f; 0x96;
    0xe9; 0x3d; 0x7e; 0x11; 0x73; 0x93; 0x17; 0x2a;
    0xae; 0x2d; 0x8a; 0x57; 0x1e; 0x03; 0xac; 0x9c;
    0x9e; 0xb7; 0x6f; 0xac; 0x45; 0xaf; 0x8e; 0x51;
    0x30; 0xc8; 0x1c; 0x46; 0xa3; 0x5c; 0xe4; 0x11;
    0xe5; 0xfb; 0xc1; 0x19; 0x1a; 0x0a; 0x52; 0xef;
    0xf6; 0x9f; 0x24; 0x45; 0xdf; 0x4f; 0x9b; 0x17;
    0xad; 0x2b; 0x41; 0x7b; 0xe6; 0x6c; 0x37; 0x10
   ] in
  assert_norm(List.Tot.length l == 64);
  createL_global (List.Tot.map u8 l)

let cip2 : b:ilbuffer uint8 (size 80){recallable b} =
  let l = [
    0xf5; 0x8c; 0x4c; 0x04; 0xd6; 0xe5; 0xf1; 0xba;
    0x77; 0x9e; 0xab; 0xfb; 0x5f; 0x7b; 0xfb; 0xd6;
    0x9c; 0xfc; 0x4e; 0x96; 0x7e; 0xdb; 0x80; 0x8d;
    0x67; 0x9f; 0x77; 0x7b; 0xc6; 0x70; 0x2c; 0x7d;
    0x39; 0xf2; 0x33; 0x69; 0xa9; 0xd9; 0xba; 0xcf;
    0xa5; 0x30; 0xe2; 0x63; 0x04; 0x23; 0x14; 0x61;
    0xb2; 0xeb; 0x05; 0xe2; 0xc3; 0x9b; 0xe9; 0xfc;
    0xda; 0x6c; 0x19; 0x07; 0x8c; 0x6a; 0x9d; 0x1b;
    0x3f; 0x46; 0x17; 0x96; 0xd6; 0xb0; 0xd6; 0xb2;
    0xe0; 0xc2; 0xa7; 0x2b; 0x4d; 0x80; 0xe6; 0x44
   ] in
  assert_norm(List.Tot.length l == 80);
  createL_global (List.Tot.map u8 l)

let key3 : b:ilbuffer uint8 (size 32){recallable b} =
  let l = [
    0x67; 0x2d; 0x38; 0xdd; 0x4b; 0x90; 0xaa; 0xde;
    0x77; 0x68; 0x79; 0xeb; 0x9e; 0x2a; 0xda; 0xc0;
    0x56; 0x61; 0xb5; 0x24; 0xe0; 0x68; 0x21; 0xc4;
    0x34; 0xe3; 0xec; 0x53; 0x58; 0xd0; 0xc8; 0xce
  ] in
  assert_norm(List.Tot.length l == 32);
  createL_global (List.Tot.map u8 l)

let iv3 : b:ilbuffer uint8 (size 16){recallable b} =
  let l = [
    0xfb; 0xff; 0xa2; 0xa3; 0x4e; 0xe5; 0x08; 0x38;
    0xcb; 0xee; 0x1b; 0x3a; 0x3c; 0xf1; 0x3f; 0xfc
  ] in
  assert_norm(List.Tot.length l == 16);
  createL_global (List.Tot.map u8 l)

#set-options "--lax"

let input3 : b:ilbuffer uint8 (size 159){recallable b} =
  let l = [
    0x3c; 0x5d; 0x07; 0x0d; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;
    0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00
   ] in
  assert_norm(List.Tot.length l == 159);
  createL_global (List.Tot.map u8 l)

let cip3 : b:ilbuffer uint8 (size 160){recallable b} =
  let l = [
    0x3c; 0x5d; 0x07; 0x0d; 0x1b; 0x75; 0xc4; 0x18;
    0xce; 0xf7; 0x69; 0xbd; 0x73; 0x78; 0xa5; 0x89;
    0x69; 0x53; 0x7a; 0x00; 0xe0; 0xff; 0x60; 0xcb;
    0xb9; 0x9d; 0xef; 0xb4; 0x86; 0xfc; 0xfb; 0x43;
    0x38; 0x42; 0x64; 0xda; 0x4e; 0xa9; 0x82; 0x1c;
    0x13; 0x36; 0xf0; 0x2d; 0x98; 0x8d; 0xa3; 0x89;
    0x44; 0x45; 0x33; 0x31; 0xc4; 0xb3; 0x01; 0x81;
    0x70; 0x4c; 0xbc; 0xec; 0x5a; 0x79; 0x2a; 0xb8;
    0x7c; 0x5c; 0xcf; 0xf2; 0x56; 0xe0; 0xb4; 0xd6;
    0x1b; 0xa6; 0xa3; 0x0a; 0x69; 0x64; 0x78; 0x38;
    0x75; 0x01; 0x88; 0x82; 0xe6; 0x6b; 0xfb; 0xd9;
    0x44; 0x5a; 0xc4; 0x4f; 0xee; 0x9d; 0xc6; 0x7e;
    0xdc; 0x2a; 0xd9; 0xde; 0x78; 0xad; 0xbe; 0x0e;
    0xb7; 0xe9; 0xcb; 0x99; 0x02; 0x72; 0x18; 0x3c;
    0xe5; 0xfa; 0xc6; 0x82; 0xee; 0x51; 0x06; 0xf6;
    0x7d; 0x73; 0x2c; 0xd1; 0x6d; 0xfb; 0x73; 0x12;
    0x39; 0x59; 0x0b; 0xa6; 0x7d; 0xc8; 0x27; 0xe8;
    0x49; 0xc4; 0x9a; 0x9f; 0xb5; 0xed; 0x8e; 0xed;
    0x41; 0xd8; 0x5d; 0x5e; 0x6d; 0xe3; 0x29; 0x4e;
    0x74; 0xf3; 0x52; 0x4c; 0x64; 0x89; 0xc2; 0xf2
   ] in
  assert_norm(List.Tot.length l == 160);
  createL_global (List.Tot.map u8 l)

val main: unit -> Stack C.exit_code
  (requires (fun h -> True))
  (ensures  (fun h0 r h1 -> True))
let main () =
  push_frame();
  let comp1 = create (size 32) (u8 0) in
  Hacl.Impl.AES_256_CBC.aes256_cbc_encrypt comp1 key1 iv1 input1 16ul;
  TestLib.compare_and_print (C.String.of_literal "AES-CBC encryption 1") cip1 comp1 16ul;
  let dec1 = create (size 16) (u8 0) in
  let len1 = Hacl.Impl.AES_256_CBC.aes256_cbc_decrypt dec1 key1 iv1 comp1 32ul in
  if len1 <> 16ul then C.String.print (C.String.of_literal "incorrect length from decryption\n") else ();
  TestLib.compare_and_print (C.String.of_literal "AES-CBC decryption 1") input1 dec1 16ul;

  let comp2 = create (size 80) (u8 0) in
  Hacl.Impl.AES_256_CBC.aes256_cbc_encrypt comp2 key2 iv2 input2 64ul;
  TestLib.compare_and_print (C.String.of_literal "AES-CBC encryption 2") cip2 comp2 80ul;
  let dec2 = create (size 64) (u8 0) in
  let len2 = Hacl.Impl.AES_256_CBC.aes256_cbc_decrypt dec2 key2 iv2 comp2 80ul in
  if len2 <> 64ul then C.String.print (C.String.of_literal "incorrect length from decryption\n") else ();
  TestLib.compare_and_print (C.String.of_literal "AES-CBC decryption 2") input2 dec2 64ul;

  let comp3 = create (size 160) (u8 0) in
  Hacl.Impl.AES_256_CBC.aes256_cbc_encrypt comp3 key3 iv3 input3 159ul;
  TestLib.compare_and_print (C.String.of_literal "AES-CBC encryption 3") cip3 comp3 160ul;
  let dec3 = create (size 159) (u8 0) in
  let len3 = Hacl.Impl.AES_256_CBC.aes256_cbc_decrypt dec3 key3 iv3 comp3 160ul in
  if len3 <> 159ul then C.String.print (C.String.of_literal "incorrect length from decryption\n") else ();
  TestLib.compare_and_print (C.String.of_literal "AES-CBC decryption 3") input3 dec3 159ul;
  pop_frame();
  C.EXIT_SUCCESS
