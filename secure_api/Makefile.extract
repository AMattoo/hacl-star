# This Makefile is capable of separately lax-checking files in parallel using a
# .depend file; it then generates, in the out/ directory:
# - QuicProvider, an OCaml library that calls a C-compiled HACL*
# - LowCProvider, an OCaml library like the one above, with a smaller API
# - Crypto_AEAD_Main.c, a standalone version of secure_api that is suitable for
#   the miTLS build in pure C.
#
# An extraction configuration is made up of $(CONCRETE_DIR)/Flag.fst, which
# eliminates all the ideal code. Furthermore, a particular compile-time choice of
# algorithms can be achieved by re-defining the Crypto.Indexing.fst file.
#
# In this Makefile, the implementation choice is IMPL_CHOICE, which can be
# overriden with any of the directory names in concrete_specializations/.
#
# A caller of this Makefile need not run "make clean" before using a different
# IMPL_CHOICE.
HACL_HOME 	?= ..
KREMLIN_HOME 	?= ../../kremlin
FSTAR_HOME 	?= ../../FStar
CONCRETE_DIR	= $(HACL_HOME)/secure_api/concrete_specializations
IMPL_CHOICE	?= runtime_switch
DIST_DIR	= out/$(IMPL_CHOICE)
OUTPUT_DIR	= $(DIST_DIR)/extracted

# Warning: these are not always buildable, depending on IMPL_CHOICE...! Consult
# the main Makefile for valid combinations.
all: standalone $(DIST_DIR)/krml-test.exe $(DIST_DIR)/LowCProvider.cmxa

standalone: $(DIST_DIR)/Crypto_AEAD_Main.c

test: $(DIST_DIR)/krml-test.exe
	./$<

# The include paths, including the implementation choice.
INCLUDE_PATHS=$(addprefix --include , \
	$(HACL_HOME)/specs \
	$(HACL_HOME)/code/bignum \
	$(HACL_HOME)/code/experimental/aesgcm \
	$(HACL_HOME)/code/lib/kremlin \
	$(HACL_HOME)/code/poly1305 \
	$(HACL_HOME)/code/salsa-family \
	$(KREMLIN_HOME)/kremlib	\
	$(HACL_HOME)/secure_api \
	$(HACL_HOME)/secure_api/aead \
	$(HACL_HOME)/secure_api/prf \
	$(HACL_HOME)/secure_api/vale \
	$(HACL_HOME)/secure_api/uf1cma \
	$(HACL_HOME)/secure_api/utils \
	$(HACL_HOME)/secure_api/LowCProvider/fst \
	$(CONCRETE_DIR) $(CONCRETE_DIR)/$(IMPL_CHOICE))

# The F* compiler and the entry points.
FSTAR=$(FSTAR_HOME)/bin/fstar.exe $(OTHERFLAGS) --lax --cache_checked_modules \
	$(INCLUDE_PATHS) --odir $(OUTPUT_DIR)
FSTAR_FILES=aead/Crypto.AEAD.Main.fst test/KrmlTest.fst LowCProvider/fst/LowCProvider.fst

# Horrible Makefile trick.
.hack.$(IMPL_CHOICE):
	@rm -rf .hack.*
	touch $@

# Automatic dependency analysis; the hack forces this target to be rebuilt
# whenever the value of $(IMPL_CHOICE) changes.
.depend.extract: .hack.$(IMPL_CHOICE) $(OUTPUT_DIR)
	$(FSTAR) --dep full $(FSTAR_FILES) > .depend.extract

include .depend.extract

# Now we get parallel lax-checking, which is nice.
%.checked.lax: %
	$(FSTAR) $*
	touch $@

# Another generic rule that leverages .depend.extract, for interactive
# verification.
%.fsti-in:
	@echo --hint_info $(INCLUDE_PATHS) $(OTHERFLAGS) --lax \
	  --cache_checked_modules

# F* doesn't recursively create directories for --odir
$(OUTPUT_DIR):
	mkdir -p $@

# Filling out the right invocations to generate a .krml
$(OUTPUT_DIR)/%.krml:
	$(FSTAR) $(subst .checked.lax,,$<) --codegen Kremlin --extract_module \
	  $(basename $(notdir $(subst .checked.lax,,$<)))

# ... and a .ml file. Note: it's hard to put these in two separate
# sub-directories because they share the --odir option of F*.
$(OUTPUT_DIR)/%.ml:
	$(FSTAR) $(subst .checked.lax,,$<) --codegen OCaml --extract_module \
	  $(basename $(notdir $(subst .checked.lax,,$<)))

# First target: a clean, single-file version of the library suitable for the
# build of miTLS in pure C. No subtlety in the list of dependencies...
$(DIST_DIR)/Crypto_AEAD_Main.h \
$(DIST_DIR)/Crypto_AEAD_Main.c: $(filter-out $(OUTPUT_DIR)/prims.krml,$(ALL_KRML_FILES))
	$(KREMLIN_HOME)/krml $(KOPTS) -bundle Crypto.AEAD.Main=* -add-include \
	  '"kremstr.h"' -add-include '"testlib.h"' -add-include '"kremlib.h"' \
	  -add-include '"Crypto_Indexing.h"' -skip-compilation -minimal -drop \
	  Crypto.Indexing -drop KrmlTest,LowCProvider,CryptoTypes -tmpdir $(DIST_DIR) $^

# Building vale.a via a recursive invocation.
VALE_A = vale/asm/vale.a
.PHONY: $(VALE_A)
$(VALE_A):
	$(MAKE) -C vale/asm

# These three concrete specializations want you to link in vale.a
vale_aes_concrete_id_EXTRA 	= $(VALE_A)
vale_aes_abstract_id_EXTRA 	= $(VALE_A)
runtime_switch_EXTRA 		= $(VALE_A)

# Second target: the functional test. Note: this does not yet use the
# standalone C file because the test still bypasses Crypto.AEAD.Main
$(DIST_DIR)/krml-test.exe: $(filter-out $(OUTPUT_DIR)/prims.krml,$(ALL_KRML_FILES)) $($(IMPL_CHOICE)_EXTRA)
	$(KREMLIN_HOME)/krml $(KOPTS) -no-prefix KrmlTest -bundle \
	  Hacl.Impl.Poly1305_64+Hacl.Impl.Chacha20=Hacl.*,Spec,Spec.* -bundle \
	    Crypto.AEAD.Main=Crypto.* -add-include '"kremstr.h"' -add-include \
	  '"testlib.h"' -add-include '"kremlib.h"' -tmpdir $(OUTPUT_DIR) $^ -o $@ \
	  -drop LowCProvider,CryptoTypes $(KREMLIN_HOME)/kremlib/testlib.c

# Third target: the LowC interface. There are several sub-parts.

# Extracting a standalone header & C file from a single fst file.
$(DIST_DIR)/%.h $(DIST_DIR)/%.c: $(filter-out $(OUTPUT_DIR)/prims.krml,$(ALL_KRML_FILES))
	$(KREMLIN_HOME)/krml $(KOPTS) -bundle '$*=*' -minimal -skip-compilation \
	  -tmpdir $(DIST_DIR) $^ -add-include '"kremlib.h"' -add-include '"kremstr.h"'

# Since we're building an actual C file, we need the standalone AEAD file, along
# with the actual extraction of the index. We also need a helper from
# Crypto.Symmetric.Bytes.
HEADERS=$(DIST_DIR)/Crypto_Symmetric_Bytes.h $(DIST_DIR)/Crypto_Indexing.h \
  $(DIST_DIR)/Crypto_AEAD_Main.h

$(DIST_DIR)/Crypto_AEAD_Main.o: $(HEADERS)
LowCProvider/lowc_stub.o: $(HEADERS)

OCAMLOPTS=-package fstarlib,zarith -g -I $(FSTAR_HOME)/ulib/ml
OCAMLOPT=OCAMLPATH="$(FSTAR_HOME)/bin" ocamlfind opt $(OCAMLOPTS)
OCAMLMKLIB=OCAMLPATH="$(FSTAR_HOME)/bin" ocamlfind mklib $(OCAMLOPTS)

# Then, we need to generate some .o ourselves, using ocamlopt to get all the
# right include paths...
%.o: %.c
	$(OCAMLOPT) -c $< -I $(DIST_DIR) -I $(KREMLIN_HOME)/kremlib -ccopt -o \
	  -ccopt $@ -ccopt -fPIC -ccopt -Wno-unused-variable -ccopt -Wno-parentheses

# Finally, ocamlmklib is smart enough to take all of these at once.
$(DIST_DIR)/LowCProvider.cmxa: \
	  $(OUTPUT_DIR)/CryptoTypes.ml LowCProvider/LowCProvider.ml \
	  LowCProvider/lowc_stub.o \
	  $(DIST_DIR)/Crypto_AEAD_Main.o $(DIST_DIR)/Crypto_Indexing.o \
	  $(DIST_DIR)/Crypto_Symmetric_Bytes.o $($(IMPL_CHOICE)_EXTRA)
	$(MAKE) -C $(FSTAR_HOME)/ulib/ml
	$(OCAMLMKLIB) -I $(OUTPUT_DIR) $^


clean:
	rm -rf .depend.extract out/*
