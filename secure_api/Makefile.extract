# This Makefile is capable of separately lax-checking files in parallel using a
# .depend file; it then generates, in the out/ directory:
# - Crypto_AEAD_Main.c, a standalone version of secure_api that is suitable for
#   the miTLS build in pure C.
# - krml-test.exe, a test driver for AEAD
#
# An extraction configuration is made up of $(CONCRETE_DIR)/Flag.fst, which
# eliminates all the ideal code. Furthermore, a particular compile-time choice of
# algorithms can be achieved by re-defining the Crypto.Indexing.fst file.
#
# In this Makefile, the implementation choice is IMPL_CHOICE, which can be
# overriden with any of the directory names in concrete_specializations/.
#
# A caller of this Makefile need not run "make clean" before using a different
# IMPL_CHOICE.
HACL_HOME=..

include Makefile.common

# Warning: these are not always buildable, depending on IMPL_CHOICE...! Consult
# the main Makefile for valid combinations.
all: $(DIST_DIR)/krml-test.exe

################################################################################
# This Makefile ought to work with and without compiler support for UInt128    #
################################################################################

ifneq (,$(EVEREST_WINDOWS))
KOPTS+=-falloca -ftail-calls
CFLAGS+=# -DKRML_NOSTRUCT_PASSING
endif

################################################################################
# Main configurations                                    		       #
################################################################################

CRYPTO_DIR = $(DIST_DIR)/crypto
TLS_FFI_DIR = $(MITLS_HOME)/libs/ffi

abstract: $(CRYPTO_DIR)/Crypto_AEAD_Main.h base

concrete: $(CRYPTO_DIR)/Crypto_AEAD_Main_Crypto_Symmetric_Cipher_Crypto_Indexing.h base

base: $(CRYPTO_DIR)/Crypto_Symmetric_Bytes.h

%.test: %
	./$<

test: krml-test
krml-test: $(DIST_DIR)/krml-test.exe.test

################################################################################
# Building upon the generated .depend file				       #
################################################################################

ifeq (,$(VERIFY))
FSTAR += --admit_smt_queries true
endif

# The entry points
FSTAR_FILES=aead/Crypto.AEAD.Main.fst test/KrmlTest.fst

EXTRACT='* -FStar -CryptoTypes'
# Automatic dependency analysis; the hack forces this target to be rebuilt
# whenever the value of $(IMPL_CHOICE) changes.
.depend.$(IMPL_CHOICE): | $(CACHE_DIR) $(OUTPUT_DIR)
	$(FSTAR) --extract $(EXTRACT) --dep full $(FSTAR_FILES) > .depend.$(IMPL_CHOICE)

include .depend.$(IMPL_CHOICE)

verification: $(addprefix $(CACHE_DIR)/,$(notdir $(addsuffix .checked,$(ALL_FST_FILES))))
	echo $^

# Now we get parallel lax-checking, which is nice.
# cwinter: The order-only dependency makes sure that F* will not run until
# .depend.* is re-generated. Otherwise it can happen that this rule is executed
# in parallel with the .depend rule, where this rule uses the old .depend file.
%.checked: | .depend.$(IMPL_CHOICE) $(CACHE_DIR) $(OUTPUT_DIR)
	$(FSTAR) $<
	touch $@

# Filling out the right invocations to generate a .krml
$(OUTPUT_DIR)/%.krml: | $(OUTPUT_DIR)
	$(FSTAR) \
          $(subst $(CACHE_DIR)/,,$(subst .checked,,$<)) \
	  --codegen Kremlin \
	  --extract_module $(basename $(notdir $(subst .checked,,$<)))

# ... and a .ml file. Note: it's hard to put these in two separate
# sub-directories because they share the --odir option of F*.
$(OUTPUT_DIR)/%.ml: | $(OUTPUT_DIR)
	$(FSTAR) \
	  $(subst $(CACHE_DIR)/,,$(subst .checked,,$<)) \
	  --codegen OCaml \
	  --extract_module $(basename $(notdir $(subst .checked,,$<)))


################################################################################
# 1. A clean single-file version of AEAD for the C build of miTLS    	       #
################################################################################

CCOPTS+=-Wno-unused-variable -Wno-unused-parameter -Wno-unused-but-set-variable \
  -Wno-parentheses -Werror -Wno-unknown-warning-option

MY_KRML_FILES=$(filter-out $(OUTPUT_DIR)/prims.krml,$(ALL_KRML_FILES))

# Generic rule for single-file KreMLin packaging -- use with caution, this may
# repeat most of your program in every single compilation unit.
$(CRYPTO_DIR)/%.h $(CRYPTO_DIR)/%.c: $(MY_KRML_FILES)
	$(KREMLIN_HOME)/krml $(KOPTS) -bundle '$(if $(BUNDLE),$(BUNDLE),$*)=*' -minimal -skip-compilation \
	  -tmpdir $(CRYPTO_DIR) $^ -add-include '"kremlib.h"' -add-include '"kremlin/internal/compat.h"' \
	  $(EXTRA)

# Manually override the default argument for bundles, so as to provide a +
$(CRYPTO_DIR)/Crypto_AEAD_Main_Crypto_Symmetric_Cipher_Crypto_Indexing.c \
  $(CRYPTO_DIR)/Crypto_AEAD_Main_Crypto_Symmetric_Cipher_Crypto_Indexing.h: BUNDLE=Crypto_AEAD_Main+Crypto_Symmetric_Cipher+Crypto_Indexing

# This is without the indexing id.
$(CRYPTO_DIR)/Crypto_AEAD_Main.h: EXTRA = -add-include '"Crypto_Indexing.h"' -drop Crypto.Indexing


################################################################################
# 2. Compiling Vale on all platforms                             	       #
################################################################################

VALE_DIR = vale/asm

VALE_OBJ = $(addprefix $(VALE_DIR)/,sha256_main_i.o \
  sha256-$(MARCH)$(VARIANT).o Vale_Hash_SHA2_256.o \
  vale_aes_glue.o \
  aes-$(MARCH)$(VARIANT).o)
#  aesgcm-$(MARCH)$(VARIANT).o WIP

# These three concrete specializations want you to bring in the vale object
# files into your cmxa / .exe
vale_aes_concrete_id_EXTRA 	= $(VALE_OBJ)
vale_aes_abstract_id_EXTRA 	= $(VALE_OBJ)
runtime_switch_EXTRA 		= $(VALE_OBJ)

# Easy!
%.o: %.S
	$(CC) $(CCOPTS) -c $< -o $@

# For convenient linking from miTLS
$(DIST_DIR)/vale.a: $(VALE_OBJ)
	ar cr $@ $^

vale: $(DIST_DIR)/vale.a

################################################################################
# 3. The functional test, krml-test.exe                          	       #
################################################################################

$(DIST_DIR)/copied/%.c: $(KREMLIN_HOME)/kremlib/%.c
	mkdir -p $(dir $@)
	cp $< $@

# Note: this does not yet use the standalone C file because the test still
# bypasses Crypto.AEAD.Main
.PRECIOUS: $(DIST_DIR)/krml-test.exe
$(DIST_DIR)/krml-test.exe: $(MY_KRML_FILES) $($(IMPL_CHOICE)_EXTRA)
	$(KREMLIN_HOME)/krml $(KOPTS) -no-prefix KrmlTest -bundle \
	  Hacl.Impl.Poly1305_64+Hacl.Impl.Chacha20=Hacl.*,Spec,Spec.* -bundle \
	    Crypto.AEAD.Main=Crypto.* -tmpdir $(OUTPUT_DIR) \
	    -add-include '"kremlin/internal/compat.h"' \
	  $^ -o $@

# Note: we don't use gcc -MM because this would need to happen after KreMLin
# extraction, and then every run of this Makefile would start by extracting the
# entire world just to get the dependencies between C files.
$(CRYPTO_DIR)/Crypto_AEAD_Main_Crypto_Symmetric_Cipher_Crypto_Indexing.o: $(HEADERS)

OCAMLOPTS=-package fstarlib,zarith -g -I $(FSTAR_HOME)/ulib/ml
OCAMLOPT=OCAMLPATH="$(FSTAR_HOME)/bin" ocamlfind opt $(OCAMLOPTS)
OCAMLC=OCAMLPATH="$(FSTAR_HOME)/bin" ocamlfind ocamlc $(OCAMLOPTS)
OCAMLMKLIB=OCAMLPATH="$(FSTAR_HOME)/bin" ocamlfind mklib -g -I $(FSTAR_HOME)/ulib/ml

# Then, we need to generate some .o ourselves, using ocamlopt to get all the
# right include paths...
%.o: %.c
	$(OCAMLOPT) -c $< -I $(dir $@) -I $(DIST_DIR) -I $(KREMLIN_HOME)/include \
	  -I $(TLS_FFI_DIR) -ccopt "-o $@" -I $(CRYPTO_DIR) \
	  $(addprefix -ccopt ,$(CCOPTS))

# Gross approximation: the cmx's we build are most likely extracted F* code and,
# as such, require a working fstarlib.
%.cmx: %.ml $(FSTAR_HOME)/bin/fstarlib/fstarlib.cmxa
	$(OCAMLOPT) -c $< -I $(DIST_DIR) -I $(OUTPUT_DIR) -o $@

%.cmo: %.ml $(FSTAR_HOME)/bin/fstarlib/fstarlib.cma
	$(OCAMLC) -c $< -I $(DIST_DIR) -I $(OUTPUT_DIR) -o $@

ARCHIVE_FILES= $(VALE_OBJ) \
    $(CRYPTO_DIR)/Crypto_AEAD_Main_Crypto_Symmetric_Cipher_Crypto_Indexing.o \
    $(CHACHA_DIR)/Hacl_Chacha20.o \
    $(POLY_DIR)/AEAD_Poly1305_64.o \
    $(POLICIES_DIR)/Hacl_Policies.o \
    $(CHACHAPOLY_DIR)/Hacl_Chacha20Poly1305.o \
    $(CRYPTO_DIR)/Crypto_Symmetric_Bytes.o $(CURVE_DIR)/Hacl_Curve25519.o \
    $($(IMPL_CHOICE)_EXTRA)

