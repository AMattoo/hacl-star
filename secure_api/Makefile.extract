# This Makefile is capable of separately lax-checking files in parallel using a
# .depend file; it then generates, in the out/ directory:
# - QuicProvider, a C library that wraps a C-compiled HACL*
# - LowCProvider, an OCaml library like the one above, with a smaller API
# - Crypto_AEAD_Main.c, a standalone version of secure_api that is suitable for
#   the miTLS build in pure C.
# - krml-test.exe, a test driver for AEAD
# - LowCTests.exe, a test driver for LowCProvider
#
# An extraction configuration is made up of $(CONCRETE_DIR)/Flag.fst, which
# eliminates all the ideal code. Furthermore, a particular compile-time choice of
# algorithms can be achieved by re-defining the Crypto.Indexing.fst file.
#
# In this Makefile, the implementation choice is IMPL_CHOICE, which can be
# overriden with any of the directory names in concrete_specializations/.
#
# A caller of this Makefile need not run "make clean" before using a different
# IMPL_CHOICE.
HACL_HOME=..

include Makefile.common

# Warning: these are not always buildable, depending on IMPL_CHOICE...! Consult
# the main Makefile for valid combinations.
all: $(DIST_DIR)/krml-test.exe $(DIST_DIR)/LowC.cmxa

# Makefile bug here: the second file is never generated (because of the +).
abstract: $(DIST_DIR)/Crypto_AEAD_Main.h base

# Ibid.
concrete: $(DIST_DIR)/Crypto_AEAD_Main_Crypto_Indexing.h base

base: $(DIST_DIR)/Crypto_HKDF_Crypto_HMAC.h $(DIST_DIR)/Crypto_Symmetric_Bytes.h

%.test: %
	./$<

test: krml-test lowc-test
krml-test: $(DIST_DIR)/krml-test.exe.test
lowc-test: $(DIST_DIR)/LowCTests.exe.test

################################################################################
# Building upon the generated .depend file				       #
################################################################################

# Extraction runs F* in --lax mode
FSTAR += --lax

# The entry points
FSTAR_FILES=aead/Crypto.AEAD.Main.fst test/KrmlTest.fst \
  LowCProvider/fst/LowCProvider.fst LowCProvider/fst/HaclProvider.fst \
  hkdf/Crypto.HKDF.fst

EXTRACT='* -FStar -CryptoTypes'
# Automatic dependency analysis; the hack forces this target to be rebuilt
# whenever the value of $(IMPL_CHOICE) changes.
.depend.$(IMPL_CHOICE):
	mkdir -p $(OUTPUT_DIR)
	$(FSTAR) --extract $(EXTRACT) --dep full $(FSTAR_FILES) > .depend.$(IMPL_CHOICE)

include .depend.$(IMPL_CHOICE)

# Now we get parallel lax-checking, which is nice.
%.checked.lax:
	$(FSTAR) $<
	touch $@

# F* doesn't recursively create directories for --odir
$(OUTPUT_DIR):
	mkdir -p $@

# Filling out the right invocations to generate a .krml
$(OUTPUT_DIR)/%.krml:
	$(FSTAR) \
          $(subst $(CACHE_DIR)/,,$(subst .checked.lax,,$<)) \
	  --codegen Kremlin \
	  --extract_module $(basename $(notdir $(subst .checked.lax,,$<)))

# ... and a .ml file. Note: it's hard to put these in two separate
# sub-directories because they share the --odir option of F*.
$(OUTPUT_DIR)/%.ml:
	$(FSTAR) \
	  $(subst $(CACHE_DIR)/,,$(subst .checked.lax,,$<)) \
	  --codegen OCaml \
	  --extract_module $(basename $(notdir $(subst .checked.lax,,$<)))


################################################################################
# 1. A clean single-file version of AEAD for the C build of miTLS    	       #
################################################################################

# Generic rule for single-file KreMLin packaging -- use with caution, this may
# repeat most of your program in every single compilation unit.
$(DIST_DIR)/%.h $(DIST_DIR)/%.c: $(filter-out $(OUTPUT_DIR)/prims.krml,$(ALL_KRML_FILES))
	$(KREMLIN_HOME)/krml $(KOPTS) -bundle '$(if $(BUNDLE),$(BUNDLE),$*)=*' -minimal -skip-compilation \
	  -tmpdir $(DIST_DIR) $^ -add-include '"kremlib.h"' -add-include '"kremstr.h"' \
	  $(EXTRA)

# Manually override the default argument for bundles, so as to provide a +
$(DIST_DIR)/Crypto_AEAD_Main_Crypto_Indexing.c \
  $(DIST_DIR)/Crypto_AEAD_Main_Crypto_Indexing.h: BUNDLE=Crypto_AEAD_Main+Crypto_Indexing

$(DIST_DIR)/Crypto_HKDF_Crypto_HMAC.c \
  $(DIST_DIR)/Crypto_HKDF_Crypto_HMAC.h: BUNDLE=Crypto_HKDF+Crypto_HMAC

# This is without the indexing id.
$(DIST_DIR)/Crypto_AEAD_Main.h: EXTRA = -add-include '"testlib.h"' -add-include '"Crypto_Indexing.h"' -drop Crypto.Indexing


################################################################################
# 2. Compiling Vale on all platforms                             	       #
################################################################################

VALE_DIR = vale/asm

VALE_OBJ = $(addprefix $(VALE_DIR)/,sha256_main_i.o \
  sha256-$(MARCH)$(VARIANT).o Vale_Hash_SHA2_256.o \
  vale_aes_glue.o aes-$(MARCH)$(VARIANT).o)

# These three concrete specializations want you to bring in the vale object
# files into your cmxa / .exe
vale_aes_concrete_id_EXTRA 	= $(VALE_OBJ)
vale_aes_abstract_id_EXTRA 	= $(VALE_OBJ)
runtime_switch_EXTRA 		= $(VALE_OBJ)

# Easy!
%.o: %.S
	$(CC) $(CCOPTS) -c $< -o $@

# For convenient linking from miTLS
out/vale.a: $(VALE_OBJ)
	ar cr $@ $^

################################################################################
# 3. The functional test, krml-test.exe                          	       #
################################################################################

copied/%.c: $(KREMLIN_HOME)/kremlib/%.c
	mkdir -p $(dir $@)
	cp $< $@

# Note: this does not yet use the standalone C file because the test still
# bypasses Crypto.AEAD.Main
$(DIST_DIR)/krml-test.exe: $(filter-out $(OUTPUT_DIR)/prims.krml,$(ALL_KRML_FILES)) $($(IMPL_CHOICE)_EXTRA) copied/testlib.c
	$(KREMLIN_HOME)/krml $(KOPTS) -no-prefix KrmlTest -bundle \
	  Hacl.Impl.Poly1305_64+Hacl.Impl.Chacha20=Hacl.*,Spec,Spec.* -bundle \
	    Crypto.AEAD.Main=Crypto.* -add-include '"kremstr.h"' -add-include \
	  '"testlib.h"' -add-include '"kremlib.h"' -tmpdir $(OUTPUT_DIR) $^ -o $@ \
	  -drop HaclProvider,LowCProvider,CryptoTypes

################################################################################
# 4. The LowC provider library                                   	       #
################################################################################

CURVE_DIR=$(HACL_HOME)/code/curve25519/x25519-c/

ifeq (,$(wildcard $(FSTAR_HOME)/bin/fstarlib/fstarlib.cmxa))
  $(error FSTAR_HOME is $(FSTAR_HOME) and I cannot find $(FSTAR_HOME)/bin/fstarlib/fstarlib.cmxa -- please run make in $(FSTAR_HOME)/ulib/ml)
endif

ifeq (,$(wildcard $(CURVE_DIR)/Curve25519.c))
  $(error The Curve25519 directory is $(CURVE_DIR) and I cannot find $(CURVE_DIR)/Curve25519.c -- please run make extract-c in $(CURVE_DIR)/..)
endif

# Since we're building an actual C file, we need the standalone AEAD file, along
# with the actual extraction of the index. We also need a helper from
# Crypto.Symmetric.Bytes.
HEADERS=$(DIST_DIR)/Crypto_Symmetric_Bytes.h $(CURVE_DIR)/Curve25519.h $(CURVE_DIR)/FStar.h \
	  $(DIST_DIR)/Crypto_AEAD_Main_Crypto_Indexing.h

# Note: we don't use gcc -MM because this would need to happen after KreMLin
# extraction, and then every run of this Makefile would start by extracting the
# entire world just to get the dependencies between C files.
$(DIST_DIR)/Crypto_AEAD_Main_Crypto_Indexing.o: $(HEADERS)
LowCProvider/lowc_stub.o: $(HEADERS)

OCAMLOPTS=-package fstarlib,zarith -g -I $(FSTAR_HOME)/ulib/ml
OCAMLOPT=OCAMLPATH="$(FSTAR_HOME)/bin" ocamlfind opt $(OCAMLOPTS)
OCAMLMKLIB=OCAMLPATH="$(FSTAR_HOME)/bin" ocamlfind mklib $(OCAMLOPTS)

# Then, we need to generate some .o ourselves, using ocamlopt to get all the
# right include paths...
%.o: %.c
	$(OCAMLOPT) -c $< -I $(DIST_DIR) -I $(KREMLIN_HOME)/kremlib -I $(MLCRYPTO_HOME) -ccopt -o \
	  -ccopt $@ -ccopt -fPIC -ccopt -Wno-unused-variable -ccopt -Wno-parentheses \
	  -I $(CURVE_DIR)

# Gross approximation: the cmx's we build are most likely extracted F* code and,
# as such, require a working fstarlib.
%.cmx: %.ml $(FSTAR_HOME)/bin/fstarlib/fstarlib.cmxa
	$(OCAMLOPT) -c $< -I LowCProvider -I $(DIST_DIR) -I $(OUTPUT_DIR) -I $(MLCRYPTO_HOME) -o $@

# Note: we don't use ocamldep because this would need to happen after
# extraction... meaning that the Makefile, no matter what, would always
# re-extract to get the dependencies. Make it a separate target?
.PHONY: $(MLCRYPTO_HOME)/CryptoTypes.cmx
$(MLCRYPTO_HOME)/CryptoTypes.cmx:
	$(MAKE) -C $(MLCRYPTO_HOME)

LowCProvider/LowCProvider.cmx: $(MLCRYPTO_HOME)/CryptoTypes.cmx
LowCProvider/Tests.cmx: LowCProvider/LowCProvider.cmx

# Finally, ocamlmklib is smart enough to take all of these at once.
$(DIST_DIR)/LowC.cmxa: \
	  LowCProvider/LowCProvider.cmx \
	  LowCProvider/HaclProvider.cmx \
	  LowCProvider/lowc_stub.o \
	  $(DIST_DIR)/Crypto_AEAD_Main_Crypto_Indexing.o \
	  $(DIST_DIR)/Crypto_Symmetric_Bytes.o $(CURVE_DIR)/Curve25519.o \
	  $(CURVE_DIR)/FStar.o $($(IMPL_CHOICE)_EXTRA)
	$(OCAMLMKLIB) -I $(OUTPUT_DIR) $^ -o $(patsubst %.cmxa,%,$@)


################################################################################
# 5. The LowC provider tests                                     	       #
################################################################################

# Note: clients of MLCrypto are generally assumed to use CoreCrypto.cmxa but
# here since we just need the type definitions we optimize the linking and just
# pass CryptoTypes.cmx
$(DIST_DIR)/LowCTests.exe: copied/kremstr.o \
	  $(MLCRYPTO_HOME)/CryptoTypes.cmx $(DIST_DIR)/LowC.cmxa LowCProvider/Tests.cmx
	$(OCAMLOPT) -I $(OUTPUT_DIR) -I LowCProvider \
	  -ccopt -L$(DIST_DIR) -linkpkg $^ -o $@

clean:
	rm -rf .depend.extract out/* vale/asm/*.o LowCProvider/*.{cm*,o,a}
