/* This file was auto-generated by KreMLin! */

#include "Hacl_Mult.h"

static bool
Hacl_Impl_Lib_bn_is_bit_set(Prims_nat len, uint32_t clen, uint64_t *input, uint32_t ind)
{
  uint32_t i = ind / (uint32_t)64U;
  uint32_t j = ind % (uint32_t)64U;
  uint64_t tmp = input[i];
  uint64_t x0 = tmp >> j & (uint64_t)1U;
  return x0 == (uint64_t)1U;
}

static void
Hacl_Impl_Lib_bn_set_bit(Prims_nat len, uint32_t clen, uint64_t *input, uint32_t ind)
{
  uint32_t i = ind / (uint32_t)64U;
  uint32_t j = ind % (uint32_t)64U;
  uint64_t tmp = input[i];
  input[i] = tmp | (uint64_t)1U << j;
}

static void Hacl_Impl_Lib_fill(Prims_nat len, uint32_t clen, uint64_t *b, uint64_t z)
{
  for (uint32_t i = (uint32_t)0U; i < clen; i = i + (uint32_t)1U)
    b[i] = z;
}

static bool
Hacl_Impl_Lib_eq_b_(Prims_nat len, uint32_t clen, uint8_t *b1, uint8_t *b2, uint32_t i)
{
  if (i < clen)
  {
    uint8_t uu____851 = b1[i];
    uint8_t uu____888 = b2[i];
    bool uu____850 = uu____851 == uu____888;
    if (uu____850)
      return Hacl_Impl_Lib_eq_b_(len, clen, b1, b2, i + (uint32_t)1U);
    else
      return false;
  }
  else
    return true;
}

bool Hacl_Impl_Lib_eq_b(Prims_nat len, uint32_t clen, uint8_t *b1, uint8_t *b2)
{
  return Hacl_Impl_Lib_eq_b_(len, clen, b1, b2, (uint32_t)0U);
}

static void
Hacl_Impl_Addition_bn_sub_(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint32_t i,
  uint64_t carry,
  uint64_t *res
)
{
  if (i < caLen)
  {
    uint64_t t1 = a[i];
    uint64_t t2;
    if (i < cbLen)
      t2 = b[i];
    else
      t2 = (uint64_t)0U;
    uint64_t res_i = t1 - t2 - carry;
    res[i] = res_i;
    uint64_t carry1;
    if (carry == (uint64_t)1U)
    {
      uint64_t ite;
      if (t1 <= t2)
        ite = (uint64_t)1U;
      else
        ite = (uint64_t)0U;
      carry1 = ite;
    }
    else
    {
      uint64_t ite;
      if (t1 < t2)
        ite = (uint64_t)1U;
      else
        ite = (uint64_t)0U;
      carry1 = ite;
    }
    Hacl_Impl_Addition_bn_sub_(aLen, bLen, caLen, a, cbLen, b, i + (uint32_t)1U, carry1, res);
  }
}

static void
Hacl_Impl_Addition_bn_sub(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint64_t *res
)
{
  Hacl_Impl_Addition_bn_sub_(aLen, bLen, caLen, a, cbLen, b, (uint32_t)0U, (uint64_t)0U, res);
}

static uint64_t
Hacl_Impl_Addition_bn_add_(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint32_t i,
  uint64_t carry,
  uint64_t *res
)
{
  if (i < caLen)
  {
    uint64_t t1 = a[i];
    uint64_t t2;
    if (i < cbLen)
      t2 = b[i];
    else
      t2 = (uint64_t)0U;
    uint64_t res_i = t1 + t2 + carry;
    res[i] = res_i;
    uint64_t carry1;
    if (res_i < t1)
      carry1 = (uint64_t)1U;
    else
      carry1 = (uint64_t)0U;
    return
      Hacl_Impl_Addition_bn_add_(aLen,
        bLen,
        caLen,
        a,
        cbLen,
        b,
        i + (uint32_t)1U,
        carry1,
        res);
  }
  else
    return carry;
}

static void
Hacl_Impl_Addition_bn_add(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint64_t *res
)
{
  (void)Hacl_Impl_Addition_bn_add_(aLen,
    bLen,
    caLen,
    a,
    cbLen,
    b,
    (uint32_t)0U,
    (uint64_t)0U,
    res);
}

static void
Hacl_Impl_Addition_bn_add_carry(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t caLen,
  uint64_t *a,
  uint32_t cbLen,
  uint64_t *b,
  uint64_t *res
)
{
  uint64_t *res_ = res;
  uint64_t
  carry =
    Hacl_Impl_Addition_bn_add_(aLen,
      bLen,
      caLen,
      a,
      cbLen,
      b,
      (uint32_t)0U,
      (uint64_t)0U,
      res_);
  res[caLen] = carry;
}

static bool
Hacl_Impl_Comparison_bn_is_less_(
  Prims_nat len,
  uint32_t clen,
  uint64_t *a,
  uint64_t *b,
  uint32_t i
)
{
  if (i > (uint32_t)0U)
  {
    uint32_t i1 = i - (uint32_t)1U;
    uint64_t t1 = a[i1];
    uint64_t t2 = b[i1];
    if (!(t1 == t2))
      if (t1 < t2)
        return true;
      else
        return false;
    else
      return Hacl_Impl_Comparison_bn_is_less_(len, clen, a, b, i1);
  }
  else
    return false;
}

static bool
Hacl_Impl_Comparison_bn_is_less(Prims_nat len, uint32_t clen, uint64_t *a, uint64_t *b)
{
  return Hacl_Impl_Comparison_bn_is_less_(len, clen, a, b, clen);
}

static bool
Hacl_Impl_Comparison_bn_is_less_ds_(
  Prims_nat a0Len,
  Prims_nat a1Len,
  uint32_t aa0Len,
  uint64_t *a0,
  uint32_t aa1Len,
  uint64_t *a1,
  uint32_t i
)
{
  if (i > (uint32_t)0U)
  {
    uint32_t i1 = i - (uint32_t)1U;
    uint64_t t1 = a0[i1];
    uint64_t t2;
    if (i1 < aa1Len)
      t2 = a1[i1];
    else
      t2 = (uint64_t)0U;
    if (!(t1 == t2))
      if (t1 < t2)
        return true;
      else
        return false;
    else
      return Hacl_Impl_Comparison_bn_is_less_ds_(a0Len, a1Len, aa0Len, a0, aa1Len, a1, i1);
  }
  else
    return false;
}

static bool
Hacl_Impl_Comparison_bn_is_less_ds(
  Prims_nat a0Len,
  Prims_nat a1len,
  uint32_t aa0Len,
  uint64_t *a0,
  uint32_t aa1Len,
  uint64_t *a1
)
{
  return Hacl_Impl_Comparison_bn_is_less_ds_(a0Len, a1len, aa0Len, a0, aa1Len, a1, aa0Len);
}


static void
Hacl_Impl_Multiplication_bn_mult_by_limb_addj(
  Prims_nat aLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t l,
  uint32_t i,
  uint32_t j,
  uint32_t resLen,
  uint64_t carry,
  uint64_t *res
)
{
  uint32_t ij = i + j;
  if (i < aaLen)
  {
    uint64_t res_ij = res[ij];
    uint64_t uu____258 = a[i];
    K___uint64_t_uint64_t
    uu____253 =
      {
        .fst = FStar_UInt128_uint128_to_uint64(FStar_UInt128_shift_right(FStar_UInt128_add(FStar_UInt128_add(FStar_UInt128_mul_wide(uu____258,
                  l),
                FStar_UInt128_uint64_to_uint128(carry)),
              FStar_UInt128_uint64_to_uint128(res_ij)),
            (uint32_t)64U)),
        .snd = FStar_UInt128_uint128_to_uint64(FStar_UInt128_add(FStar_UInt128_add(FStar_UInt128_mul_wide(uu____258,
                l),
              FStar_UInt128_uint64_to_uint128(carry)),
            FStar_UInt128_uint64_to_uint128(res_ij)))
      };
    K___uint64_t_uint64_t scrut = uu____253;
    uint64_t carry_ = scrut.fst;
    uint64_t res_ij1 = scrut.snd;
    res[ij] = res_ij1;
    Hacl_Impl_Multiplication_bn_mult_by_limb_addj(aLen,
      aaLen,
      a,
      l,
      i + (uint32_t)1U,
      j,
      resLen,
      carry_,
      res);
  }
  else
    res[ij] = carry;
}

static void
Hacl_Impl_Multiplication_bn_mult_(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t bbLen,
  uint64_t *b,
  uint32_t j,
  uint32_t resLen,
  uint64_t *res
)
{
  if (j < bbLen)
  {
    uint64_t uu____705 = b[j];
    Hacl_Impl_Multiplication_bn_mult_by_limb_addj(aLen,
      aaLen,
      a,
      uu____705,
      (uint32_t)0U,
      j,
      resLen,
      (uint64_t)0U,
      res);
    Hacl_Impl_Multiplication_bn_mult_(aLen,
      bLen,
      aaLen,
      a,
      bbLen,
      b,
      j + (uint32_t)1U,
      resLen,
      res);
  }
}

void
Hacl_Impl_Multiplication_bn_mul(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t bbLen,
  uint64_t *b,
  uint64_t *res
)
{
  Hacl_Impl_Multiplication_bn_mult_(aLen,
    bLen,
    aaLen,
    a,
    bbLen,
    b,
    (uint32_t)0U,
    aaLen + bbLen,
    res);
}

static void
Hacl_Impl_Multiplication_abs(
  Prims_nat aLen,
  Prims_nat bLen,
  uint32_t aaLen,
  uint64_t *a,
  uint32_t bbLen,
  uint64_t *b,
  uint64_t *res
)
{
  bool uu____1531 = Hacl_Impl_Comparison_bn_is_less_ds(aLen, aLen, aaLen, a, bbLen, b);
  if (uu____1531)
    Hacl_Impl_Addition_bn_sub(aLen, aLen, bbLen, b, aaLen, a, res);
  else
    Hacl_Impl_Addition_bn_sub(aLen, aLen, aaLen, a, bbLen, b, res);
}

static void
Hacl_Impl_Multiplication_add_sign(
  Prims_nat a0Len,
  Prims_nat a1Len,
  Prims_nat resLen,
  uint32_t aa0Len,
  uint32_t aa1Len,
  uint32_t rresLen,
  uint64_t *c0,
  uint64_t *c1,
  uint64_t *c2,
  uint64_t *a0,
  uint64_t *a1,
  uint64_t *a2,
  uint64_t *b0,
  uint64_t *b1,
  uint64_t *b2,
  uint64_t *res
)
{
  uint32_t c0Len = aa0Len + aa0Len;
  uint32_t c1Len = aa1Len + aa1Len;
  bool uu____2539 = Hacl_Impl_Comparison_bn_is_less_ds(a0Len, a1Len, aa0Len, a0, aa1Len, a1);
  Hacl_Impl_Multiplication_sign sa2;
  if (uu____2539)
    sa2 = Hacl_Impl_Multiplication_Negative;
  else
    sa2 = Hacl_Impl_Multiplication_Positive;
  bool uu____2624 = Hacl_Impl_Comparison_bn_is_less_ds(a0Len, a1Len, aa0Len, b0, aa1Len, b1);
  Hacl_Impl_Multiplication_sign sb2;
  if (uu____2624)
    sb2 = Hacl_Impl_Multiplication_Negative;
  else
    sb2 = Hacl_Impl_Multiplication_Positive;
  Hacl_Impl_Addition_bn_add_carry(a0Len + a0Len,
    a1Len + a1Len,
    c0Len,
    c0,
    c1Len,
    c1,
    res);
  if
  (sa2
  == Hacl_Impl_Multiplication_Positive
  && sb2 == Hacl_Impl_Multiplication_Positive
  || sa2 == Hacl_Impl_Multiplication_Negative && sb2 == Hacl_Impl_Multiplication_Negative)
    Hacl_Impl_Addition_bn_sub(rresLen,
      a0Len+ a0Len,
      rresLen,
      res,
      c0Len,
      c2,
      res);
  else
    Hacl_Impl_Addition_bn_add(rresLen,
      a0Len + a0Len,
      rresLen,
      res,
      c0Len,
      c2,
      res);
}

void
Hacl_Impl_Multiplication_karatsuba_(
  uint32_t k,
  Prims_nat aLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t *b,
  uint64_t *tmp,
  uint64_t *res
)
{
  uint32_t tmpLen = (uint32_t)4U * pow2_i;
  uint32_t aaLen2 = aaLen + aaLen;
  uint32_t pow2_i0 = pow2_i / (uint32_t)2U;
  uint32_t pow2_i1 = pow2_i0 - iLen;
  Hacl_Impl_Lib_fill(tmpLen,
    tmpLen,
    tmp,
    (uint64_t)0U);
  Hacl_Impl_Lib_fill(aLen + aLen, aaLen2, res, (uint64_t)0U);
  if (aaLen < k)
    Hacl_Impl_Multiplication_bn_mul(aLen, aLen, aaLen, a, aaLen, b, res);
  else
  {
    uint64_t *a0 = a;
    uint64_t *a1 = a + pow2_i0;
    uint64_t *b0 = b;
    uint64_t *b1 = b + pow2_i0;
    uint64_t *tmp0 = tmp;
    uint64_t *c0 = res;
    Hacl_Impl_Multiplication_karatsuba_(k, pow2_i0,
      pow2_i0,
      (uint32_t)0U,
      pow2_i0,
      a0,
      b0,
      tmp0,
      c0);
    if (pow2_i0 / (uint32_t)2U <= iLen)
      (void)(iLen - pow2_i0 / (uint32_t)2U);
    uint64_t *tmp01 = tmp;
    uint64_t *c1 = res + (uint32_t)2U * pow2_i0;
    Hacl_Impl_Multiplication_karatsuba_(k, pow2_i1,
      pow2_i0,
      iLen,
      pow2_i1,
      a1,
      b1,
      tmp01,
      c1);
    uint64_t *a2 = tmp;
    uint64_t *b2 = tmp + pow2_i0;
    Hacl_Impl_Multiplication_abs(pow2_i0,
      pow2_i1,
      pow2_i0,
      a0,
      pow2_i1,
      a1,
      a2);
    Hacl_Impl_Multiplication_abs(pow2_i0,
      pow2_i1,
      pow2_i0,
      b0,
      pow2_i1,
      b1,
      b2);
    uint64_t *c2 = tmp + (uint32_t)2U * pow2_i0;
    uint64_t *tmp02 = tmp + (uint32_t)4U * pow2_i0;
    Hacl_Impl_Multiplication_karatsuba_(k, pow2_i0,
      pow2_i0,
      (uint32_t)0U,
      pow2_i0,
      a2,
      b2,
      tmp02,
      c2);
    uint32_t tmp1Len = pow2_i + (uint32_t)1U;
    uint64_t *tmp1 = tmp + (uint32_t)4U * pow2_i0;
    Hacl_Impl_Multiplication_add_sign(pow2_i0,
      pow2_i1,
      tmp1Len,
      pow2_i0,
      pow2_i1,
      tmp1Len,
      c0,
      c1,
      c2,
      a0,
      a1,
      a2,
      b0,
      b1,
      b2,
      tmp1);
    uint32_t res1Len = pow2_i0 + pow2_i1 + pow2_i1;
    uint64_t *res1 = res + pow2_i0;
    Hacl_Impl_Addition_bn_add(res1Len,
      tmp1Len,
      res1Len,
      res1,
      tmp1Len,
      tmp1,
      res1);
  }
}

void
Hacl_Impl_Multiplication_karatsuba(
  uint32_t k,
  Prims_nat aLen,
  uint32_t pow2_i,
  uint32_t iLen,
  uint32_t aaLen,
  uint64_t *a,
  uint64_t *b,
  uint64_t *st_mult,
  uint64_t *res
)
{
  uint32_t aaLen2 = aaLen + aaLen;
  //Hacl_Impl_Lib_fill(Prims_op_Addition(aLen, aLen), aaLen2, res, (uint64_t)0U);
  //if (aaLen < (uint32_t)500000U)
    //Hacl_Impl_Multiplication_bn_mul(aLen, aLen, aaLen, a, aaLen, b, res);
  //else
   Hacl_Impl_Multiplication_karatsuba_(k, aLen, pow2_i, iLen, aaLen, a, b, st_mult, res);
}
