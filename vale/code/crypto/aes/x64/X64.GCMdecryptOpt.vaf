include "../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../arch/x64/X64.Vale.InsMem.vaf"
include "../../../arch/x64/X64.Vale.InsVector.vaf"
include "../../../arch/x64/X64.Vale.InsStack.vaf"
include "../../../lib/util/x64/X64.Stack.vaf"
include "../../../thirdPartyPorts/OpenSSL/aes/X64.AESGCM.vaf"
include "X64.AES.vaf"
include "X64.GF128_Mul.vaf"
include "X64.GCTR.vaf"
include "X64.GHash.vaf"
include "X64.GCMencryptOpt.vaf"
include{:fstar}{:open} "Prop_s"
include{:fstar}{:open} "open Opaque_s"
include{:/*TODO*/fstar}{:open} "FStar.Seq.Base"
include{:fstar}{:open} "Words_s"
include{:fstar}{:open} "Words.Seq_s"
include{:fstar}{:open} "Types_s"
include{:fstar}{:open} "Arch.Types"
include{:fstar}{:open} "AES_s"
include{:fstar}{:open} "GCTR_s"
include{:fstar}{:open} "GCTR"
include{:fstar}{:open} "GCM"
include{:fstar}{:open} "GHash_s"
include{:fstar}{:open} "GHash"
include{:fstar}{:open} "GCM_s"
include{:fstar}{:open} "GF128_s"
include{:fstar}{:open} "GF128"
include{:fstar}{:open} "Util.Meta"
include{:fstar}{:open} "X64.Poly1305.Math"
include{:fstar}{:open} "GCM_helpers"
include{:fstar}{:open} "Workarounds"
include{:fstar}{:open} "X64.Machine_s"
include{:fstar}{:open} "X64.Memory"
include{:fstar}{:open} "X64.Vale.State"
include{:fstar}{:open} "X64.Vale.Decls"
include{:fstar}{:open} "X64.Vale.QuickCode"
include{:fstar}{:open} "X64.Vale.QuickCodes"
include{:fstar}{:open} "X64.CPU_Features_s"
include{:fstar}{:open} "Math.Poly2.Bits_s"

module X64.GCMdecryptOpt

#verbatim{:interface}{:implementation}
module GHash = GHash
module GCTR = GCTR
open Prop_s
open Opaque_s
open FStar.Seq
open Words_s
open Words.Seq_s
open Types_s
open Arch.Types
open AES_s
open GCTR_s
open GCTR
open GCM
open GHash_s
open GHash
open GCM_s
open X64.AES
open GF128_s
open GF128
open X64.Poly1305.Math
open GCM_helpers
open Workarounds
open X64.GHash
open X64.GCTR
open X64.Machine_s
open X64.Memory
open X64.Stack_i
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.InsVector
open X64.Vale.InsStack
open X64.Vale.InsAes
open X64.Vale.QuickCode
open X64.Vale.QuickCodes
open X64.GF128_Mul
open X64.Stack
open X64.CPU_Features_s
open Math.Poly2.Bits_s
open X64.AESGCM
open Util.Meta
open X64.GCMencryptOpt
#endverbatim



procedure {:quick exportOnly}{:public}{:exportSpecs} gcm_blocks_decrypt_stdcall(
    inline win:bool,
    inline alg:algorithm,
    
    ghost auth_b:buffer128,
    ghost auth_bytes:nat64,
    ghost auth_num:nat64,
    ghost keys_b:buffer128,
    ghost iv_b:buffer128,
    ghost hkeys_b:buffer128,
    
    ghost abytes_b:buffer128,
    ghost in128x6_b:buffer128,
    ghost out128x6_b:buffer128,
    ghost len128x6_num:nat64,
    ghost in128_b:buffer128,
    ghost out128_b:buffer128,
    ghost len128_num:nat64,
    ghost inout_b:buffer128,
    ghost cipher_num:nat64,

    ghost scratch_b:buffer128,
    ghost tag_b:buffer128,    

    ghost key:seq(nat32)
    )
    lets
        auth_ptr :=         if win then rcx else rdi;
        auth_num_bytes :=   if win then rdx else rsi;
        auth_len :=         if win then r8 else rdx;
        keys_ptr :=         if win then r9 else rcx;

        iv_ptr :=           if win then load_stack64(rsp + 32 + 8 + 0, stack) else r8;
        xip    :=           if win then load_stack64(rsp + 32 + 8 + 8, stack) else r9;

        abytes_ptr      := if win then load_stack64(rsp + 40 + 16, stack) else load_stack64(rsp + 8 + 0, stack); 
        in128x6_ptr     := if win then load_stack64(rsp + 40 + 24, stack) else load_stack64(rsp + 8 + 8, stack); 
        out128x6_ptr    := if win then load_stack64(rsp + 40 + 32, stack) else load_stack64(rsp + 8 + 16, stack); 
        len128x6        := if win then load_stack64(rsp + 40 + 40, stack) else load_stack64(rsp + 8 + 24, stack); 
        in128_ptr       := if win then load_stack64(rsp + 40 + 48, stack) else load_stack64(rsp + 8 + 32, stack); 
        out128_ptr      := if win then load_stack64(rsp + 40 + 56, stack) else load_stack64(rsp + 8 + 40, stack); 
        len128          := if win then load_stack64(rsp + 40 + 64, stack) else load_stack64(rsp + 8 + 48, stack); 
        inout_ptr       := if win then load_stack64(rsp + 40 + 72, stack) else load_stack64(rsp + 8 + 56, stack);
        cipher_num_bytes := if win then load_stack64(rsp + 40 + 80, stack) else load_stack64(rsp + 8 + 64, stack);
        scratch_ptr     := if win then load_stack64(rsp + 40 + 88, stack) else load_stack64(rsp + 8 + 72, stack);
        tag_ptr         := if win then load_stack64(rsp + 40 + 96, stack) else load_stack64(rsp + 8 + 80, stack);
        
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rdi; rsi; rsp; rbp; r8; r9; r10; r11; r12; r13; r14; r15; 
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        mem; efl; stack;
    requires
        rsp == init_rsp(stack);
        
        // Valid buffers and pointers
        valid_src_stack64s(rsp + (if win then 40 else 8), 13, stack);

        auth_len == auth_num;
        auth_num_bytes == auth_bytes;
        len128x6 == len128x6_num;
        len128 == len128_num;
        cipher_num_bytes == cipher_num;

        validSrcAddrs128(mem,     auth_ptr,     auth_b, auth_len, memTaint, Secret);
        validSrcAddrs128(mem,   abytes_ptr,   abytes_b,        1, memTaint, Secret);
        validDstAddrs128(mem,       iv_ptr,       iv_b,        1, memTaint, Secret);
        validSrcAddrs128(mem,  in128x6_ptr,  in128x6_b, len128x6, memTaint, Secret);
        validDstAddrs128(mem, out128x6_ptr, out128x6_b, len128x6, memTaint, Secret);
        validSrcAddrs128(mem,    in128_ptr,    in128_b,   len128, memTaint, Secret);
        validDstAddrs128(mem,   out128_ptr,   out128_b,   len128, memTaint, Secret);
        validDstAddrs128(mem,    inout_ptr,    inout_b,        1, memTaint, Secret);
        validDstAddrs128(mem,  scratch_ptr,  scratch_b,        8, memTaint, Secret);
        validSrcAddrs128(mem,          xip,    hkeys_b,       10, memTaint, Secret);
        validDstAddrs128(mem,      tag_ptr,      tag_b,        1, memTaint, Secret);        

        buffer_disjoints128(tag_b, list(out128x6_b, out128_b, inout_b, hkeys_b));

        buffer_disjoints128(iv_b, list(keys_b, scratch_b, in128x6_b, out128x6_b, hkeys_b, in128_b, out128_b, inout_b));

        buffer_disjoints128(scratch_b, list(keys_b, in128x6_b, out128x6_b, in128_b, out128_b, inout_b, hkeys_b));

        buffer_disjoints128(out128x6_b, list(keys_b, hkeys_b, in128_b, inout_b));

        buffer_disjoints128(out128_b, list(keys_b, hkeys_b, out128x6_b, inout_b));

        buffer_disjoints128(inout_b, list(keys_b, hkeys_b, out128x6_b, out128_b));

        buffers_disjoint128(in128x6_b, out128x6_b) || in128x6_b == out128x6_b;
        buffers_disjoint128(in128_b, out128_b) || in128_b == out128_b;

            auth_ptr + 0x10*auth_len < pow2_64;
         in128x6_ptr + 0x10*len128x6 < pow2_64;
        out128x6_ptr + 0x10*len128x6 < pow2_64;
           in128_ptr + 0x10*len128   < pow2_64;
          out128_ptr + 0x10*len128   < pow2_64;
           inout_ptr + 0x10          < pow2_64;

        buffer_length(auth_b) == auth_len;
        buffer_length(abytes_b) == 1;
        buffer_length(in128x6_b) == buffer_length(out128x6_b);
        buffer_length(in128_b) == buffer_length(out128_b);
        buffer_length(in128x6_b) == len128x6;
        buffer_length(in128_b) == len128;
        buffer_length(inout_b) == 1;

        0 < cipher_num_bytes;
        8 * cipher_num_bytes < pow2_32;
        4096 * (buffer_length(in128x6_b)) * 16 < pow2_32;
        256 * buffer_length(in128_b) < pow2_32;
        4096 * auth_num_bytes < pow2_32;
        xip + 0x20 < pow2_64;

        buffer_addr(keys_b, mem) + 0x80 < pow2_64;

        // len128x6 is # of 128-bit blocks that come in 6-block chunks
        len128x6 % 6 == 0;
        len128x6 >= 18;
        12 + len128x6 + 6 < pow2_32;

        4096 * (len128x6 + len128 + 1) * 16 < pow2_32;

        len128x6 * (128/8) + len128 * (128/8) <= cipher_num_bytes < len128x6 * (128/8) + len128 * (128/8) + 128/8;
        auth_len * (128/8) <= auth_num_bytes < auth_len * (128/8) + 128/8;

        // GCTR reqs
        aesni_enabled;
        alg = AES_128;
        is_aes_key_LE(alg, key);
        buffer128_as_seq(mem, keys_b) == key_to_round_keys_LE(alg, key);
        validSrcAddrs128(mem, keys_ptr, keys_b, nr(alg) + 1, memTaint, Secret);

        // GCM reqs
        pclmulqdq_enabled;
        buffer128_read(hkeys_b, 2, mem) == reverse_bytes_quad32(aes_encrypt_LE(alg, key, Mkfour(0,0,0,0)));
        hkeys_reqs(hkeys_b, reverse_bytes_quad32(buffer128_read(hkeys_b, 2, mem)), mem);

    ensures
        modifies_mem(loc_union(loc_buffer(iv_b), 
                     loc_union(loc_buffer(scratch_b), 
                     loc_union(loc_buffer(out128x6_b), 
                     loc_union(loc_buffer(out128_b), 
                               loc_buffer(inout_b))))), old(mem), mem);

        // Semantics
        8 * old(cipher_num_bytes) < pow2_32;
        8 * old(auth_num_bytes) < pow2_32;

        let iv_LE := old(buffer128_read(iv_b, 0, mem));
        let iv_BE := reverse_bytes_quad32(iv_LE);

        let auth_raw_quads := old(append(s128(mem, auth_b), s128(mem, abytes_b)));
        let auth_bytes := slice_work_around(le_seq_quad32_to_bytes(auth_raw_quads), old(auth_num_bytes));
        let cipher_raw_quads := old(append(append(s128(mem, in128x6_b), s128(mem, in128_b)), s128(mem, inout_b)));
        let cipher_bytes := slice_work_around(le_seq_quad32_to_bytes(cipher_raw_quads), old(cipher_num_bytes));
        let plain_raw_quads := append(append(s128(mem, out128x6_b), s128(mem, out128_b)), s128(mem, inout_b));
        let plain_bytes := slice_work_around(le_seq_quad32_to_bytes(plain_raw_quads), old(cipher_num_bytes));
        let expected_tag := old(le_quad32_to_bytes(buffer128_read(tag_b, 0, mem)));
        
        4096 * length(auth_bytes)  < pow2_32 /\
        4096 * length(plain_bytes) < pow2_32 /\
        is_aes_key(alg, seq_nat32_to_seq_nat8_LE(key)) /\
        plain_bytes == 
            gcm_decrypt_LE(alg, seq_nat32_to_seq_nat8_LE(key), be_quad32_to_bytes(iv_BE), 
                           cipher_bytes, auth_bytes, expected_tag)._1 /\
        (rax = 0) == 
            gcm_decrypt_LE(alg, seq_nat32_to_seq_nat8_LE(key), be_quad32_to_bytes(iv_BE), 
                            cipher_bytes, auth_bytes, expected_tag)._2;

        // Calling convention for caller/callee saved registers
        rsp == old(rsp);

        // Windows:
        win ==> rbx == old(rbx);
        win ==> rbp == old(rbp);
        win ==> rdi == old(rdi);
        win ==> rsi == old(rsi);
        win ==> r12 == old(r12);
        win ==> r13 == old(r13);
        win ==> r14 == old(r14);
        win ==> r15 == old(r15);

        win ==> xmm6  == old(xmm6);
        win ==> xmm7  == old(xmm7);
        win ==> xmm8  == old(xmm8);
        win ==> xmm9  == old(xmm9);
        win ==> xmm10 == old(xmm10);
        win ==> xmm11 == old(xmm11);
        win ==> xmm12 == old(xmm12);
        win ==> xmm13 == old(xmm13);
        win ==> xmm14 == old(xmm14);
        win ==> xmm15 == old(xmm15);

        // Linux:
        !win ==> rbx == old(rbx);
        !win ==> rbp == old(rbp);
        !win ==> r12 == old(r12);
        !win ==> r13 == old(r13);
        !win ==> r14 == old(r14);
        !win ==> r15 == old(r15);
{

        /////////// TODO ///////////////
        assume false;

}
