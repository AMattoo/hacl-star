include "../../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../../arch/x64/X64.Vale.InsMem.vaf"
include "../../../../arch/x64/X64.Vale.InsVector.vaf"
include "../../../../thirdPartyPorts/Intel/aes/x64/X64.AESCTR.vaf"
include "../../../../lib/util/x64/X64.Stack.vaf"
include "../X64.AES.vaf"
include "../X64.GF128_Mul.vaf"
include "../X64.GCTR.vaf"
include "../X64.GHash.vaf"
include "../X64.GCMencrypt.vaf"
include{:fstar}{:open} "open Opaque_s"
include{:/*TODO*/fstar}{:open} "FStar.Seq.Base"
include{:fstar}{:open} "Words_s"
include{:fstar}{:open} "Words.Seq_s"
include{:fstar}{:open} "Types_s"
include{:fstar}{:open} "Arch.Types"
include{:fstar}{:open} "AES_s"
include{:fstar}{:open} "GCTR_s"
include{:fstar}{:open} "GCTR"
include{:fstar}{:open} "GCM"
include{:fstar}{:open} "GHash_s"
include{:fstar}{:open} "GHash"
include{:fstar}{:open} "GCM_s"
include{:fstar}{:open} "GF128_s"
include{:fstar}{:open} "GF128"
include{:fstar}{:open} "X64.Poly1305.Math"
include{:fstar}{:open} "GCM_helpers"
include{:fstar}{:open} "X64.Machine_s"
include{:fstar}{:open} "X64.Memory"
include{:fstar}{:open} "X64.Vale.State"
include{:fstar}{:open} "X64.Vale.Decls"
include{:fstar}{:open} "X64.Vale.QuickCode"
include{:fstar}{:open} "X64.Vale.QuickCodes"
include{:fstar}{:open} "X64.CPU_Features_s"

module X64.GCMencryptstdcall

#verbatim{:interface}{:implementation}
module GHash = GHash
module GCTR = GCTR
open Opaque_s
open FStar.Seq
open Words_s
open Words.Seq_s
open Types_s
open Arch.Types
open AES_s
open GCTR_s
open GCTR
open GCM
open GHash_s
open GHash
open GCM_s
open X64.AES
open GF128_s
open GF128
open X64.Poly1305.Math
open GCM_helpers
open X64.GHash
open X64.GCTR
open X64.Machine_s
open X64.Memory
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.InsVector
open X64.Vale.InsAes
open X64.Vale.QuickCode
open X64.Vale.QuickCodes
open X64.GF128_Mul
open X64.AESCTR
open X64.Stack
open X64.CPU_Features_s
open X64.GCMencrypt
#endverbatim

#reset-options "--z3rlimit 30"


procedure {:quick}{:exportSpecs}{:public} gcm_make_length_stdcall(
    inline win:bool,
    ghost stack_b:buffer64,
    ghost plain_num_bytes:nat64,
    ghost auth_num_bytes:nat64,
    ghost b:buffer128)
    requires
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, b);
        buffer_writeable(b);
        valid_taint_buf64(stack_b, mem, memTaint, Public);
        valid_taint_buf128(b, mem, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, 0, memTaint);
        win ==> rcx == plain_num_bytes;
        win ==> rdx == auth_num_bytes;
        win ==> r8 == buffer_addr(b, mem);
        !win ==> rdi == plain_num_bytes;
        !win ==> rsi == auth_num_bytes;
        !win ==> rdx == buffer_addr(b, mem);

        buffer_length(b) == 1;
        plain_num_bytes * 8 < pow2_32;
        auth_num_bytes * 8 < pow2_32;
    ensures
        modifies_mem(loc_union(loc_buffer(stack_b), loc_buffer(b)), old(mem), mem);
        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        buffer128_read(b, 0, mem) == reverse_bytes_quad32(Mkfour(#nat32(8 * plain_num_bytes), 0, #nat32(8 * auth_num_bytes), 0));
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
    inline if (win) {
        InitPshufbMask(xmm0, rax);

        // Prepare length fields
        ZeroXmm(xmm2);
        Mov64(rax, rcx);
        IMul64(rax, 8);
        Pinsrd(xmm2, rax, 0);
        Mov64(rax, rdx);
        IMul64(rax, 8);
        Pinsrd(xmm2, rax, 2);
        // assert xmm2 == Mkfour(#nat32(8 * plain_num_bytes), 0, #nat32(8 * auth_num_bytes), 0);     // Passes when ghost vars above are removed

        Pshufb(xmm2, xmm0);

        Store128_buffer(r8, xmm2, 0, Secret, b, 0);
    } else {
        // Save r13
        Mov64(rcx, r13);

        // Move plain and auth_num_bytes in the right registers
        Mov64(r13, rdi);
        Mov64(r11, rsi);

        InitPshufbMask(xmm8, rax);

        // Prepare length fields
        ZeroXmm(xmm2);
        Mov64(rax, r13);
        IMul64(rax, 8);
        Pinsrd(xmm2, rax, 0);
        Mov64(rax, r11);
        IMul64(rax, 8);
        Pinsrd(xmm2, rax, 2);
        // assert xmm2 == Mkfour(#nat32(8 * plain_num_bytes), 0, #nat32(8 * auth_num_bytes), 0);     // Passes when ghost vars above are removed

        Pshufb(xmm2, xmm8);

        Store128_buffer(rdx, xmm2, 0, Secret, b, 0);
        // Restore r13
        Mov64(r13, rcx);
    }
}