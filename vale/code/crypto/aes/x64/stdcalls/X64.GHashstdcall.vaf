include "../../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../../arch/x64/X64.Vale.InsMem.vaf"
include "../../../../arch/x64/X64.Vale.InsVector.vaf"
include "../../../../arch/x64/X64.Vale.InsAes.vaf"
include "../../../../lib/util/x64/X64.Stack.vaf"
include "../X64.GF128_Mul.vaf"
include "../X64.GHash.vaf"
include{:/*TODO*/fstar}{:open} "FStar.Seq.Base"
include{:fstar}{:open} "Words_s"
include{:fstar}{:open} "Types_s"
include{:fstar}{:open} "Arch.Types"
include{:fstar}{:open} "AES_s"
include{:fstar}{:open} "GHash_s"
include{:fstar}{:open} "GHash"
include{:fstar}{:open} "GF128_s"
include{:fstar}{:open} "GF128"
include{:fstar}{:open} "GCTR_s"
include{:fstar}{:open} "GCM_helpers"
include{:fstar}{:open} "Math.Poly2_s"
include{:fstar}{:open} "X64.Poly1305.Math"
include{:fstar}{:open} "X64.Machine_s"
include{:fstar}{:open} "X64.Memory"
include{:fstar}{:open} "X64.Vale.State"
include{:fstar}{:open} "X64.Vale.Decls"
include{:fstar}{:open} "X64.Vale.QuickCode"
include{:fstar}{:open} "X64.Vale.QuickCodes"
include{:fstar}{:open} "X64.CPU_Features_s"

module X64.GHashstdcall

#verbatim{:interface}{:implementation}
module GHash = GHash // REVIEW: it's strange to have to do this to refer to GHash.*
open Opaque_s
open FStar.Seq
open Words_s
open Types_s
open Arch.Types
open AES_s
open GHash_s
open GHash
open GF128_s
open GF128
open GCTR_s
open GCM_helpers
open Math.Poly2_s
open X64.Poly1305.Math
open X64.GF128_Mul
open X64.Machine_s
open X64.Memory
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.InsVector
open X64.Vale.InsAes
open X64.Vale.QuickCode
open X64.Vale.QuickCodes
open X64.CPU_Features_s
open X64.GHash
open X64.Stack
#endverbatim

#reset-options "--z3rlimit 20"

procedure {:quick}{:exportSpecs}{:public} ghash_incremental_bytes_stdcall(
    inline win:bool,
    ghost stack_b:buffer64,
    ghost h_b:buffer128, 
    ghost hash_b:buffer128, 
    ghost input_b:buffer128, 
    ghost num_bytes:nat64)
    requires
        locs_disjoint(list(loc_buffer(h_b), loc_buffer(hash_b)));
        locs_disjoint(list(loc_buffer(h_b), loc_buffer(input_b)));
        locs_disjoint(list(loc_buffer(hash_b), loc_buffer(input_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(h_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(hash_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(input_b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, h_b);
        buffer_readable(mem, hash_b);
        buffer_readable(mem, input_b);
        valid_taint_buf64(stack_b, mem, memTaint, Public);
        valid_taint_buf128(h_b, mem, memTaint, Secret);
        valid_taint_buf128(hash_b, mem, memTaint, Secret);
        valid_taint_buf128(input_b, mem, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, if win then 28 else 8, memTaint);
        win ==> rcx == buffer_addr(h_b, mem);
        win ==> rdx == buffer_addr(hash_b, mem);
        win ==> r8 == buffer_addr(input_b, mem);
        win ==> r9 == num_bytes;
        !win ==> rdi == buffer_addr(h_b, mem);
        !win ==> rsi == buffer_addr(hash_b, mem);
        !win ==> rdx == buffer_addr(input_b, mem);
        !win ==> rcx == num_bytes;

        buffer_length(input_b) == bytes_to_quad_size(num_bytes);
        pclmulqdq_enabled;
        buffer_length(h_b) > 0;
        buffer_length(hash_b) > 0;
        buffer_addr(input_b, mem) + 16 * bytes_to_quad_size(num_bytes) < pow2_64;
        
    ensures
        modifies_mem(loc_union(loc_buffer(stack_b), loc_buffer(hash_b)), old(mem), mem);
        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        num_bytes == 0 ==> buffer128_read(hash_b, 0, mem) == buffer128_read(hash_b, 0, old(mem));
        let input_bytes := slice_work_around(le_seq_quad32_to_bytes(buffer128_as_seq(mem, input_b)), num_bytes);
        let padded_bytes := pad_to_128_bits(input_bytes);
        let input_quads := le_bytes_to_seq_quad32(padded_bytes);
        let h := buffer128_read(h_b, 0, old(mem));
        let old_io := buffer128_read(hash_b, 0, old(mem));
        let io := buffer128_read(hash_b, 0, mem);
        num_bytes > 0 ==> length(input_quads) > 0 /\
            io == ghash_incremental(h, old_io, input_quads);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
        callee_save_registers(win, stack_b);        

        inline if (win) {

        Mov64(rbx, rdx);
        InitPshufbMask(xmm8, r11);
        Mov64(r11, r9);
        Load128_buffer(xmm1, rdx, 0, Secret, hash_b, 0);
        Load128_buffer(xmm11, rcx, 0, Secret, h_b, 0);
        Mov64(rax, r8);
        Pshufb(xmm11, xmm8);
        ghash_incremental_bytes(input_b);
        Mov64(rdx, rbx);
        Store128_buffer(rdx, xmm1, 0, Secret, hash_b, 0);
        }
        else
        {
           InitPshufbMask(xmm8, r11);
           Mov64(r11, rcx);
           Load128_buffer(xmm1, rsi, 0, Secret, hash_b, 0);
           Load128_buffer(xmm11, rdi, 0, Secret, h_b, 0);
           Mov64(rax, rdx);
           ghost var oldio := xmm1;
           Pshufb(xmm11, xmm8);
           ghash_incremental_bytes(input_b);
           Store128_buffer(rsi, xmm1, 0, Secret, hash_b, 0);
        }


        callee_restore_registers(win, stack_b, old(xmm6), old(xmm7), old(xmm8),
            old(xmm9), old(xmm10), old(xmm11), old(xmm12), old(xmm13), old(xmm14), old(xmm15)); 
}

procedure {:quick}{:exportSpecs}{:public} ghash_extra_stdcall(
    inline win:bool,
    ghost stack_b:buffer64,
    ghost in_b:buffer128,
    ghost hash_b:buffer128,
    ghost h_b:buffer128,
    ghost num_bytes:nat64,
    ghost orig_hash:quad32)
    lets orig_in_ptr := if win then rcx else rdi;
    requires
        locs_disjoint(list(loc_buffer(in_b), loc_buffer(hash_b)));
        locs_disjoint(list(loc_buffer(in_b), loc_buffer(h_b)));
        locs_disjoint(list(loc_buffer(hash_b), loc_buffer(h_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(in_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(hash_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(h_b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, in_b);
        buffer_readable(mem, hash_b);
        buffer_readable(mem, h_b);
        valid_taint_buf64(stack_b, mem, memTaint, Public);
        valid_taint_buf128(in_b, mem, memTaint, Secret);
        valid_taint_buf128(hash_b, mem, memTaint, Secret);
        valid_taint_buf128(h_b, mem, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, if win then 28 else 8, memTaint);
        win ==> rcx == buffer_addr(in_b, mem);
        win ==> rdx == buffer_addr(hash_b, mem);
        win ==> r8 == buffer_addr(h_b, mem);
        win ==> r9 == num_bytes;
        !win ==> rdi == buffer_addr(in_b, mem);
        !win ==> rsi == buffer_addr(hash_b, mem);
        !win ==> rdx == buffer_addr(h_b, mem);
        !win ==> rcx == num_bytes;

        pclmulqdq_enabled;

        buffer_length(in_b) == bytes_to_quad_size(num_bytes);
        buffer_length(h_b) == 1;
        buffer_length(hash_b) == 1;

        buffer_addr(in_b, mem) + 16 * bytes_to_quad_size(num_bytes) < pow2_64;

        4096 * num_bytes  < pow2_32;
        256 * bytes_to_quad_size(num_bytes) < pow2_32;

        let old_hash := buffer128_read(hash_b, 0, mem);
        let input := slice_work_around(buffer128_as_seq(mem, in_b), num_bytes / 16);
        old_hash == ghash_incremental0(buffer128_read(h_b, 0, mem), orig_hash, input);

        let num_blocks := num_bytes / 16;
        num_bytes % 16 != 0;
        0 < num_bytes < 16 * bytes_to_quad_size(num_bytes);
        16 * (bytes_to_quad_size(num_bytes) - 1) < num_bytes;
    ensures
        modifies_mem(loc_union(loc_buffer(stack_b), loc_buffer(hash_b)), old(mem), mem);
        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        let h_val := buffer128_read(h_b, 0, mem);
        let new_hash := buffer128_read(hash_b, 0, mem);

        let input_bytes := slice_work_around(le_seq_quad32_to_bytes(buffer128_as_seq(mem, in_b)), num_bytes);
        let padded_bytes := pad_to_128_bits(input_bytes);
        let input_quads := le_bytes_to_seq_quad32(padded_bytes);
        length(input_quads) > 0 /\ new_hash == ghash_incremental(h_val, orig_hash, input_quads);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
    callee_save_registers(win, stack_b);     

    inline if (win) {
        // num_bytes % 16 goes into rax
        Mov64(rax, r9);
        And64(rax, 15);

        // in_ptr is buffer_addr(in_b) + 16 * (num_bytes / 16)
        // r9 should contain rcx + num_bytes / 16 * 16
        Shr64(r9, 4);
        lemma_poly_bits64();
        IMul64(r9, 16);
        Add64(rcx, r9);
        Mov64(r9, rcx);

        // Init Mask in xmm8 register
        InitPshufbMask(xmm8, r11);

        Load128_buffer(xmm1, rdx, 0, Secret, hash_b, 0);
        Load128_buffer(xmm11, r8, 0, Secret, h_b, 0);
        Pshufb(xmm11, xmm8);
        Mov64(r8, rdx);
        // Call the function
        ghash_incremental_bytes_extra(in_b, orig_in_ptr, orig_hash, num_bytes);

        // Update the hash
        Store128_buffer(r8, xmm1, 0, Secret, hash_b, 0);
    }
    else
    {
        // num_bytes % 16 goes into rax
         Mov64(rax, rcx);
         And64(rax, 15);

         // in_ptr is buffer_addr(in_b) + 16 * (num_bytes / 16)
         // r9 should contain rdi + num_bytes / 16 * 16
         Shr64(rcx, 4);
         lemma_poly_bits64();
         IMul64(rcx, 16);
         Add64(rdi, rcx);
         Mov64(r9, rdi);

         // Init Mask in xmm8 register
         InitPshufbMask(xmm8, r11);

         Load128_buffer(xmm1, rsi, 0, Secret, hash_b, 0);
         Load128_buffer(xmm11, rdx, 0, Secret, h_b, 0);
         Pshufb(xmm11, xmm8);

         // Call the function
         ghash_incremental_bytes_extra(in_b, orig_in_ptr, orig_hash, num_bytes);

         // Update the hash
         Store128_buffer(rsi, xmm1, 0, Secret, hash_b, 0);
    }

    callee_restore_registers(win, stack_b, old(xmm6), old(xmm7), old(xmm8),
        old(xmm9), old(xmm10), old(xmm11), old(xmm12), old(xmm13), old(xmm14), old(xmm15)); 
}

procedure {:quick}{:exportSpecs}{:public} ghash_one_block(
    inline win:bool,
    ghost stack_b:buffer64,
    ghost h_b:buffer128,
    ghost hash_b:buffer128,
    ghost input_b:buffer128,
    ghost offset:nat64)
    requires
        locs_disjoint(list(loc_buffer(h_b), loc_buffer(hash_b)));
        locs_disjoint(list(loc_buffer(h_b), loc_buffer(input_b)));
        locs_disjoint(list(loc_buffer(hash_b), loc_buffer(input_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(h_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(hash_b)));
        locs_disjoint(list(loc_buffer(stack_b), loc_buffer(input_b)));
        buffer_readable(mem, stack_b);
        buffer_readable(mem, h_b);
        buffer_readable(mem, hash_b);
        buffer_readable(mem, input_b);
        valid_taint_buf64(stack_b, mem, memTaint, Public);
        valid_taint_buf128(h_b, mem, memTaint, Secret);
        valid_taint_buf128(hash_b, mem, memTaint, Secret);
        valid_taint_buf128(input_b, mem, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, if win then 28 else 8, memTaint);
        win ==> rcx == buffer_addr(h_b, mem);
        win ==> rdx == buffer_addr(hash_b, mem);
        win ==> r8 == buffer_addr(input_b, mem);
        win ==> r9 == offset;
        !win ==> rdi == buffer_addr(h_b, mem);
        !win ==> rsi == buffer_addr(hash_b, mem);
        !win ==> rdx == buffer_addr(input_b, mem);
        !win ==> rcx == offset;

        pclmulqdq_enabled;
        buffer_length(input_b) >= offset + 1;
        buffer_length(h_b) >= 1;
        buffer_length(hash_b) >= 1;
        buffer_addr(input_b, mem) +  offset * 16 < pow2_64;        
    ensures
        modifies_mem(loc_union(loc_buffer(stack_b), loc_buffer(hash_b)), old(mem), mem);
        win ==>  rbx == old(rbx);
        win ==>  rbp == old(rbp);
        win ==>  rdi == old(rdi);
        win ==>  rsi == old(rsi);
        win ==>  rsp == old(rsp);
        win ==>  r12 == old(r12);
        win ==>  r13 == old(r13);
        win ==>  r14 == old(r14);
        win ==>  r15 == old(r15);
        !win ==>  rbx == old(rbx);
        !win ==>  rbp == old(rbp);
        !win ==>  r12 == old(r12);
        !win ==>  r13 == old(r13);
        !win ==>  r14 == old(r14);
        !win ==>  r15 == old(r15);
        win ==>  xmm6 == old(xmm6);
        win ==>  xmm7 == old(xmm7);
        win ==>  xmm8 == old(xmm8);
        win ==>  xmm9 == old(xmm9);
        win ==>  xmm10 == old(xmm10);
        win ==>  xmm11 == old(xmm11);
        win ==>  xmm12 == old(xmm12);
        win ==>  xmm13 == old(xmm13);
        win ==>  xmm14 == old(xmm14);
        win ==>  xmm15 == old(xmm15);

        let old_hash := buffer128_read(hash_b, 0, old(mem));
        let new_hash := buffer128_read(hash_b, 0, mem);
        let h_q := buffer128_read(h_b, 0, old(mem));
        let input_quad := buffer128_read(input_b, offset, old(mem));
        new_hash == ghash_incremental(h_q, old_hash, create(1, input_quad));
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rsi; rdi; rbp; rsp; r8; r9; r10; r11; r12; r13; r14; r15;
        xmm0; xmm1; xmm2; xmm3; xmm4; xmm5; xmm6; xmm7; xmm8; xmm9; xmm10; xmm11; xmm12; xmm13; xmm14; xmm15;
        efl; mem;
{
    callee_save_registers(win, stack_b);

    inline if (win) {
        // Input into xmm2
        IMul64(r9, 16);
        Add64(r9, r8);
        Load128_buffer(xmm2, r9, 0, Secret, input_b, offset);

        // Save xmm8
        Mov128(xmm0, xmm8);

        // mask into xmm8
        InitPshufbMask(xmm8, r11);

        // old_hash into xmm1
        Load128_buffer(xmm1, rdx, 0, Secret, hash_b, 0);

        // h into xmm11
        Load128_buffer(xmm11, rcx, 0, Secret, h_b, 0);
        Pshufb(xmm11, xmm8);

        // Call the function
        compute_ghash_incremental_register();

        // Store the new hash into hash_b
        Store128_buffer(rdx, xmm1, 0, Secret, hash_b, 0);
    } else {
        // Input into xmm2
        IMul64(rcx, 16);
        Add64(rcx, rdx);
        Load128_buffer(xmm2, rcx, 0, Secret, input_b, offset);

        // old_hash into xmm1
        Load128_buffer(xmm1, rsi, 0, Secret, hash_b, 0);

        // mask into xmm8
        InitPshufbMask(xmm8, r11);

        // h into xmm11
        Load128_buffer(xmm11, rdi, 0, Secret, h_b, 0);

        Pshufb(xmm11, xmm8);

        // Call the function
        compute_ghash_incremental_register();

        // Store the new_hash into hash_b
        Store128_buffer(rsi, xmm1, 0, Secret, hash_b, 0);
    }

    callee_restore_registers(win, stack_b, old(xmm6), old(xmm7), old(xmm8),
        old(xmm9), old(xmm10), old(xmm11), old(xmm12), old(xmm13), old(xmm14), old(xmm15)); 

}
