include "X64.Vale.InsBasic.vaf"
include "X64.Vale.InsVector.vaf"

module X64.Vale.InsSha

#verbatim{:interface}
open Words_s
open Types_s
open Arch.Types
open Spec.SHA2Again
open SHA_helpers
open X64.Machine_s
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.QuickCode
open X64.Vale.InsVector
open FStar.UInt32

open FStar.Seq
open Spec.Loops
#endverbatim

#verbatim
open Types_s
open X64.Machine_s
open X64.Vale
open X64.Vale.State
open X64.Vale.StateLemmas
open X64.Vale.Decls
open X64.CryptoInstructions_s
module S = X64.Bytes_Semantics_s
module TS = X64.Taint_Semantics_s
module P = X64.Print_s

friend X64.Vale.StateLemmas
friend X64.Vale.Decls
friend X64.Memory
//#reset-options "--initial_fuel 4 --max_fuel 4 --max_ifuel 2 --z3rlimit 20"
//#reset-options "--initial_fuel 2 --max_fuel 2 --max_ifuel 2 --initial_ifuel 2 --z3rlimit 60"
#endverbatim

procedure{:instruction Ins(TS.TaintedIns(tuple(S.SHA256_rnds2(dst, src), list(), list()), Public))}{:quick exportOnly} 
          SHA256_rnds2(inout dst:xmm, src:xmm, ghost t:counter, ghost block:block_w(SHA2_256), ghost hash_orig:hash_w(SHA2_256))
  reads xmm0;
  requires 
    t + 1 < size_k_w(SHA2_256);
    xmm0.lo0 == add_wrap(vv(index(k0(SHA2_256),t)),   vv(ws_opaque(SHA2_256, block, t)));
    xmm0.lo1 == add_wrap(vv(index(k0(SHA2_256),t+1)), vv(ws_opaque(SHA2_256, block, t + 1)));
    make_hash(src, dst)      == repeat_range_spec(0, t,   shuffle_core_opaque(SHA2_256, block), hash_orig);
  ensures
    make_hash(dst, old(src)) == repeat_range_spec(0, t+2, shuffle_core_opaque(SHA2_256, block), hash_orig);
{
    lemma_sha256_rnds2(old(src), old(dst), old(xmm0), t, block, hash_orig);
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.SHA256_msg1(dst, src), list(), list()), Public))}{:quick exportOnly} 
          SHA256_msg1(inout dst:xmm, src:xmm, ghost t:counter, ghost block:block_w(SHA2_256))
  requires 
    16 <= t < size_k_w(SHA2_256);
    dst == ws_quad32(t-16, block);
    src.lo0 == vv(ws_opaque(SHA2_256, block, t-12));
  ensures
    dst == ws_partial(t, block);
{
    lemma_sha256_msg1(old(dst), old(src), t, block);
}


procedure{:instruction Ins(TS.TaintedIns(tuple(S.SHA256_msg2(dst, src), list(), list()), Public))}{:quick exportOnly} 
          SHA256_msg2(inout dst:xmm, src:xmm, ghost t:counter, ghost block:block_w(SHA2_256))
  requires 
    16 <= t < size_k_w(SHA2_256) - 3;
    let step1 := ws_partial(t, block) in
    let t_minus_7 := ws_quad32(t-7, block) in
    dst == add_wrap_quad32(step1,t_minus_7);
    src.hi2 == vv(ws_opaque(SHA2_256, block, t-2));
    src.hi3 == vv(ws_opaque(SHA2_256, block, t-1));
  ensures
    dst == ws_quad32(t, block);
{
    lemma_sha256_msg2(old(dst), old(src), t, block);
}
