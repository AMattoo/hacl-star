include "X64.Vale.InsBasic.vaf"
include "X64.Vale.InsVector.vaf"

module X64.Vale.InsSha

#verbatim{:interface}
open Words_s
open Types_s
open Arch.Types
open Spec.SHA2Again
open SHA_helpers
open X64.Machine_s
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.QuickCode
open X64.Vale.InsVector
open FStar.UInt32

open FStar.Seq
#endverbatim

#verbatim
open Types_s
open X64.Machine_s
open X64.Vale
open X64.Vale.State
open X64.Vale.StateLemmas
open X64.Vale.Decls
open X64.CryptoInstructions_s
module S = X64.Bytes_Semantics_s
module TS = X64.Taint_Semantics_s
module P = X64.Print_s
//#reset-options "--initial_fuel 4 --max_fuel 4 --max_ifuel 2 --z3rlimit 20"
//#reset-options "--initial_fuel 2 --max_fuel 2 --max_ifuel 2 --initial_ifuel 2 --z3rlimit 60"
#endverbatim

procedure{:instruction Ins(TS.TaintedIns(tuple(S.SHA256_rnds2(dst, src), list(), list()), Public))}{:quick exportOnly} 
          SHA256_rnds2(inout dst:xmm, src:xmm, ghost t:counter, ghost block:block_w(SHA2_256))
  reads xmm0;
  requires 
    t + 1 < size_k_w(SHA2_256);
    xmm0.lo0 == v(add_mod(index(k0(SHA2_256),t),   ws_opaque(SHA2_256, block, t)));
    xmm0.lo1 == v(add_mod(index(k0(SHA2_256),t+1), ws_opaque(SHA2_256, block, t + 1)));
  ensures
    let hash0 := old(make_hash(src, dst)) in
    let hash1 := shuffle_core_opaque(SHA2_256, block, hash0, t) in
    let hash2 := shuffle_core_opaque(SHA2_256, block, hash1, t + 1) in
    hash2 == make_hash(dst, old(src));
{
    lemma_sha256_rnds2(old(src), old(dst), old(xmm0), t, block);
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.SHA256_msg1(dst, src), list(), list()), Public))}{:quick exportOnly} 
          SHA256_msg1(inout dst:xmm, src:xmm, ghost t:counter, ghost block:block_w(SHA2_256))
  requires 
    16 <= t < size_k_w(SHA2_256);
    dst == ws_quad32(t-16, block);
    src.lo0 == v(ws_opaque(SHA2_256, block, t-12));
  ensures
    dst == ws_partial(t, block);
{
    lemma_sha256_msg1(old(dst), old(src), t, block);
}


procedure{:instruction Ins(TS.TaintedIns(tuple(S.SHA256_msg2(dst, src), list(), list()), Public))}{:quick exportOnly} 
          SHA256_msg2(inout dst:xmm, src:xmm, ghost t:counter, ghost block:block_w(SHA2_256))
  requires 
    16 <= t < size_k_w(SHA2_256);
    let w := ws_partial(t) in
    let mid := ws_quad32(t-7, block) in
    dst == add_wrap_quad32(mid,w);
  ensures
    dst == ws_quad32(t, block);
{
    lemma_sha256_msg2(old(dst), old(src), t, block);
}
