include "../../../../arch/x64/X64.Vale.InsBasic.vaf"
include "../../../../arch/x64/X64.Vale.InsMem.vaf"
include{:fstar}{:open} "Fast_defs"
include{:fstar}{:open} "Fast_lemmas_external"
include{:fstar}{:open} "FastHybrid_helpers"
include{:fstar}{:open} "X64.CPU_Features_s"

module X64.FastHybrid

#reset-options "--z3rlimit 30"

#verbatim{:interface}
open Types_s
open Arch.Types
open X64.Machine_s
open X64.Memory
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.QuickCode
open X64.Vale.QuickCodes
open Fast_defs
open X64.CPU_Features_s

#endverbatim

#verbatim{:implementation}
open Types_s
open Arch.Types
open X64.Machine_s
open X64.Memory
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.InsBasic
open X64.Vale.InsMem
open X64.Vale.QuickCode
open X64.Vale.QuickCodes
open FStar.Tactics
open Fast_defs
open Fast_lemmas_external
open FastHybrid_helpers
open X64.CPU_Features_s
#endverbatim

type tactic:Type(0) extern;
const int_canon:tactic extern;
ghost procedure assert_by_tactic(ghost p:prop, ghost t:tactic) extern;

#reset-options "--z3rlimit 300"

procedure{:quick} fast_mul1(
    ghost inA_b:buffer64)
    lets
        inA_ptr @= rsi;
        b @= rdx;

        a0 := buffer64_read(inA_b, 0, mem);
        a1 := buffer64_read(inA_b, 1, mem);
        a2 := buffer64_read(inA_b, 2, mem);
        a3 := buffer64_read(inA_b, 3, mem);

        a := pow2_four(a0, a1, a2, a3);
    reads
        inA_ptr; b; mem; memTaint;

    modifies
        rax; r8; r9; r10; r11; r12; r13; r14;
        efl;

    requires
        adx_enabled && bmi2_enabled;

        validSrcAddrs64(mem, inA_ptr, inA_b, 4, memTaint, Secret);

    ensures
        let d := pow2_five(r8, r10, r12, r14, rax);
        d == old(a * b);

        rax < pow2_64 - 1;
{
    xor_lemmas();
    
    lemma_load_mem64(inA_b, 0, mem);    
    Mulx64( r9,  r8, Mem(inA_ptr,  0, inA_b, 0, Secret));  /* A[0]*B */ lemma_prod_bounds(r9, r8, b, a0); 
    lemma_load_mem64(inA_b, 1, mem);    
    Mulx64(r11, r10, Mem(inA_ptr,  8, inA_b, 1, Secret));  /* A[1]*B */ lemma_prod_bounds(r11, r10, b, a1); 
    Add64Wrap(r10, r9);
    Mov64(r9, 0);
    lemma_load_mem64(inA_b, 2, mem);    
    Mulx64(r13, r12, Mem(inA_ptr, 16, inA_b, 2, Secret));  /* A[2]*B */ lemma_prod_bounds(r13, r12, b, a2); 
    Adcx64Wrap(r12, r11);
    lemma_load_mem64(inA_b, 3, mem);    
    Mulx64(rax, r14, Mem(inA_ptr, 24, inA_b, 3, Secret));  /* A[3]*B */ lemma_prod_bounds(rax, r14, b, a3); 
    Adcx64Wrap(r14, r13);
    Adcx64Wrap(rax, r9);

    ghost var carry_bit := bool_bit(cf(efl));
    assert carry_bit == 0;      // PASSES
    assert_by_tactic(a * b == pow2_four(b*a0, b*a1, b*a2, b*a3), int_canon);   // PASSES
}

#reset-options "--z3rlimit 300"
procedure{:quick} fast_add_after_mul1(
    ghost dst_b:buffer64,
    ghost inB_b:buffer64)
    lets
        dst_ptr @= rdi;
        inB_ptr @= rcx;

        b0 := buffer64_read(inB_b, 0, mem);
        b1 := buffer64_read(inB_b, 1, mem);
        b2 := buffer64_read(inB_b, 2, mem);
        b3 := buffer64_read(inB_b, 3, mem);

        a := pow2_five(r8, r10, r12, r14, rax);
        b := pow2_four(b0, b1, b2, b3);
    reads
        dst_ptr; inB_ptr; r14; memTaint;

    modifies
        rax; r8; r9; r10; r11; r12; r13; r15;
        mem; efl;

    requires
        adx_enabled && bmi2_enabled;
        buffers_disjoint(dst_b, inB_b) || dst_b == inB_b;

        validDstAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inB_ptr, inB_b, 4, memTaint, Secret);

        rax < pow2_64 - 1;

    ensures
        let d0 := buffer64_read(dst_b, 0, mem);
        let d1 := buffer64_read(dst_b, 1, mem);
        let d2 := buffer64_read(dst_b, 2, mem);
        let d3 := buffer64_read(dst_b, 3, mem);
        let d := pow2_five(d0, d1, d2, d3, rax);
        d == old(a + b);

        validSrcAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
        modifies_buffer(dst_b, old(mem), mem);
{
    xor_lemmas();

    Load64_buffer( r9, inB_ptr,  0, Secret, inB_b, 0);     /* B[0] */
    Add64Wrap(r9, r8);
    Store64_buffer(dst_ptr,  r9,  0, Secret, dst_b, 0);  
    Mov64(r9, 0);

    Load64_buffer(r11, inB_ptr,  8, Secret, inB_b, 1);     /* B[1] */
    Adcx64Wrap(r11, r10);
    Store64_buffer(dst_ptr, r11,  8, Secret, dst_b, 1);  

    Load64_buffer(r13, inB_ptr, 16, Secret, inB_b, 2);     /* B[2] */
    Adcx64Wrap(r13, r12);
    Store64_buffer(dst_ptr, r13, 16, Secret, dst_b, 2);  

    Load64_buffer(r15, inB_ptr, 24, Secret, inB_b, 3);     /* B[3] */
    Adcx64Wrap(r15, r14);
    Store64_buffer(dst_ptr, r15, 24, Secret, dst_b, 3);  

    Adcx64Wrap(rax, r9);
}

#reset-options "--z3rlimit 20"
procedure{:quick} fast_mul1_add(
    ghost dst_b:buffer64,
    ghost inA_b:buffer64,
    ghost inB_b:buffer64)
    lets
        dst_ptr @= rdi;
        inA_ptr @= rsi;
        x       @= rdx;
        inB_ptr @= rcx;

        a0 := buffer64_read(inA_b, 0, mem);
        a1 := buffer64_read(inA_b, 1, mem);
        a2 := buffer64_read(inA_b, 2, mem);
        a3 := buffer64_read(inA_b, 3, mem);

        b0 := buffer64_read(inB_b, 0, mem);
        b1 := buffer64_read(inB_b, 1, mem);
        b2 := buffer64_read(inB_b, 2, mem);
        b3 := buffer64_read(inB_b, 3, mem);

        a := pow2_four(a0, a1, a2, a3);
        b := pow2_four(b0, b1, b2, b3);
    reads
        dst_ptr; inA_ptr; x; inB_ptr; memTaint;

    modifies
        rax; r8; r9; r10; r11; r12; r13; r14; r15;
        mem; efl;

    requires
        adx_enabled && bmi2_enabled;
        buffers_disjoint(dst_b, inA_b) || dst_b == inA_b;
        buffers_disjoint(dst_b, inB_b) || dst_b == inB_b;

        validDstAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inA_ptr, inA_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inB_ptr, inB_b, 4, memTaint, Secret);
    ensures
        let d0 := buffer64_read(dst_b, 0, mem);
        let d1 := buffer64_read(dst_b, 1, mem);
        let d2 := buffer64_read(dst_b, 2, mem);
        let d3 := buffer64_read(dst_b, 3, mem);
        let d := pow2_five(d0, d1, d2, d3, rax);
        d == old(a * x + b);

        validSrcAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
        modifies_buffer(dst_b, old(mem), mem);
{
    fast_mul1(inA_b);
    fast_add_after_mul1(dst_b, inB_b);
}


procedure{:quick}{:public} fast_mul1_add_stdcall(
    inline win:bool,
    ghost dst_b:buffer64,
    ghost inA_b:buffer64,
    ghost inB_b:buffer64,
    ghost stack_b:buffer64)
    lets
        dst_ptr @= rdi; inA_ptr @= rsi; x @= rdx; inB_ptr @= rcx; 
        dst_in := (if win then rcx else rdi);
        inA_in := (if win then rdx else rsi);
          x_in := (if win then r8  else rdx);
        inB_in   := (if win then r9  else rcx);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rdi; rsi; r8; r9; r10; r11; r12; r13; r14; r15;
        rsp; efl; mem;
    requires
        adx_enabled && bmi2_enabled;
        buffers_disjoint(dst_b, inA_b) || inA_b == dst_b;
        buffers_disjoint(dst_b, inB_b) || dst_b == inB_b;

        buffers_disjoint(stack_b, dst_b);
        buffers_disjoint(stack_b, inA_b);
        buffers_disjoint(stack_b, inB_b);

        validDstAddrs64(mem, dst_in, dst_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inA_in, inA_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inB_in, inB_b, 4, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, 5, memTaint);
    ensures
        let a0 := old(buffer64_read(inA_b, 0, mem));
        let a1 := old(buffer64_read(inA_b, 1, mem));
        let a2 := old(buffer64_read(inA_b, 2, mem));
        let a3 := old(buffer64_read(inA_b, 3, mem));

        let b0 := old(buffer64_read(inB_b, 0, mem));
        let b1 := old(buffer64_read(inB_b, 1, mem));
        let b2 := old(buffer64_read(inB_b, 2, mem));
        let b3 := old(buffer64_read(inB_b, 3, mem));

        let d0 := buffer64_read(dst_b, 0, mem);
        let d1 := buffer64_read(dst_b, 1, mem);
        let d2 := buffer64_read(dst_b, 2, mem);
        let d3 := buffer64_read(dst_b, 3, mem);

        let a := pow2_four(a0, a1, a2, a3);
        let b := pow2_four(b0, b1, b2, b3);
        let d := pow2_five(d0, d1, d2, d3, rax);
                 
        d == old(a * x_in + b);

        //////////////////////////////////////
        //   Framing
        //////////////////////////////////////

        modifies_buffer_2(dst_b, stack_b, old(mem), mem);
        validSrcAddrs64(mem, dst_in, dst_b, 4, memTaint, Secret);

        rbx == old(rbx);
        win ==> rsi == old(rsi);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);
        r15 == old(r15);

        rsp == old(rsp);
{
    // Store callee-save registers
    Push(r15, stack_b, 4);
    Push(r12, stack_b, 3);
    Push(r13, stack_b, 2);
    Push(r14, stack_b, 1);

    // Line up the rest of the arguments
    inline if (win) {
        Push(rsi, stack_b, 0);
        Mov64(dst_ptr, rcx);
        Mov64(inA_ptr, rdx);
        Mov64(x, r8);
        Mov64(inB_ptr, r9);
    } 

    fast_mul1_add(dst_b, inA_b, inB_b);

    inline if (win) {
        Pop(rsi, stack_b, 0);
    }
    Pop(r14, stack_b, 1);
    Pop(r13, stack_b, 2);
    Pop(r12, stack_b, 3);
    Pop(r15, stack_b, 4);
}

#reset-options "--z3rlimit 10"
procedure {:quick exportOnly} carry_times_38(inout tmp:dst_opr64)
    lets
        carry @= rax;
    modifies carry;
    reads efl;
    requires 
        carry == 0;
        @tmp != TReg(Rax);
    ensures 
        carry == bool_bit(cf(efl)) * 38;
        tmp == 38;
{
    Mov64(tmp, 38);
    Cmovc64(carry, tmp);
}

#reset-options "--z3rlimit 300"
procedure{:quick} carry_pass(inline use_cf:bool)
    lets
        carry @= rax;
        tmp @= rcx;
        a0 @= r8;
        a1 @= r10;
        a2 @= r12;
        a3 @= r14;
    modifies
        carry; rcx; a0; a1; a2; a3;
        efl;

    requires
        adx_enabled && bmi2_enabled;

        !use_cf ==> carry * 38 < pow2_64;

    ensures
//        let sum := old(pow2_four(a0, a1, a2, a3) + bool_bit(cf(efl)) * 38);
//        let carry := bool_bit(sum >= pow2_256);
//        let a0_new := (old(a0) + old(bool_bit(cf(efl))) * 38 + carry*38) % pow2_64;
//        pow2_four(a0, a1, a2, a3) == old(pow2_four(a0_new, a1, a2, a3));
{
    ghost var carry_in:nat64 := if use_cf then (if cf(efl) then 1 else 0) else carry;
    inline if (use_cf) {
        Mov64(carry, 0);
        carry_times_38(tmp);
    } else {
        Mov64(tmp, 38);
        IMul64(carry, tmp);
    }

    Add64Wrap(a0, carry); 
    Adcx64Wrap(a1, 0); 
    Adcx64Wrap(a2, 0);
    Adcx64Wrap(a3, 0);
    assert pow2_five(a0, a1, a2, a3, bool_bit(cf(efl))) == old(pow2_four(a0, a1, a2, a3) + carry_in * 38);
    ghost var sum := old(pow2_four(a0, a1, a2, a3) + carry_in * 38);
    ghost var new_carry := bool_bit(cf(efl));
    assert new_carry == bool_bit(sum >= pow2_256);

    Mov64(carry, 0);
    Cmovc64(carry, tmp);
    Add64Wrap(a0, carry);
    assert a0 == (old(a0) + carry_in * 38 + new_carry*38) % pow2_64;
}

#reset-options "--z3rlimit 300"
procedure{:quick} fast_add(
    ghost inA_b:buffer64,
    ghost inB_b:buffer64)
    lets
        inA_ptr @= rsi;
        inB_ptr @= rcx;
        
        d0 @= r8;
        d1 @= r10;
        d2 @= r12;
        d3 @= r14;

        a0 := buffer64_read(inA_b, 0, mem);
        a1 := buffer64_read(inA_b, 1, mem);
        a2 := buffer64_read(inA_b, 2, mem);
        a3 := buffer64_read(inA_b, 3, mem);

        b0 := buffer64_read(inB_b, 0, mem);
        b1 := buffer64_read(inB_b, 1, mem);
        b2 := buffer64_read(inB_b, 2, mem);
        b3 := buffer64_read(inB_b, 3, mem);

        a := pow2_four(a0, a1, a2, a3);
        b := pow2_four(b0, b1, b2, b3);
    reads
        inA_ptr; inB_ptr; mem; memTaint;

    modifies
        d0; d1; d2; d3;
        efl;

    requires
        adx_enabled && bmi2_enabled;

        validSrcAddrs64(mem, inA_ptr, inA_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inB_ptr, inB_b, 4, memTaint, Secret);

    ensures
        let d := pow2_five(d0, d1, d2, d3, bool_bit(cf(efl)));
        d == old(a + b);
{
    xor_lemmas();
    Load64_buffer(d0, inB_ptr,  0, Secret, inB_b, 0);     /* B[0] */
    lemma_load_mem64(inA_b, 0, mem);    
    Add64Wrap(d0, Mem(inA_ptr,  0, inA_b, 0, Secret));

    Load64_buffer(d1, inB_ptr,  8, Secret, inB_b, 1);     /* B[1] */
    lemma_load_mem64(inA_b, 1, mem);    
    Adcx64Wrap(d1, Mem(inA_ptr,  8, inA_b, 1, Secret));

    Load64_buffer(d2, inB_ptr, 16, Secret, inB_b, 2);     /* B[2] */
    lemma_load_mem64(inA_b, 2, mem);    
    Adcx64Wrap(d2, Mem(inA_ptr, 16, inA_b, 2, Secret));

    Load64_buffer(d3, inB_ptr, 24, Secret, inB_b, 3);     /* B[3] */
    lemma_load_mem64(inA_b, 3, mem);    
    Adcx64Wrap(d3, Mem(inA_ptr, 24, inA_b, 3, Secret));
}

#reset-options "--z3rlimit 30"
procedure{:quick} store4(ghost dst_b:buffer64)
    lets
        dst_ptr @= rdi;
        d0 @= r8;
        d1 @= r10;
        d2 @= r12;
        d3 @= r14;
    reads dst_ptr; d0; d1; d2; d3; memTaint;
    modifies mem;
    requires validDstAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
    ensures 
        modifies_buffer(dst_b, old(mem), mem);
        validSrcAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
{
    Store64_buffer(dst_ptr, d0,  0, Secret, dst_b, 0);  
    Store64_buffer(dst_ptr, d1,  8, Secret, dst_b, 1);  
    Store64_buffer(dst_ptr, d2, 16, Secret, dst_b, 2);  
    Store64_buffer(dst_ptr, d3, 24, Secret, dst_b, 3);  
}


/*
#reset-options "--z3rlimit 20"

procedure{:quick}{:public} fast_add1_stdcall(
    inline win:bool,
    ghost dst_b:buffer64,
    ghost inA_b:buffer64,
    ghost stack_b:buffer64)
    lets
        dst_ptr @= rdi; inA_ptr @= rsi; b @= rdx;
        dst_in := (if win then rcx else rdi);
        inA_in := (if win then rdx else rsi);
        inB_in := (if win then r8  else rdx);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rdi; rsi; r8; r9; r10; r11; r12; r13; r14; r15;
        rsp; efl; mem;
    requires
        adx_enabled && bmi2_enabled;
        buffers_disjoint(dst_b, inA_b) || inA_b == dst_b;

        buffers_disjoint(stack_b, dst_b);
        buffers_disjoint(stack_b, inA_b);

        validDstAddrs64(mem, dst_in, dst_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inA_in, inA_b, 4, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, 1, memTaint);
    ensures
        let a0 := old(buffer64_read(inA_b, 0, mem));
        let a1 := old(buffer64_read(inA_b, 1, mem));
        let a2 := old(buffer64_read(inA_b, 2, mem));
        let a3 := old(buffer64_read(inA_b, 3, mem));

        let d0 := buffer64_read(dst_b, 0, mem);
        let d1 := buffer64_read(dst_b, 1, mem);
        let d2 := buffer64_read(dst_b, 2, mem);
        let d3 := buffer64_read(dst_b, 3, mem);

        let a := pow2_four(a0, a1, a2, a3);
        let d := pow2_five(d0, d1, d2, d3, rax);
                 
        d == a + old(inB_in);

        //////////////////////////////////////
        //   Framing
        //////////////////////////////////////

        modifies_buffer_2(dst_b, stack_b, old(mem), mem);
        validSrcAddrs64(mem, dst_in, dst_b, 4, memTaint, Secret);

        rbx == old(rbx);
        rsi == old(rsi);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);

        rsp == old(rsp);
{
    // Store callee-save registers
    Push(rsi, stack_b, 0);

    // Line up the rest of the arguments
    inline if (win) {
        Mov64(dst_ptr, rcx);
        Mov64(inA_ptr, rdx);
        Mov64(b, r8);
    } 
    Mov64(rcx, rdx);

    fast_add1(dst_b, inA_b);

    Pop(rsi, stack_b, 0);
}


#reset-options "--z3rlimit 300"
procedure{:quick} fast_sub1(
    ghost dst_b:buffer64,
    ghost inA_b:buffer64)
    lets
        dst_ptr @= rdi;
        inA_ptr @= rsi;
        b @= rcx;

        a0 := buffer64_read(inA_b, 0, mem);
        a1 := buffer64_read(inA_b, 1, mem);
        a2 := buffer64_read(inA_b, 2, mem);
        a3 := buffer64_read(inA_b, 3, mem);

        a := pow2_four(a0, a1, a2, a3);
    reads
        dst_ptr; inA_ptr; b; memTaint;

    modifies
        rax; r8; r9; r10; r11; 
        mem; efl;

    requires
        buffers_disjoint(dst_b, inA_b) || dst_b == inA_b;

        validDstAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inA_ptr, inA_b, 4, memTaint, Secret);

    ensures
        let d0 := buffer64_read(dst_b, 0, mem);
        let d1 := buffer64_read(dst_b, 1, mem);
        let d2 := buffer64_read(dst_b, 2, mem);
        let d3 := buffer64_read(dst_b, 3, mem);
        let d := pow2_four(d0, d1, d2, d3);
        d - rax * pow2_256 == old(a - b);
        rax == 0 || rax == 1;

        validSrcAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
        modifies_buffer(dst_b, old(mem), mem);
{
    xor_lemmas();

    Xor64( r8,  r8);
    Xor64( r9,  r9);
    Xor64(r10, r10);
    Xor64(r11, r11);
    Xor64(rax, rax);

    Load64_buffer( r8, inA_ptr,  0, Secret, inA_b, 0);     /* A[0] */
    Sub64Wrap(r8, b);      /* A[0] - B */
    Store64_buffer(dst_ptr,  r8,  0, Secret, dst_b, 0);  

    Load64_buffer( r9, inA_ptr,  8, Secret, inA_b, 1);     /* A[1] */
    Sbb64(r9, r10);          
    Store64_buffer(dst_ptr, r9,  8, Secret, dst_b, 1);  

    Load64_buffer(r10, inA_ptr, 16, Secret, inA_b, 2);     /* A[2] */
    Sbb64(r10, r11);         
    Store64_buffer(dst_ptr, r10, 16, Secret, dst_b, 2);  
    
    Load64_buffer(r11, inA_ptr, 24, Secret, inA_b, 3);     /* A[3] */
    Sbb64(r11, rax);         
    Store64_buffer(dst_ptr, r11, 24, Secret, dst_b, 3);  

    ghost var c := cf(efl);
    Adc64Wrap(rax, rax);   // Extract the carry bit
    assert rax == bool_bit(c);

//    lemma_sub(a, a0, a1, a2, a3,
//              b, b0, b1, b2, b3,
//              r8, r9, r10, r11, bool_bit(c));
}

#reset-options "--z3rlimit 20"
procedure{:quick}{:public} fast_sub1_stdcall(
    inline win:bool,
    ghost dst_b:buffer64,
    ghost inA_b:buffer64,
    ghost stack_b:buffer64)
    lets
        dst_ptr @= rdi; inA_ptr @= rsi; b @= rdx;
        dst_in := (if win then rcx else rdi);
        inA_in := (if win then rdx else rsi);
        inB_in := (if win then r8  else rdx);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rdi; rsi; r8; r9; r10; r11; r12; r13; r14; r15;
        rsp; efl; mem;
    requires
        adx_enabled && bmi2_enabled;
        buffers_disjoint(dst_b, inA_b) || inA_b == dst_b;

        buffers_disjoint(stack_b, dst_b);
        buffers_disjoint(stack_b, inA_b);

        validDstAddrs64(mem, dst_in, dst_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inA_in, inA_b, 4, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, 1, memTaint);
    ensures
        let a0 := old(buffer64_read(inA_b, 0, mem));
        let a1 := old(buffer64_read(inA_b, 1, mem));
        let a2 := old(buffer64_read(inA_b, 2, mem));
        let a3 := old(buffer64_read(inA_b, 3, mem));

        let d0 := buffer64_read(dst_b, 0, mem);
        let d1 := buffer64_read(dst_b, 1, mem);
        let d2 := buffer64_read(dst_b, 2, mem);
        let d3 := buffer64_read(dst_b, 3, mem);

        let a := pow2_four(a0, a1, a2, a3);
        let d := pow2_four(d0, d1, d2, d3);
        d - rax * pow2_256 == old(a - inB_in);
        rax == 0 || rax == 1;

        //////////////////////////////////////
        //   Framing
        //////////////////////////////////////

        modifies_buffer_2(dst_b, stack_b, old(mem), mem);
        validSrcAddrs64(mem, dst_in, dst_b, 4, memTaint, Secret);

        rbx == old(rbx);
        rsi == old(rsi);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);

        rsp == old(rsp);
{
    // Store callee-save registers
    Push(rsi, stack_b, 0);

    // Line up the rest of the arguments
    inline if (win) {
        Mov64(dst_ptr, rcx);
        Mov64(inA_ptr, rdx);
        Mov64(b, r8);
    } 
    Mov64(rcx, rdx);

    fast_sub1(dst_b, inA_b);

    Pop(rsi, stack_b, 0);
}


#reset-options "--z3rlimit 300"
procedure{:quick} fast_add(
    ghost dst_b:buffer64,
    ghost inA_b:buffer64,
    ghost inB_b:buffer64)
    lets
        dst_ptr @= rdi;
        inA_ptr @= rsi;
        inB_ptr @= rcx;

        a0 := buffer64_read(inA_b, 0, mem);
        a1 := buffer64_read(inA_b, 1, mem);
        a2 := buffer64_read(inA_b, 2, mem);
        a3 := buffer64_read(inA_b, 3, mem);

        b0 := buffer64_read(inB_b, 0, mem);
        b1 := buffer64_read(inB_b, 1, mem);
        b2 := buffer64_read(inB_b, 2, mem);
        b3 := buffer64_read(inB_b, 3, mem);

        a := pow2_four(a0, a1, a2, a3);
        b := pow2_four(b0, b1, b2, b3);
    reads
        dst_ptr; inA_ptr; inB_ptr; memTaint;

    modifies
        rax; r8; r9; r10; r11; r12; 
        mem; efl;

    requires
        adx_enabled && bmi2_enabled;
        buffers_disjoint(dst_b, inA_b) || dst_b == inA_b;
        buffers_disjoint(dst_b, inB_b) || dst_b == inB_b;

        validDstAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inA_ptr, inA_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inB_ptr, inB_b, 4, memTaint, Secret);

    ensures
        let d0 := buffer64_read(dst_b, 0, mem);
        let d1 := buffer64_read(dst_b, 1, mem);
        let d2 := buffer64_read(dst_b, 2, mem);
        let d3 := buffer64_read(dst_b, 3, mem);
        let d := pow2_five(d0, d1, d2, d3, rax);
        d == old(a + b);

        validSrcAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
        modifies_buffer(dst_b, old(mem), mem);
{
    xor_lemmas();
    Xor64( r8,  r8);
    Xor64(rax, rax);

    Load64_buffer( r9, inB_ptr,  0, Secret, inB_b, 0);     /* B[0] */
    lemma_load_mem64(inA_b, 0, mem);    
    Add64Wrap(r9, Mem(inA_ptr,  0, inA_b, 0, Secret));
    Store64_buffer(dst_ptr,  r9,  0, Secret, dst_b, 0);  

    Load64_buffer(r10, inB_ptr,  8, Secret, inB_b, 1);     /* B[1] */
    lemma_load_mem64(inA_b, 1, mem);    
    Adcx64Wrap(r10, Mem(inA_ptr,  8, inA_b, 1, Secret));
    Store64_buffer(dst_ptr, r10,  8, Secret, dst_b, 1);  

    Load64_buffer(r11, inB_ptr, 16, Secret, inB_b, 2);     /* B[2] */
    lemma_load_mem64(inA_b, 2, mem);    
    Adcx64Wrap(r11, Mem(inA_ptr, 16, inA_b, 2, Secret));
    Store64_buffer(dst_ptr, r11, 16, Secret, dst_b, 2);  

    Load64_buffer(r12, inB_ptr, 24, Secret, inB_b, 3);     /* B[3] */
    lemma_load_mem64(inA_b, 3, mem);    
    Adcx64Wrap(r12, Mem(inA_ptr, 24, inA_b, 3, Secret));
    Store64_buffer(dst_ptr, r12, 24, Secret, dst_b, 3);  

    Adcx64Wrap(rax, r8);
}

procedure{:quick}{:public} fast_add_stdcall(
    inline win:bool,
    ghost dst_b:buffer64,
    ghost inA_b:buffer64,
    ghost inB_b:buffer64,
    ghost stack_b:buffer64)
    lets
        dst_ptr @= rdi; inA_ptr @= rsi; inB_ptr @= rcx;
        dst_in := (if win then rcx else rdi);
        inA_in := (if win then rdx else rsi);
        inB_in := (if win then r8 else rdx);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rdi; rsi; r8; r9; r10; r11; r12; r13; r14;
        rsp; efl; mem;
    requires
        adx_enabled && bmi2_enabled;
        buffers_disjoint(dst_b, inA_b) || dst_b == inA_b;
        buffers_disjoint(dst_b, inB_b) || dst_b == inB_b;

        buffers_disjoint(stack_b, dst_b);
        buffers_disjoint(stack_b, inA_b);
        buffers_disjoint(stack_b, inB_b);

        validDstAddrs64(mem, dst_in, dst_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inA_in, inA_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inB_in, inB_b, 4, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, 2, memTaint);
    ensures
        let a0 := old(buffer64_read(inA_b, 0, mem));
        let a1 := old(buffer64_read(inA_b, 1, mem));
        let a2 := old(buffer64_read(inA_b, 2, mem));
        let a3 := old(buffer64_read(inA_b, 3, mem));

        let b0 := old(buffer64_read(inB_b, 0, mem));
        let b1 := old(buffer64_read(inB_b, 1, mem));
        let b2 := old(buffer64_read(inB_b, 2, mem));
        let b3 := old(buffer64_read(inB_b, 3, mem));

        let d0 := buffer64_read(dst_b, 0, mem);
        let d1 := buffer64_read(dst_b, 1, mem);
        let d2 := buffer64_read(dst_b, 2, mem);
        let d3 := buffer64_read(dst_b, 3, mem);

        let a := pow2_four(a0, a1, a2, a3);
        let b := pow2_four(b0, b1, b2, b3);
        let d := pow2_five(d0, d1, d2, d3, rax);

        d == a + b;

        //////////////////////////////////////
        //   Framing
        //////////////////////////////////////

        modifies_buffer_2(dst_b, stack_b, old(mem), mem);
        validSrcAddrs64(mem, dst_in, dst_b, 4, memTaint, Secret);

        rsi == old(rsi);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);

        rsp == old(rsp);
{
    // Store callee-save registers
    Push(rsi, stack_b, 1);
    Push(r12, stack_b, 0);

    // Line up the rest of the arguments
    inline if (win) {
        Mov64(dst_ptr, rcx);
        Mov64(inA_ptr, rdx);
        Mov64(inB_ptr, r8);
    } else {
        Mov64(inB_ptr, rdx);
    }

    fast_add(dst_b, inA_b, inB_b);

    Pop(r12, stack_b, 0);
    Pop(rsi, stack_b, 1);
}


#reset-options "--z3rlimit 300"
procedure{:quick} fast_sub(
    ghost dst_b:buffer64,
    ghost inA_b:buffer64,
    ghost inB_b:buffer64)
    lets
        dst_ptr @= rdi;
        inA_ptr @= rsi;
        inB_ptr @= rcx;

        a0 := buffer64_read(inA_b, 0, mem);
        a1 := buffer64_read(inA_b, 1, mem);
        a2 := buffer64_read(inA_b, 2, mem);
        a3 := buffer64_read(inA_b, 3, mem);

        b0 := buffer64_read(inB_b, 0, mem);
        b1 := buffer64_read(inB_b, 1, mem);
        b2 := buffer64_read(inB_b, 2, mem);
        b3 := buffer64_read(inB_b, 3, mem);

        a := pow2_four(a0, a1, a2, a3);
        b := pow2_four(b0, b1, b2, b3);
    reads
        dst_ptr; inA_ptr; inB_ptr; memTaint;

    modifies
        rax; r8; r9; r10; r11; 
        mem; efl;

    requires
        buffers_disjoint(dst_b, inA_b) || dst_b == inA_b;
        buffers_disjoint(dst_b, inB_b) || dst_b == inB_b;

        validDstAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inA_ptr, inA_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inB_ptr, inB_b, 4, memTaint, Secret);

    ensures
        let d0 := buffer64_read(dst_b, 0, mem);
        let d1 := buffer64_read(dst_b, 1, mem);
        let d2 := buffer64_read(dst_b, 2, mem);
        let d3 := buffer64_read(dst_b, 3, mem);
        let d := pow2_four(d0, d1, d2, d3);
        d - rax * pow2_256 == old(a - b);
        rax == 0 || rax == 1;

        validSrcAddrs64(mem, dst_ptr, dst_b, 4, memTaint, Secret);
        modifies_buffer(dst_b, old(mem), mem);
{
    xor_lemmas();

    Xor64(rax, rax);

    Load64_buffer( r8, inA_ptr,  0, Secret, inA_b, 0);     /* A[0] */
    lemma_load_mem64(inB_b, 0, mem);   
    Sub64Wrap(r8, Mem(inB_ptr, 0, inB_b, 0, Secret));      /* A[0] - B[0] */
    Store64_buffer(dst_ptr,  r8,  0, Secret, dst_b, 0);  

    //assert r8 - pow2_64 * bool_bit(cf(efl)) == old(a0 - b0);  // PASSES

    Load64_buffer( r9, inA_ptr,  8, Secret, inA_b, 1);     /* A[1] */
    lemma_load_mem64(inB_b, 1, mem);   
    Sbb64(r9, Mem(inB_ptr, 8, inB_b, 1, Secret));          /* A[1] - B[1] */
    Store64_buffer(dst_ptr, r9,  8, Secret, dst_b, 1);  

    //assert pow2_two(r8, r9) - pow2_128 * bool_bit(cf(efl)) == old(pow2_two(a0, a1) - pow2_two(b0, b1));  // PASSES
    
    Load64_buffer(r10, inA_ptr, 16, Secret, inA_b, 2);     /* A[2] */
    lemma_load_mem64(inB_b, 2, mem);   
    Sbb64(r10, Mem(inB_ptr,16, inB_b, 2, Secret));         /* A[2] - B[2] */
    //assert pow2_three(r8, r9, r10) - pow2_192 * bool_bit(cf(efl)) == old(pow2_three(a0, a1, a2) - pow2_three(b0, b1, b2));  // FAILS
    Store64_buffer(dst_ptr, r10, 16, Secret, dst_b, 2);  
    
    Load64_buffer(r11, inA_ptr, 24, Secret, inA_b, 3);     /* A[3] */
    lemma_load_mem64(inB_b, 3, mem);   
    Sbb64(r11, Mem(inB_ptr,24, inB_b, 3, Secret));         /* A[3] - B[3] */
    Store64_buffer(dst_ptr, r11, 24, Secret, dst_b, 3);  

    ghost var c := cf(efl);
    Adc64Wrap(rax, rax);   // Extract the carry bit
    assert rax == bool_bit(c);

    lemma_sub(a, a0, a1, a2, a3,
              b, b0, b1, b2, b3,
              r8, r9, r10, r11, bool_bit(c));
}


procedure{:quick}{:public} fast_sub_stdcall(
    inline win:bool,
    ghost dst_b:buffer64,
    ghost inA_b:buffer64,
    ghost inB_b:buffer64,
    ghost stack_b:buffer64)
    lets
        dst_ptr @= rdi; inA_ptr @= rsi; inB_ptr @= rcx;
        dst_in := (if win then rcx else rdi);
        inA_in := (if win then rdx else rsi);
        inB_in := (if win then r8 else rdx);
    reads memTaint;
    modifies
        rax; rbx; rcx; rdx; rdi; rsi; r8; r9; r10; r11; r12; r13; r14;
        rsp; efl; mem;
    requires
        adx_enabled && bmi2_enabled;
        buffers_disjoint(dst_b, inA_b) || dst_b == inA_b;
        buffers_disjoint(dst_b, inB_b) || dst_b == inB_b;

        buffers_disjoint(stack_b, dst_b);
        buffers_disjoint(stack_b, inA_b);
        buffers_disjoint(stack_b, inB_b);

        validDstAddrs64(mem, dst_in, dst_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inA_in, inA_b, 4, memTaint, Secret);
        validSrcAddrs64(mem, inB_in, inB_b, 4, memTaint, Secret);
        valid_stack_slots(mem, rsp, stack_b, 2, memTaint);
    ensures
        let a0 := old(buffer64_read(inA_b, 0, mem));
        let a1 := old(buffer64_read(inA_b, 1, mem));
        let a2 := old(buffer64_read(inA_b, 2, mem));
        let a3 := old(buffer64_read(inA_b, 3, mem));

        let b0 := old(buffer64_read(inB_b, 0, mem));
        let b1 := old(buffer64_read(inB_b, 1, mem));
        let b2 := old(buffer64_read(inB_b, 2, mem));
        let b3 := old(buffer64_read(inB_b, 3, mem));

        let d0 := buffer64_read(dst_b, 0, mem);
        let d1 := buffer64_read(dst_b, 1, mem);
        let d2 := buffer64_read(dst_b, 2, mem);
        let d3 := buffer64_read(dst_b, 3, mem);

        let a := pow2_four(a0, a1, a2, a3);
        let b := pow2_four(b0, b1, b2, b3);
        let d := pow2_four(d0, d1, d2, d3);
        d - rax * pow2_256 == old(a - b);
        rax == 0 || rax == 1;

        //////////////////////////////////////
        //   Framing
        //////////////////////////////////////

        modifies_buffer_2(dst_b, stack_b, old(mem), mem);
        validSrcAddrs64(mem, dst_in, dst_b, 4, memTaint, Secret);

        rsi == old(rsi);
        r12 == old(r12);
        r13 == old(r13);
        r14 == old(r14);

        rsp == old(rsp);
{
    // Store callee-save registers
    Push(rsi, stack_b, 1);
    Push(r12, stack_b, 0);

    // Line up the rest of the arguments
    inline if (win) {
        Mov64(dst_ptr, rcx);
        Mov64(inA_ptr, rdx);
        Mov64(inB_ptr, r8);
    } else {
        Mov64(inB_ptr, rdx);
    }

    fast_sub(dst_b, inA_b, inB_b);

    Pop(r12, stack_b, 0);
    Pop(rsi, stack_b, 1);
}
*/
