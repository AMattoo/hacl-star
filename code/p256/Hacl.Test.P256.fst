module Hacl.Test.P256

module ST = FStar.HyperStack.ST

open FStar.HyperStack.All

#set-options "--lax"

open FStar.Buffer

module P256 = Hacl.Impl.P256

val main: unit -> ST FStar.Int32.t
  (requires (fun h -> True))
  (ensures  (fun h0 r h1 -> True))
let main () =
  push_frame();

  // Base point for Nist-P256
  let px   = createL [0x6Buy; 0x17uy; 0xD1uy; 0xF2uy; 0xE1uy; 0x2Cuy; 0x42uy; 0x47uy;
                     0xF8uy; 0xBCuy; 0xE6uy; 0xE5uy; 0x63uy; 0xA4uy; 0x40uy; 0xF2uy;
                     0x77uy; 0x03uy; 0x7Duy; 0x81uy; 0x2Duy; 0xEBuy; 0x33uy; 0xA0uy;
                     0xF4uy; 0xA1uy; 0x39uy; 0x45uy; 0xD8uy; 0x98uy; 0xC2uy; 0x96uy] in

  let py = createL [0x4Fuy; 0xE3uy; 0x42uy; 0xE2uy; 0xFEuy; 0x1Auy; 0x7Fuy; 0x9Buy;
                   0x8Euy; 0xE7uy; 0xEBuy; 0x4Auy; 0x7Cuy; 0x0Fuy; 0x9Euy; 0x16uy;
                   0x2Buy; 0xCEuy; 0x33uy; 0x57uy; 0x6Buy; 0x31uy; 0x5Euy; 0xCEuy;
                   0xCBuy; 0xB6uy; 0x40uy; 0x68uy; 0x37uy; 0xBFuy; 0x51uy; 0xF5uy] in

  // Scratch point to store the result 
  let outx = create 0uy 32ul in
  let outy = create 0uy 32ul in

  // Test secret key
  let sk1 = createL [0x1uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy;
                    0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy;
                    0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy;
                    0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy ] in

  let sk2 = createL [0x2uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy;
                    0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy;
                    0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy;
                    0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy; 0x0uy ] in

  // Expected result (for sk = 2)
  let expectedx2 = createL [0x7Cuy; 0xF2uy; 0x7Buy; 0x18uy; 0x8Duy; 0x03uy; 0x4Fuy; 0x7Euy;
                     0x8Auy; 0x52uy; 0x38uy; 0x03uy; 0x04uy; 0xB5uy; 0x1Auy; 0xC3uy;
                     0xC0uy; 0x89uy; 0x69uy; 0xE2uy; 0x77uy; 0xF2uy; 0x1Buy; 0x35uy;
                     0xA6uy; 0x0Buy; 0x48uy; 0xFCuy; 0x47uy; 0x66uy; 0x99uy; 0x78uy] in
                     
  let expectedy2 = createL [0x07uy; 0x77uy; 0x55uy; 0x10uy; 0xDBuy; 0x8Euy; 0xD0uy; 0x40uy;
                     0x29uy; 0x3Duy; 0x9Auy; 0xC6uy; 0x9Fuy; 0x74uy; 0x30uy; 0xDBuy;
                     0xBAuy; 0x7Duy; 0xADuy; 0xE6uy; 0x3Cuy; 0xE9uy; 0x82uy; 0x29uy;
                     0x9Euy; 0x04uy; 0xB7uy; 0x9Duy; 0x22uy; 0x78uy; 0x73uy; 0xD1uy] in

  // Test for k = 1
  P256.p256 outx outy px py sk1;
  TestLib.compare_and_print (C.string_of_literal "P256 test vector x coord") px outx 32ul;
  TestLib.compare_and_print (C.string_of_literal "P256 test vector y coord") py outy 32ul;

  // Test for k = 2
  P256.p256 outx outy px py sk2;
  TestLib.compare_and_print (C.string_of_literal "P256 test vector y coord") expectedy2 outy 32ul;
  TestLib.compare_and_print (C.string_of_literal "P256 test vector x coord") expectedx2 outx 32ul;

  (* let res = Ed25519.verify pk4 msg4 1023ul sig4 in *)
  (* let ret = *)
  (*   if res then ( *)
  (*     Ed25519.sign sig4' sk4 msg4 1023ul; *)
  (*     TestLib.compare_and_print (C.string_of_literal "Ed25519 sig4") sig4 sig4' 64ul; *)
  (*     C.exit_success *)
  (*   ) else C.exit_failure in *)

  pop_frame();
  0l
