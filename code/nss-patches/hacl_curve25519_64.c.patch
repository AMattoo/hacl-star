--- ../snapshot-gcc-unrolled/Curve25519.c   2017-08-14 17:36:23.000000000 -0700
+++ /opt/nss_core/nss/lib/freebl/verified/Hacl_Curve25519.c 2017-08-14 17:27:39.000000000 -0700
@@ -1,4 +1,18 @@
-#include "Curve25519.h"
+// Copyright 2016-2017 INRIA and Microsoft Corporation
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include "hacl_curve25519_64.h"
 
 static void Hacl_Bignum_Modulo_carry_top(uint64_t *b)
 {
@@ -120,7 +134,7 @@
     uint64_t
     r0 =
       FStar_Int_Cast_Full_uint128_to_uint64(tctr)
-      & ((uint64_t )1 << (uint32_t )51) - (uint64_t )1;
+      & (((uint64_t )1 << (uint32_t )51) - (uint64_t )1);
     FStar_UInt128_t c = FStar_UInt128_shift_right(tctr, (uint32_t )51);
     tmp[ctr] = FStar_Int_Cast_Full_uint64_to_uint128(r0);
     tmp[ctr + (uint32_t )1] = FStar_UInt128_add(tctrp1, c);
@@ -132,7 +146,7 @@
     uint64_t
     r0 =
       FStar_Int_Cast_Full_uint128_to_uint64(tctr)
-      & ((uint64_t )1 << (uint32_t )51) - (uint64_t )1;
+      & (((uint64_t )1 << (uint32_t )51) - (uint64_t )1);
     FStar_UInt128_t c = FStar_UInt128_shift_right(tctr, (uint32_t )51);
     tmp[ctr] = FStar_Int_Cast_Full_uint64_to_uint128(r0);
     tmp[ctr + (uint32_t )1] = FStar_UInt128_add(tctrp1, c);
@@ -144,7 +158,7 @@
     uint64_t
     r0 =
       FStar_Int_Cast_Full_uint128_to_uint64(tctr)
-      & ((uint64_t )1 << (uint32_t )51) - (uint64_t )1;
+      & (((uint64_t )1 << (uint32_t )51) - (uint64_t )1);
     FStar_UInt128_t c = FStar_UInt128_shift_right(tctr, (uint32_t )51);
     tmp[ctr] = FStar_Int_Cast_Full_uint64_to_uint128(r0);
     tmp[ctr + (uint32_t )1] = FStar_UInt128_add(tctrp1, c);
@@ -156,7 +170,7 @@
     uint64_t
     r0 =
       FStar_Int_Cast_Full_uint128_to_uint64(tctr)
-      & ((uint64_t )1 << (uint32_t )51) - (uint64_t )1;
+      & (((uint64_t )1 << (uint32_t )51) - (uint64_t )1);
     FStar_UInt128_t c = FStar_UInt128_shift_right(tctr, (uint32_t )51);
     tmp[ctr] = FStar_Int_Cast_Full_uint64_to_uint128(r0);
     tmp[ctr + (uint32_t )1] = FStar_UInt128_add(tctrp1, c);
@@ -246,7 +260,7 @@
   Hacl_Bignum_Fproduct_copy_from_wide_(output, t);
   uint64_t i0 = output[0];
   uint64_t i1 = output[1];
-  uint64_t i0_ = i0 & ((uint64_t )1 << (uint32_t )51) - (uint64_t )1;
+  uint64_t i0_ = i0 & (((uint64_t )1 << (uint32_t )51) - (uint64_t )1);
   uint64_t i1_ = i1 + (i0 >> (uint32_t )51);
   output[0] = i0_;
   output[1] = i1_;
@@ -338,7 +352,7 @@
   Hacl_Bignum_Fproduct_copy_from_wide_(output, tmp);
   uint64_t i0 = output[0];
   uint64_t i1 = output[1];
-  uint64_t i0_ = i0 & ((uint64_t )1 << (uint32_t )51) - (uint64_t )1;
+  uint64_t i0_ = i0 & (((uint64_t )1 << (uint32_t )51) - (uint64_t )1);
   uint64_t i1_ = i1 + (i0 >> (uint32_t )51);
   output[0] = i0_;
   output[1] = i1_;
@@ -573,7 +587,7 @@
 {
   if (ctr == (uint32_t )0)
   {
-    
+
   }
   else
   {
@@ -740,7 +754,7 @@
 {
   if (i == (uint32_t )0)
   {
-    
+
   }
   else
   {
@@ -764,7 +778,7 @@
 {
   if (i == (uint32_t )0)
   {
-    
+
   }
   else
   {
@@ -909,7 +923,7 @@
   Hacl_Bignum_Modulo_carry_top(input);
   uint64_t i0 = input[0];
   uint64_t i1 = input[1];
-  uint64_t i0_ = i0 & ((uint64_t )1 << (uint32_t )51) - (uint64_t )1;
+  uint64_t i0_ = i0 & (((uint64_t )1 << (uint32_t )51) - (uint64_t )1);
   uint64_t i1_ = i1 + (i0 >> (uint32_t )51);
   input[0] = i0_;
   input[1] = i1_;
@@ -1024,4 +1038,3 @@
 {
   Hacl_EC_crypto_scalarmult(mypublic, secret, basepoint);
 }
-
