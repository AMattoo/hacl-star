/* This file was generated by KreMLin <https://github.com/FStarLang/kremlin>
 * KreMLin invocation: /home/rpk/kremlin/krml -I /home/rpk/kremlin/kremlib/compat -I /mnt/c/hacl-star/code/lib/kremlin -I /home/rpk/kremlin/kremlib/compat -I /mnt/c/hacl-star/specs -I . -ccopt -march=native -verbose -ldopt -flto -tmpdir mpfr-c mpfr-c/out.krml -skip-compilation -minimal -add-include "kremlib.h" -bundle MPFR=* -fparentheses
 * F* version: 3352fef9
 * KreMLin version: c65d4779
 */

#include "MPFR.h"

extern FStar_UInt128_uint128 FStar_UInt128_shift_right(FStar_UInt128_uint128 x0, uint32_t x1);

extern uint64_t FStar_UInt128_uint128_to_uint64(FStar_UInt128_uint128 x0);

extern FStar_UInt128_uint128 FStar_UInt128_mul_wide(uint64_t x0, uint64_t x1);

static bool MPFR_RoundingMode_uu___is_MPFR_RNDN(MPFR_RoundingMode_mpfr_rnd_t projectee)
{
  switch (projectee)
  {
    case MPFR_RoundingMode_MPFR_RNDN:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

static bool MPFR_RoundingMode_uu___is_MPFR_RNDZ(MPFR_RoundingMode_mpfr_rnd_t projectee)
{
  switch (projectee)
  {
    case MPFR_RoundingMode_MPFR_RNDZ:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

static bool MPFR_RoundingMode_uu___is_MPFR_RNDU(MPFR_RoundingMode_mpfr_rnd_t projectee)
{
  switch (projectee)
  {
    case MPFR_RoundingMode_MPFR_RNDU:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

static bool MPFR_RoundingMode_uu___is_MPFR_RNDD(MPFR_RoundingMode_mpfr_rnd_t projectee)
{
  switch (projectee)
  {
    case MPFR_RoundingMode_MPFR_RNDD:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

static bool MPFR_RoundingMode_uu___is_MPFR_RNDA(MPFR_RoundingMode_mpfr_rnd_t projectee)
{
  switch (projectee)
  {
    case MPFR_RoundingMode_MPFR_RNDA:
      {
        return true;
      }
    default:
      {
        return false;
      }
  }
}

static bool MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(MPFR_RoundingMode_mpfr_rnd_t rnd, bool neg)
{
  return
    MPFR_RoundingMode_uu___is_MPFR_RNDZ(rnd)
    || (MPFR_RoundingMode_uu___is_MPFR_RNDU(rnd) && neg)
    || (MPFR_RoundingMode_uu___is_MPFR_RNDD(rnd) && !neg);
}

static bool MPFR_RoundingMode_mpfr_IS_LIKE_RNDA(MPFR_RoundingMode_mpfr_rnd_t rnd, bool neg)
{
  return
    MPFR_RoundingMode_uu___is_MPFR_RNDA(rnd)
    || (MPFR_RoundingMode_uu___is_MPFR_RNDD(rnd) && neg)
    || (MPFR_RoundingMode_uu___is_MPFR_RNDD(rnd) && !neg);
}

static uint32_t MPFR_Lib_gmp_NUMB_BITS = (uint32_t)64U;

static int32_t MPFR_Lib_mpfr_EMIN = (int32_t)1 - (int32_t)0x40000000;

static int32_t MPFR_Lib_mpfr_EMAX = (int32_t)0x40000000 - (int32_t)1;

static void MPFR_Lib_mpn_ZERO(uint64_t *b, uint32_t l)
{
  if (!(l == (uint32_t)0U))
  {
    b[l - (uint32_t)1U] = (uint64_t)0U;
    MPFR_Lib_mpn_ZERO(b, l - (uint32_t)1U);
  }
}

static int32_t MPFR_Lib_mpfr_RET(int32_t t)
{
  return t;
}

static void MPFR_Lib_mpfr_setmax_rec(MPFR_Lib_mpfr_struct *x, uint32_t i)
{
  uint64_t *mant = x->mpfr_d;
  if (i == (uint32_t)0U)
  {
    MPFR_Lib_mpfr_struct f0 = x[0U];
    uint32_t p = f0.mpfr_prec;
    MPFR_Lib_mpfr_struct f = x[0U];
    uint32_t l = (f.mpfr_prec - (uint32_t)1U) / MPFR_Lib_gmp_NUMB_BITS + (uint32_t)1U;
    mant[i] = (uint64_t)0xffffffffffffffffU << (l * MPFR_Lib_gmp_NUMB_BITS - p);
  }
  else
  {
    MPFR_Lib_mpfr_setmax_rec(x, i - (uint32_t)1U);
    mant[i] = (uint64_t)0xffffffffffffffffU;
  }
}

static void MPFR_Lib_mpfr_setmax(MPFR_Lib_mpfr_struct *x)
{
  MPFR_Lib_mpfr_struct uu___62_131220 = x[0U];
  x[0U] =
    (
      (MPFR_Lib_mpfr_struct){
        .mpfr_prec = uu___62_131220.mpfr_prec,
        .mpfr_sign = uu___62_131220.mpfr_sign,
        .mpfr_exp = MPFR_Lib_mpfr_EMAX,
        .mpfr_d = uu___62_131220.mpfr_d
      }
    );
  MPFR_Lib_mpfr_struct f = x[0U];
  MPFR_Lib_mpfr_setmax_rec(x, (f.mpfr_prec - (uint32_t)1U) / MPFR_Lib_gmp_NUMB_BITS);
}

static void MPFR_Lib_mpfr_setmin(MPFR_Lib_mpfr_struct *x)
{
  MPFR_Lib_mpfr_struct uu___62_131431 = x[0U];
  x[0U] =
    (
      (MPFR_Lib_mpfr_struct){
        .mpfr_prec = uu___62_131431.mpfr_prec,
        .mpfr_sign = uu___62_131431.mpfr_sign,
        .mpfr_exp = MPFR_Lib_mpfr_EMIN,
        .mpfr_d = uu___62_131431.mpfr_d
      }
    );
  MPFR_Lib_mpfr_struct f = x[0U];
  uint32_t xn = (f.mpfr_prec - (uint32_t)1U) / MPFR_Lib_gmp_NUMB_BITS;
  uint64_t *xp = x->mpfr_d;
  xp[xn] = (uint64_t)0x8000000000000000U;
  MPFR_Lib_mpn_ZERO(xp, xn);
}

static int32_t
MPFR_Exceptions_mpfr_overflow(
  MPFR_Lib_mpfr_struct *x,
  MPFR_RoundingMode_mpfr_rnd_t rnd_mode,
  int32_t sign
)
{
  MPFR_Lib_mpfr_struct uu___63_80 = x[0U];
  x[0U] =
    (
      (MPFR_Lib_mpfr_struct){
        .mpfr_prec = uu___63_80.mpfr_prec,
        .mpfr_sign = sign,
        .mpfr_exp = uu___63_80.mpfr_exp,
        .mpfr_d = uu___63_80.mpfr_d
      }
    );
  if (MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(rnd_mode, sign < (int32_t)0))
  {
    MPFR_Lib_mpfr_setmax(x);
    if (sign == (int32_t)1)
      return (int32_t)-1;
    else
      return (int32_t)1;
  }
  else
  {
    MPFR_Lib_mpfr_struct uu___62_167 = x[0U];
    x[0U] =
      (
        (MPFR_Lib_mpfr_struct){
          .mpfr_prec = uu___62_167.mpfr_prec,
          .mpfr_sign = uu___62_167.mpfr_sign,
          .mpfr_exp = (int32_t)-0x80000000 + (int32_t)3,
          .mpfr_d = uu___62_167.mpfr_d
        }
      );
    return sign;
  }
}

static int32_t
MPFR_Exceptions_mpfr_underflow(
  MPFR_Lib_mpfr_struct *x,
  MPFR_RoundingMode_mpfr_rnd_t rnd_mode,
  int32_t sign
)
{
  MPFR_Lib_mpfr_struct uu___63_284 = x[0U];
  x[0U] =
    (
      (MPFR_Lib_mpfr_struct){
        .mpfr_prec = uu___63_284.mpfr_prec,
        .mpfr_sign = sign,
        .mpfr_exp = uu___63_284.mpfr_exp,
        .mpfr_d = uu___63_284.mpfr_d
      }
    );
  if (MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(rnd_mode, sign < (int32_t)0))
  {
    MPFR_Lib_mpfr_struct uu___62_339 = x[0U];
    x[0U] =
      (
        (MPFR_Lib_mpfr_struct){
          .mpfr_prec = uu___62_339.mpfr_prec,
          .mpfr_sign = uu___62_339.mpfr_sign,
          .mpfr_exp = (int32_t)-0x80000000 + (int32_t)1,
          .mpfr_d = uu___62_339.mpfr_d
        }
      );
    if (sign == (int32_t)1)
      return (int32_t)-1;
    else
      return (int32_t)1;
  }
  else
  {
    MPFR_Lib_mpfr_setmin(x);
    return sign;
  }
}

typedef struct MPFR_Add1sp1_state_s
{
  uint32_t sh;
  int32_t bx;
  uint64_t rb;
  uint64_t sb;
}
MPFR_Add1sp1_state;

static MPFR_Add1sp1_state
MPFR_Add1sp1_mk_state(uint32_t sh, int32_t bx, uint64_t rb, uint64_t sb)
{
  return ((MPFR_Add1sp1_state){ .sh = sh, .bx = bx, .rb = rb, .sb = sb });
}

typedef struct K___uint64_t_int32_t_s
{
  uint64_t fst;
  int32_t snd;
}
K___uint64_t_int32_t;

typedef struct K___uint64_t_uint64_t_int32_t_s
{
  uint64_t fst;
  uint64_t snd;
  int32_t thd;
}
K___uint64_t_uint64_t_int32_t;

static int32_t
MPFR_Add1sp1_mpfr_add1sp1(
  MPFR_Lib_mpfr_struct *a,
  MPFR_Lib_mpfr_struct *b,
  MPFR_Lib_mpfr_struct *c,
  MPFR_RoundingMode_mpfr_rnd_t rnd_mode,
  uint32_t p
)
{
  MPFR_Lib_mpfr_struct a0 = a[0U];
  MPFR_Lib_mpfr_struct b0 = b[0U];
  MPFR_Lib_mpfr_struct c0 = c[0U];
  int32_t bx = b0.mpfr_exp;
  int32_t cx = c0.mpfr_exp;
  uint32_t sh = MPFR_Lib_gmp_NUMB_BITS - p;
  MPFR_Add1sp1_state st;
  if (bx == cx)
  {
    uint64_t *ap = a0.mpfr_d;
    uint64_t *bp = b0.mpfr_d;
    uint64_t *cp = c0.mpfr_d;
    uint64_t a01 = (bp[0U] >> (uint32_t)1U) + (cp[0U] >> (uint32_t)1U);
    int32_t bx1 = b0.mpfr_exp + (int32_t)1;
    uint64_t rb = a01 & (uint64_t)1U << (sh - (uint32_t)1U);
    ap[0U] = a01 ^ rb;
    uint64_t sb = (uint64_t)0U;
    st = MPFR_Add1sp1_mk_state(sh, bx1, rb, sb);
  }
  else
  {
    MPFR_Add1sp1_state ite0;
    if (bx > cx)
    {
      int32_t bx1 = b0.mpfr_exp;
      int32_t cx1 = c0.mpfr_exp;
      uint32_t d = (uint32_t)(bx1 - cx1);
      uint64_t mask = ((uint64_t)1U << sh) - (uint64_t)1U;
      MPFR_Add1sp1_state ite1;
      if (d < sh)
      {
        uint64_t *ap = a0.mpfr_d;
        uint64_t *bp = b0.mpfr_d;
        uint64_t *cp = c0.mpfr_d;
        int32_t bx2 = b0.mpfr_exp;
        uint64_t a01 = bp[0U] + (cp[0U] >> d);
        K___uint64_t_int32_t scrut;
        if (a01 < bp[0U])
          scrut =
            (
              (K___uint64_t_int32_t){
                .fst = (uint64_t)0x8000000000000000U | a01 >> (uint32_t)1U,
                .snd = bx2 + (int32_t)1
              }
            );
        else
          scrut = ((K___uint64_t_int32_t){ .fst = a01, .snd = bx2 });
        uint64_t a02 = scrut.fst;
        int32_t bx3 = scrut.snd;
        uint64_t rb = a02 & (uint64_t)1U << (sh - (uint32_t)1U);
        uint64_t sb = (a02 & mask) ^ rb;
        ap[0U] = a02 & ~mask;
        ite1 = MPFR_Add1sp1_mk_state(sh, bx3, rb, sb);
      }
      else
      {
        MPFR_Add1sp1_state ite;
        if (d < MPFR_Lib_gmp_NUMB_BITS)
        {
          uint64_t *ap = a0.mpfr_d;
          uint64_t *bp = b0.mpfr_d;
          uint64_t *cp = c0.mpfr_d;
          int32_t bx2 = b0.mpfr_exp;
          uint64_t sb = cp[0U] << (MPFR_Lib_gmp_NUMB_BITS - d);
          uint64_t a01 = bp[0U] + (cp[0U] >> d);
          K___uint64_t_uint64_t_int32_t scrut;
          if (a01 < bp[0U])
            scrut =
              (
                (K___uint64_t_uint64_t_int32_t){
                  .fst = sb | (a01 & (uint64_t)1U),
                  .snd = (uint64_t)0x8000000000000000U | a01 >> (uint32_t)1U,
                  .thd = bx2 + (int32_t)1
                }
              );
          else
            scrut = ((K___uint64_t_uint64_t_int32_t){ .fst = sb, .snd = a01, .thd = bx2 });
          uint64_t sb1 = scrut.fst;
          uint64_t a02 = scrut.snd;
          int32_t bx3 = scrut.thd;
          uint64_t rb = a02 & (uint64_t)1U << (sh - (uint32_t)1U);
          uint64_t sb2 = sb1 | ((a02 & mask) ^ rb);
          ap[0U] = a02 & ~mask;
          ite = MPFR_Add1sp1_mk_state(sh, bx3, rb, sb2);
        }
        else
        {
          uint64_t *ap = a0.mpfr_d;
          uint64_t *bp = b0.mpfr_d;
          int32_t bx2 = b0.mpfr_exp;
          ap[0U] = bp[0U];
          uint64_t rb = (uint64_t)0U;
          uint64_t sb = (uint64_t)1U;
          ite = MPFR_Add1sp1_mk_state(sh, bx2, rb, sb);
        }
        ite1 = ite;
      }
      ite0 = ite1;
    }
    else
    {
      int32_t bx1 = c0.mpfr_exp;
      int32_t cx1 = b0.mpfr_exp;
      uint32_t d = (uint32_t)(bx1 - cx1);
      uint64_t mask = ((uint64_t)1U << sh) - (uint64_t)1U;
      MPFR_Add1sp1_state ite1;
      if (d < sh)
      {
        uint64_t *ap = a0.mpfr_d;
        uint64_t *bp = c0.mpfr_d;
        uint64_t *cp = b0.mpfr_d;
        int32_t bx2 = c0.mpfr_exp;
        uint64_t a01 = bp[0U] + (cp[0U] >> d);
        K___uint64_t_int32_t scrut;
        if (a01 < bp[0U])
          scrut =
            (
              (K___uint64_t_int32_t){
                .fst = (uint64_t)0x8000000000000000U | a01 >> (uint32_t)1U,
                .snd = bx2 + (int32_t)1
              }
            );
        else
          scrut = ((K___uint64_t_int32_t){ .fst = a01, .snd = bx2 });
        uint64_t a02 = scrut.fst;
        int32_t bx3 = scrut.snd;
        uint64_t rb = a02 & (uint64_t)1U << (sh - (uint32_t)1U);
        uint64_t sb = (a02 & mask) ^ rb;
        ap[0U] = a02 & ~mask;
        ite1 = MPFR_Add1sp1_mk_state(sh, bx3, rb, sb);
      }
      else
      {
        MPFR_Add1sp1_state ite;
        if (d < MPFR_Lib_gmp_NUMB_BITS)
        {
          uint64_t *ap = a0.mpfr_d;
          uint64_t *bp = c0.mpfr_d;
          uint64_t *cp = b0.mpfr_d;
          int32_t bx2 = c0.mpfr_exp;
          uint64_t sb = cp[0U] << (MPFR_Lib_gmp_NUMB_BITS - d);
          uint64_t a01 = bp[0U] + (cp[0U] >> d);
          K___uint64_t_uint64_t_int32_t scrut;
          if (a01 < bp[0U])
            scrut =
              (
                (K___uint64_t_uint64_t_int32_t){
                  .fst = sb | (a01 & (uint64_t)1U),
                  .snd = (uint64_t)0x8000000000000000U | a01 >> (uint32_t)1U,
                  .thd = bx2 + (int32_t)1
                }
              );
          else
            scrut = ((K___uint64_t_uint64_t_int32_t){ .fst = sb, .snd = a01, .thd = bx2 });
          uint64_t sb1 = scrut.fst;
          uint64_t a02 = scrut.snd;
          int32_t bx3 = scrut.thd;
          uint64_t rb = a02 & (uint64_t)1U << (sh - (uint32_t)1U);
          uint64_t sb2 = sb1 | ((a02 & mask) ^ rb);
          ap[0U] = a02 & ~mask;
          ite = MPFR_Add1sp1_mk_state(sh, bx3, rb, sb2);
        }
        else
        {
          uint64_t *ap = a0.mpfr_d;
          uint64_t *bp = c0.mpfr_d;
          int32_t bx2 = c0.mpfr_exp;
          ap[0U] = bp[0U];
          uint64_t rb = (uint64_t)0U;
          uint64_t sb = (uint64_t)1U;
          ite = MPFR_Add1sp1_mk_state(sh, bx2, rb, sb);
        }
        ite1 = ite;
      }
      ite0 = ite1;
    }
    st = ite0;
  }
  if (st.bx > MPFR_Lib_mpfr_EMAX)
  {
    int32_t t = MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
    return t;
  }
  else
  {
    uint64_t *ap = a->mpfr_d;
    uint64_t a01 = ap[0U];
    MPFR_Lib_mpfr_struct uu___62_3483 = a[0U];
    a[0U] =
      (
        (MPFR_Lib_mpfr_struct){
          .mpfr_prec = uu___62_3483.mpfr_prec,
          .mpfr_sign = uu___62_3483.mpfr_sign,
          .mpfr_exp = st.bx,
          .mpfr_d = uu___62_3483.mpfr_d
        }
      );
    if (st.rb == (uint64_t)0U && st.sb == (uint64_t)0U)
      return MPFR_Lib_mpfr_RET((int32_t)0);
    else if (MPFR_RoundingMode_uu___is_MPFR_RNDN(rnd_mode))
      if
      (
        st.rb
        == (uint64_t)0U
        || (st.sb == (uint64_t)0U && (a01 & (uint64_t)1U << st.sh) == (uint64_t)0U)
      )
      {
        int32_t ite;
        if (a->mpfr_sign == (int32_t)1)
          ite = (int32_t)-1;
        else
          ite = (int32_t)1;
        return MPFR_Lib_mpfr_RET(ite);
      }
      else
      {
        uint64_t *ap1 = a->mpfr_d;
        ap1[0U] = ap1[0U] + ((uint64_t)1U << st.sh);
        if (ap1[0U] == (uint64_t)0U)
        {
          ap1[0U] = (uint64_t)0x8000000000000000U;
          if (st.bx + (int32_t)1 <= MPFR_Lib_mpfr_EMAX)
          {
            MPFR_Lib_mpfr_struct uu___62_3579 = a[0U];
            a[0U] =
              (
                (MPFR_Lib_mpfr_struct){
                  .mpfr_prec = uu___62_3579.mpfr_prec,
                  .mpfr_sign = uu___62_3579.mpfr_sign,
                  .mpfr_exp = st.bx + (int32_t)1,
                  .mpfr_d = uu___62_3579.mpfr_d
                }
              );
            return MPFR_Lib_mpfr_RET(a->mpfr_sign);
          }
          else
          {
            int32_t t = MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
            return MPFR_Lib_mpfr_RET(t);
          }
        }
        else
          return MPFR_Lib_mpfr_RET(a->mpfr_sign);
      }
    else if (MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(rnd_mode, a->mpfr_sign < (int32_t)0))
    {
      int32_t ite;
      if (a->mpfr_sign == (int32_t)1)
        ite = (int32_t)-1;
      else
        ite = (int32_t)1;
      return MPFR_Lib_mpfr_RET(ite);
    }
    else
    {
      uint64_t *ap1 = a->mpfr_d;
      ap1[0U] = ap1[0U] + ((uint64_t)1U << st.sh);
      if (ap1[0U] == (uint64_t)0U)
      {
        ap1[0U] = (uint64_t)0x8000000000000000U;
        if (st.bx + (int32_t)1 <= MPFR_Lib_mpfr_EMAX)
        {
          MPFR_Lib_mpfr_struct uu___62_3786 = a[0U];
          a[0U] =
            (
              (MPFR_Lib_mpfr_struct){
                .mpfr_prec = uu___62_3786.mpfr_prec,
                .mpfr_sign = uu___62_3786.mpfr_sign,
                .mpfr_exp = st.bx + (int32_t)1,
                .mpfr_d = uu___62_3786.mpfr_d
              }
            );
          return MPFR_Lib_mpfr_RET(a->mpfr_sign);
        }
        else
        {
          int32_t t = MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
          return MPFR_Lib_mpfr_RET(t);
        }
      }
      else
        return MPFR_Lib_mpfr_RET(a->mpfr_sign);
    }
  }
}

typedef struct K___uint64_t_uint64_t_s
{
  uint64_t fst;
  uint64_t snd;
}
K___uint64_t_uint64_t;

static K___uint64_t_uint64_t MPFR_Umul_ppmm_umul_ppmm(uint64_t m, uint64_t n1)
{
  FStar_UInt128_uint128 p = FStar_UInt128_mul_wide(m, n1);
  return
    (
      (K___uint64_t_uint64_t){
        .fst = FStar_UInt128_uint128_to_uint64(FStar_UInt128_shift_right(p, (uint32_t)64U)),
        .snd = FStar_UInt128_uint128_to_uint64(p)
      }
    );
}

typedef struct K___int32_t_uint64_t_uint64_t_s
{
  int32_t fst;
  uint64_t snd;
  uint64_t thd;
}
K___int32_t_uint64_t_uint64_t;

static int32_t
MPFR_Mul_1_mpfr_mul_1(
  MPFR_Lib_mpfr_struct *a,
  MPFR_Lib_mpfr_struct *b,
  MPFR_Lib_mpfr_struct *c,
  MPFR_RoundingMode_mpfr_rnd_t rnd_mode,
  uint32_t p
)
{
  uint64_t *ap = a->mpfr_d;
  uint64_t *bp = b->mpfr_d;
  uint64_t *cp = c->mpfr_d;
  uint64_t b0 = bp[0U];
  uint64_t c0 = cp[0U];
  uint32_t sh = MPFR_Lib_gmp_NUMB_BITS - p;
  uint64_t mask = ((uint64_t)1U << sh) - (uint64_t)1U;
  int32_t ax = b->mpfr_exp + c->mpfr_exp;
  K___uint64_t_uint64_t scrut0 = MPFR_Umul_ppmm_umul_ppmm(b0, c0);
  uint64_t a0 = scrut0.fst;
  uint64_t sb = scrut0.snd;
  K___int32_t_uint64_t_uint64_t scrut;
  if (a0 < (uint64_t)0x8000000000000000U)
    scrut =
      (
        (K___int32_t_uint64_t_uint64_t){
          .fst = ax - (int32_t)1,
          .snd = a0 << (uint32_t)1U | sb >> (MPFR_Lib_gmp_NUMB_BITS - (uint32_t)1U),
          .thd = sb << (uint32_t)1U
        }
      );
  else
    scrut = ((K___int32_t_uint64_t_uint64_t){ .fst = ax, .snd = a0, .thd = sb });
  int32_t ax1 = scrut.fst;
  uint64_t a01 = scrut.snd;
  uint64_t sb1 = scrut.thd;
  uint64_t rb = a01 & (uint64_t)1U << (sh - (uint32_t)1U);
  uint64_t sb2 = sb1 | ((a01 & mask) ^ rb);
  ap[0U] = a01 & ~mask;
  MPFR_Lib_mpfr_struct uu___63_2736 = a[0U];
  a[0U] =
    (
      (MPFR_Lib_mpfr_struct){
        .mpfr_prec = uu___63_2736.mpfr_prec,
        .mpfr_sign = b->mpfr_sign * c->mpfr_sign,
        .mpfr_exp = uu___63_2736.mpfr_exp,
        .mpfr_d = uu___63_2736.mpfr_d
      }
    );
  uint64_t *ap1 = a->mpfr_d;
  uint64_t a02 = ap1[0U];
  if (ax1 > MPFR_Lib_mpfr_EMAX)
    return MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
  else if (ax1 < MPFR_Lib_mpfr_EMIN)
  {
    bool aneg = a->mpfr_sign < (int32_t)0;
    if
    (
      ax1
      == MPFR_Lib_mpfr_EMIN - (int32_t)1
      && a02 == ~mask
      &&
        ((MPFR_RoundingMode_uu___is_MPFR_RNDN(rnd_mode) && rb > (uint64_t)0U)
        || ((rb | sb2) > (uint64_t)0U && MPFR_RoundingMode_mpfr_IS_LIKE_RNDA(rnd_mode, aneg)))
    )
    {
      uint64_t *ap2 = a->mpfr_d;
      uint64_t a03 = ap2[0U];
      MPFR_Lib_mpfr_struct uu___62_2887 = a[0U];
      a[0U] =
        (
          (MPFR_Lib_mpfr_struct){
            .mpfr_prec = uu___62_2887.mpfr_prec,
            .mpfr_sign = uu___62_2887.mpfr_sign,
            .mpfr_exp = ax1,
            .mpfr_d = uu___62_2887.mpfr_d
          }
        );
      if (rb == (uint64_t)0U && sb2 == (uint64_t)0U)
        return MPFR_Lib_mpfr_RET((int32_t)0);
      else if (MPFR_RoundingMode_uu___is_MPFR_RNDN(rnd_mode))
        if
        (rb == (uint64_t)0U || (sb2 == (uint64_t)0U && (a03 & (uint64_t)1U << sh) == (uint64_t)0U))
        {
          int32_t ite;
          if (a->mpfr_sign == (int32_t)1)
            ite = (int32_t)-1;
          else
            ite = (int32_t)1;
          return MPFR_Lib_mpfr_RET(ite);
        }
        else
        {
          uint64_t *ap3 = a->mpfr_d;
          ap3[0U] = ap3[0U] + ((uint64_t)1U << sh);
          if (ap3[0U] == (uint64_t)0U)
          {
            ap3[0U] = (uint64_t)0x8000000000000000U;
            if (ax1 + (int32_t)1 > MPFR_Lib_mpfr_EMAX)
              return MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
            else
            {
              MPFR_Lib_mpfr_struct uu___62_3027 = a[0U];
              a[0U] =
                (
                  (MPFR_Lib_mpfr_struct){
                    .mpfr_prec = uu___62_3027.mpfr_prec,
                    .mpfr_sign = uu___62_3027.mpfr_sign,
                    .mpfr_exp = ax1 + (int32_t)1,
                    .mpfr_d = uu___62_3027.mpfr_d
                  }
                );
              return MPFR_Lib_mpfr_RET(a->mpfr_sign);
            }
          }
          else
            return MPFR_Lib_mpfr_RET(a->mpfr_sign);
        }
      else if (MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(rnd_mode, a->mpfr_sign < (int32_t)0))
      {
        int32_t ite;
        if (a->mpfr_sign == (int32_t)1)
          ite = (int32_t)-1;
        else
          ite = (int32_t)1;
        return MPFR_Lib_mpfr_RET(ite);
      }
      else
      {
        uint64_t *ap3 = a->mpfr_d;
        ap3[0U] = ap3[0U] + ((uint64_t)1U << sh);
        if (ap3[0U] == (uint64_t)0U)
        {
          ap3[0U] = (uint64_t)0x8000000000000000U;
          if (ax1 + (int32_t)1 > MPFR_Lib_mpfr_EMAX)
            return MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
          else
          {
            MPFR_Lib_mpfr_struct uu___62_3217 = a[0U];
            a[0U] =
              (
                (MPFR_Lib_mpfr_struct){
                  .mpfr_prec = uu___62_3217.mpfr_prec,
                  .mpfr_sign = uu___62_3217.mpfr_sign,
                  .mpfr_exp = ax1 + (int32_t)1,
                  .mpfr_d = uu___62_3217.mpfr_d
                }
              );
            return MPFR_Lib_mpfr_RET(a->mpfr_sign);
          }
        }
        else
          return MPFR_Lib_mpfr_RET(a->mpfr_sign);
      }
    }
    else if
    (
      MPFR_RoundingMode_uu___is_MPFR_RNDN(rnd_mode)
      &&
        (ax1
        < MPFR_Lib_mpfr_EMIN - (int32_t)1
        || (a02 == (uint64_t)0x8000000000000000U && (rb | sb2) == (uint64_t)0U))
    )
      return MPFR_Exceptions_mpfr_underflow(a, MPFR_RoundingMode_MPFR_RNDZ, a->mpfr_sign);
    else
      return MPFR_Exceptions_mpfr_underflow(a, rnd_mode, a->mpfr_sign);
  }
  else
  {
    uint64_t *ap2 = a->mpfr_d;
    uint64_t a03 = ap2[0U];
    MPFR_Lib_mpfr_struct uu___62_3402 = a[0U];
    a[0U] =
      (
        (MPFR_Lib_mpfr_struct){
          .mpfr_prec = uu___62_3402.mpfr_prec,
          .mpfr_sign = uu___62_3402.mpfr_sign,
          .mpfr_exp = ax1,
          .mpfr_d = uu___62_3402.mpfr_d
        }
      );
    if (rb == (uint64_t)0U && sb2 == (uint64_t)0U)
      return MPFR_Lib_mpfr_RET((int32_t)0);
    else if (MPFR_RoundingMode_uu___is_MPFR_RNDN(rnd_mode))
      if (rb == (uint64_t)0U || (sb2 == (uint64_t)0U && (a03 & (uint64_t)1U << sh) == (uint64_t)0U))
      {
        int32_t ite;
        if (a->mpfr_sign == (int32_t)1)
          ite = (int32_t)-1;
        else
          ite = (int32_t)1;
        return MPFR_Lib_mpfr_RET(ite);
      }
      else
      {
        uint64_t *ap3 = a->mpfr_d;
        ap3[0U] = ap3[0U] + ((uint64_t)1U << sh);
        if (ap3[0U] == (uint64_t)0U)
        {
          ap3[0U] = (uint64_t)0x8000000000000000U;
          if (ax1 + (int32_t)1 > MPFR_Lib_mpfr_EMAX)
            return MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
          else
          {
            MPFR_Lib_mpfr_struct uu___62_3542 = a[0U];
            a[0U] =
              (
                (MPFR_Lib_mpfr_struct){
                  .mpfr_prec = uu___62_3542.mpfr_prec,
                  .mpfr_sign = uu___62_3542.mpfr_sign,
                  .mpfr_exp = ax1 + (int32_t)1,
                  .mpfr_d = uu___62_3542.mpfr_d
                }
              );
            return MPFR_Lib_mpfr_RET(a->mpfr_sign);
          }
        }
        else
          return MPFR_Lib_mpfr_RET(a->mpfr_sign);
      }
    else if (MPFR_RoundingMode_mpfr_IS_LIKE_RNDZ(rnd_mode, a->mpfr_sign < (int32_t)0))
    {
      int32_t ite;
      if (a->mpfr_sign == (int32_t)1)
        ite = (int32_t)-1;
      else
        ite = (int32_t)1;
      return MPFR_Lib_mpfr_RET(ite);
    }
    else
    {
      uint64_t *ap3 = a->mpfr_d;
      ap3[0U] = ap3[0U] + ((uint64_t)1U << sh);
      if (ap3[0U] == (uint64_t)0U)
      {
        ap3[0U] = (uint64_t)0x8000000000000000U;
        if (ax1 + (int32_t)1 > MPFR_Lib_mpfr_EMAX)
          return MPFR_Exceptions_mpfr_overflow(a, rnd_mode, a->mpfr_sign);
        else
        {
          MPFR_Lib_mpfr_struct uu___62_3732 = a[0U];
          a[0U] =
            (
              (MPFR_Lib_mpfr_struct){
                .mpfr_prec = uu___62_3732.mpfr_prec,
                .mpfr_sign = uu___62_3732.mpfr_sign,
                .mpfr_exp = ax1 + (int32_t)1,
                .mpfr_d = uu___62_3732.mpfr_d
              }
            );
          return MPFR_Lib_mpfr_RET(a->mpfr_sign);
        }
      }
      else
        return MPFR_Lib_mpfr_RET(a->mpfr_sign);
    }
  }
}

int32_t
(*MPFR_mpfr_add1sp1)(
  MPFR_Lib_mpfr_struct *x0,
  MPFR_Lib_mpfr_struct *x1,
  MPFR_Lib_mpfr_struct *x2,
  MPFR_RoundingMode_mpfr_rnd_t x3,
  uint32_t x4
) = MPFR_Add1sp1_mpfr_add1sp1;

int32_t
(*MPFR_mpfr_mul_1)(
  MPFR_Lib_mpfr_struct *x0,
  MPFR_Lib_mpfr_struct *x1,
  MPFR_Lib_mpfr_struct *x2,
  MPFR_RoundingMode_mpfr_rnd_t x3,
  uint32_t x4
) = MPFR_Mul_1_mpfr_mul_1;

