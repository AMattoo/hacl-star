/* This file was auto-generated by KreMLin! */

#include "PKCS11_Mechanism.h"

bool isMechanismGeneration(mechanism m)
{
  if (m.tag == Generation)
    return true;
  else
    return false;
}

bool isMechanismFound(mechanism m)
{
  if (m.tag == NotFoundMechanism)
    return true;
  else
    return false;
}

uint32_t mechanismGetType(mechanism m)
{
  if (m.tag == Generation)
  {
    uint32_t identifier = m.case_Generation.mechanismID;
    return identifier;
  }
  else
    return (uint32_t)0U;
}

void (*mechanismGetFunctionGeneration(mechanism m))(uint8_t *x0, uint32_t x1)
{
  if (m.tag == Generation)
  {
    void (*f1)(uint8_t *x0, uint32_t x1) = m.case_Generation.m;
    return f1;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t mechanismRawGetTypeID(_CK_MECHANISM m)
{
  uint32_t t = m._type;
  return t;
}

_CK_VOID_PTR getMechanismRawParameters(_CK_MECHANISM m)
{
  _CK_VOID_PTR par = m.pParameter;
  return par;
}

uint32_t getMechanismRawParametersLen(_CK_MECHANISM m)
{
  uint32_t len = m.ulParameterLen;
  return len;
}

attribute_t *getAddressOfMechanismAttributes(mechanism m)
{
  if (m.tag == Generation)
  {
    attribute_t *attrs = m.case_Generation.attrs;
    return attrs;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t *getAddressOfMechanismRequiredAttributes(mechanism m)
{
  if (m.tag == Generation)
  {
    uint32_t *attrs = m.case_Generation.attributesRequired;
    return attrs;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t
*getMemoryIndexForMechanism__PKCS11_TypeDeclaration__CK_ULONG(
  uint32_t m,
  uint32_t *b,
  uint32_t len
)
{
  return b;
}

void mechanismLoadAttributes(mechanism m, uint32_t *b, uint32_t len)
{
  uint32_t
  *requestedParameters =
    getMemoryIndexForMechanism__PKCS11_TypeDeclaration__CK_ULONG(mechanismGetType(m),
      b,
      len);
  attribute_t
  attr =
    {
      .tag = CKA_CLASS,
      {
        .case_CKA_CLASS = {
          .typeId = (uint32_t)0U,
          .pValue = requestedParameters,
          .ulValueLength = (uint32_t)2U,
          .isReadOnly = false
        }
      }
    };
  attribute_t *stubForAttributes = getAddressOfMechanismAttributes(m);
  stubForAttributes[0U] = attr;
}

void mechanismGiveAttributesRequired(mechanism m, uint32_t *b, uint32_t len)
{
  uint32_t
  *requestedParameters =
    getMemoryIndexForMechanism__PKCS11_TypeDeclaration__CK_ULONG(mechanismGetType(m),
      b,
      len);
  attribute_t
  attr =
    {
      .tag = CKA_CLASS,
      {
        .case_CKA_CLASS = {
          .typeId = (uint32_t)0U,
          .pValue = requestedParameters,
          .ulValueLength = (uint32_t)2U,
          .isReadOnly = false
        }
      }
    };
  attribute_t *stubForAttributes = getAddressOfMechanismAttributes(m);
  stubForAttributes[0U] = attr;
}

attribute_t *mechanismAttributesProvidedList(mechanism m)
{
  return getAddressOfMechanismAttributes(m);
}

void mechanismLoadAttributesRequiredList(mechanism m, uint32_t *b, uint32_t len)
{
  uint32_t *address = getAddressOfMechanismRequiredAttributes(m);
  uint32_t
  *attrs =
    getMemoryIndexForMechanism__PKCS11_TypeDeclaration__CK_ULONG(mechanismGetType(m),
      b,
      len);
  uint32_t attr0 = attrs[0U];
  address[0U] = attr0;
}

