/* This file was auto-generated by KreMLin! */

#include "PKCS11_TypeDeclaration.h"

bool castableToBool(uint32_t length1)
{
  if (length1 > (uint32_t)0U && length1 % (uint32_t)4U == (uint32_t)0U)
    return true;
  else
    return false;
}

bool uu___is_CKA_CLASS(attribute_t projectee)
{
  if (projectee.tag == CKA_CLASS)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_CLASS__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_CLASS)
  {
    uint32_t typeId = projectee.case_CKA_CLASS.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t *__proj__CKA_CLASS__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_CLASS)
  {
    uint32_t *pValue = projectee.case_CKA_CLASS.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_CLASS__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_CLASS)
  {
    uint32_t ulValueLength = projectee.case_CKA_CLASS.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_CLASS__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_CLASS)
  {
    bool isReadOnly = projectee.case_CKA_CLASS.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_TOKEN(attribute_t projectee)
{
  if (projectee.tag == CKA_TOKEN)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_TOKEN__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_TOKEN)
  {
    uint32_t typeId = projectee.case_CKA_TOKEN.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_TOKEN__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_TOKEN)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_TOKEN.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_TOKEN__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_TOKEN)
  {
    uint32_t ulValueLength = projectee.case_CKA_TOKEN.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_TOKEN__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_TOKEN)
  {
    bool isReadOnly = projectee.case_CKA_TOKEN.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_PRIVATE(attribute_t projectee)
{
  if (projectee.tag == CKA_PRIVATE)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_PRIVATE__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_PRIVATE)
  {
    uint32_t typeId = projectee.case_CKA_PRIVATE.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_PRIVATE__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_PRIVATE)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_PRIVATE.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_PRIVATE__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_PRIVATE)
  {
    uint32_t ulValueLength = projectee.case_CKA_PRIVATE.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_PRIVATE__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_PRIVATE)
  {
    bool isReadOnly = projectee.case_CKA_PRIVATE.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_LABEL(attribute_t projectee)
{
  if (projectee.tag == CKA_LABEL)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_LABEL__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_LABEL)
  {
    uint32_t typeId = projectee.case_CKA_LABEL.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_LABEL__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_LABEL)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_LABEL.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_LABEL__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_LABEL)
  {
    uint32_t ulValueLength = projectee.case_CKA_LABEL.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_LABEL__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_LABEL)
  {
    bool isReadOnly = projectee.case_CKA_LABEL.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_APPLICATION(attribute_t projectee)
{
  if (projectee.tag == CKA_APPLICATION)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_APPLICATION__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_APPLICATION)
  {
    uint32_t typeId = projectee.case_CKA_APPLICATION.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_APPLICATION__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_APPLICATION)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_APPLICATION.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_APPLICATION__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_APPLICATION)
  {
    uint32_t ulValueLength = projectee.case_CKA_APPLICATION.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_APPLICATION__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_APPLICATION)
  {
    bool isReadOnly = projectee.case_CKA_APPLICATION.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_VALUE(attribute_t projectee)
{
  if (projectee.tag == CKA_VALUE)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_VALUE__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_VALUE)
  {
    uint32_t typeId = projectee.case_CKA_VALUE.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_VALUE__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_VALUE)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_VALUE.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_VALUE__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_VALUE)
  {
    uint32_t ulValueLength = projectee.case_CKA_VALUE.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_VALUE__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_VALUE)
  {
    bool isReadOnly = projectee.case_CKA_VALUE.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_OBJECT_ID(attribute_t projectee)
{
  if (projectee.tag == CKA_OBJECT_ID)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_OBJECT_ID__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_OBJECT_ID)
  {
    uint32_t typeId = projectee.case_CKA_OBJECT_ID.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_OBJECT_ID__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_OBJECT_ID)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_OBJECT_ID.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_OBJECT_ID__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_OBJECT_ID)
  {
    uint32_t ulValueLength = projectee.case_CKA_OBJECT_ID.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_OBJECT_ID__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_OBJECT_ID)
  {
    bool isReadOnly = projectee.case_CKA_OBJECT_ID.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_CERTIFICATE_TYPE(attribute_t projectee)
{
  if (projectee.tag == CKA_CERTIFICATE_TYPE)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_CERTIFICATE_TYPE__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_CERTIFICATE_TYPE)
  {
    uint32_t typeId = projectee.case_CKA_CERTIFICATE_TYPE.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_CERTIFICATE_TYPE__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_CERTIFICATE_TYPE)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_CERTIFICATE_TYPE.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_CERTIFICATE_TYPE__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_CERTIFICATE_TYPE)
  {
    uint32_t ulValueLength = projectee.case_CKA_CERTIFICATE_TYPE.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_CERTIFICATE_TYPE__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_CERTIFICATE_TYPE)
  {
    bool isReadOnly = projectee.case_CKA_CERTIFICATE_TYPE.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_ISSUER(attribute_t projectee)
{
  if (projectee.tag == CKA_ISSUER)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_ISSUER__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_ISSUER)
  {
    uint32_t typeId = projectee.case_CKA_ISSUER.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_ISSUER__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_ISSUER)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_ISSUER.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_ISSUER__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_ISSUER)
  {
    uint32_t ulValueLength = projectee.case_CKA_ISSUER.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_ISSUER__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_ISSUER)
  {
    bool isReadOnly = projectee.case_CKA_ISSUER.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_SERIAL_NUMBER(attribute_t projectee)
{
  if (projectee.tag == CKA_SERIAL_NUMBER)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_SERIAL_NUMBER__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_SERIAL_NUMBER)
  {
    uint32_t typeId = projectee.case_CKA_SERIAL_NUMBER.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_SERIAL_NUMBER__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_SERIAL_NUMBER)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_SERIAL_NUMBER.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_SERIAL_NUMBER__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_SERIAL_NUMBER)
  {
    uint32_t ulValueLength = projectee.case_CKA_SERIAL_NUMBER.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_SERIAL_NUMBER__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_SERIAL_NUMBER)
  {
    bool isReadOnly = projectee.case_CKA_SERIAL_NUMBER.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_KEY_TYPE(attribute_t projectee)
{
  if (projectee.tag == CKA_KEY_TYPE)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_KEY_TYPE__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_KEY_TYPE)
  {
    uint32_t typeId = projectee.case_CKA_KEY_TYPE.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_KEY_TYPE__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_KEY_TYPE)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_KEY_TYPE.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_KEY_TYPE__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_KEY_TYPE)
  {
    uint32_t ulValueLength = projectee.case_CKA_KEY_TYPE.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_KEY_TYPE__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_KEY_TYPE)
  {
    bool isReadOnly = projectee.case_CKA_KEY_TYPE.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_ID(attribute_t projectee)
{
  if (projectee.tag == CKA_ID)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_ID__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_ID)
  {
    uint32_t typeId = projectee.case_CKA_ID.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_ID__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_ID)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_ID.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_ID__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_ID)
  {
    uint32_t ulValueLength = projectee.case_CKA_ID.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_ID__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_ID)
  {
    bool isReadOnly = projectee.case_CKA_ID.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_SENSITIVE(attribute_t projectee)
{
  if (projectee.tag == CKA_SENSITIVE)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_SENSITIVE__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_SENSITIVE)
  {
    uint32_t typeId = projectee.case_CKA_SENSITIVE.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_SENSITIVE__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_SENSITIVE)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_SENSITIVE.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_SENSITIVE__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_SENSITIVE)
  {
    uint32_t ulValueLength = projectee.case_CKA_SENSITIVE.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_SENSITIVE__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_SENSITIVE)
  {
    bool isReadOnly = projectee.case_CKA_SENSITIVE.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_ENCRYPT(attribute_t projectee)
{
  if (projectee.tag == CKA_ENCRYPT)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_ENCRYPT__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_ENCRYPT)
  {
    uint32_t typeId = projectee.case_CKA_ENCRYPT.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool *__proj__CKA_ENCRYPT__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_ENCRYPT)
  {
    bool *pValue = projectee.case_CKA_ENCRYPT.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_ENCRYPT__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_ENCRYPT)
  {
    uint32_t ulValueLength = projectee.case_CKA_ENCRYPT.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_ENCRYPT__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_ENCRYPT)
  {
    bool isReadOnly = projectee.case_CKA_ENCRYPT.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_DECRYPT(attribute_t projectee)
{
  if (projectee.tag == CKA_DECRYPT)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_DECRYPT__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_DECRYPT)
  {
    uint32_t typeId = projectee.case_CKA_DECRYPT.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool *__proj__CKA_DECRYPT__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_DECRYPT)
  {
    bool *pValue = projectee.case_CKA_DECRYPT.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_DECRYPT__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_DECRYPT)
  {
    uint32_t ulValueLength = projectee.case_CKA_DECRYPT.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_DECRYPT__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_DECRYPT)
  {
    bool isReadOnly = projectee.case_CKA_DECRYPT.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_WRAP(attribute_t projectee)
{
  if (projectee.tag == CKA_WRAP)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_WRAP__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_WRAP)
  {
    uint32_t typeId = projectee.case_CKA_WRAP.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_WRAP__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_WRAP)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_WRAP.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_WRAP__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_WRAP)
  {
    uint32_t ulValueLength = projectee.case_CKA_WRAP.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_WRAP__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_WRAP)
  {
    bool isReadOnly = projectee.case_CKA_WRAP.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_UNWRAP(attribute_t projectee)
{
  if (projectee.tag == CKA_UNWRAP)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_UNWRAP__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_UNWRAP)
  {
    uint32_t typeId = projectee.case_CKA_UNWRAP.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_UNWRAP__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_UNWRAP)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_UNWRAP.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_UNWRAP__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_UNWRAP)
  {
    uint32_t ulValueLength = projectee.case_CKA_UNWRAP.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_UNWRAP__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_UNWRAP)
  {
    bool isReadOnly = projectee.case_CKA_UNWRAP.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_SIGN(attribute_t projectee)
{
  if (projectee.tag == CKA_SIGN)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_SIGN__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_SIGN)
  {
    uint32_t typeId = projectee.case_CKA_SIGN.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_SIGN__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_SIGN)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_SIGN.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_SIGN__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_SIGN)
  {
    uint32_t ulValueLength = projectee.case_CKA_SIGN.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_SIGN__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_SIGN)
  {
    bool isReadOnly = projectee.case_CKA_SIGN.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_CKA_VERIFY(attribute_t projectee)
{
  if (projectee.tag == CKA_VERIFY)
    return true;
  else
    return false;
}

uint32_t __proj__CKA_VERIFY__item__typeId(attribute_t projectee)
{
  if (projectee.tag == CKA_VERIFY)
  {
    uint32_t typeId = projectee.case_CKA_VERIFY.typeId;
    return typeId;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__CKA_VERIFY__item__pValue(attribute_t projectee)
{
  if (projectee.tag == CKA_VERIFY)
  {
    _CK_VOID_PTR pValue = projectee.case_CKA_VERIFY.pValue;
    return pValue;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__CKA_VERIFY__item__ulValueLength(attribute_t projectee)
{
  if (projectee.tag == CKA_VERIFY)
  {
    uint32_t ulValueLength = projectee.case_CKA_VERIFY.ulValueLength;
    return ulValueLength;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool __proj__CKA_VERIFY__item__isReadOnly(attribute_t projectee)
{
  if (projectee.tag == CKA_VERIFY)
  {
    bool isReadOnly = projectee.case_CKA_VERIFY.isReadOnly;
    return isReadOnly;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_MkKey(key_t projectee)
{
  return true;
}

uint8_t *__proj__MkKey__item__key(key_t projectee)
{
  key_t scrut = projectee;
  uint8_t *key = scrut.key;
  return key;
}

bool *__proj__MkKey__item__data(key_t projectee)
{
  key_t scrut = projectee;
  bool *data = scrut.data;
  return data;
}

bool uu___is_Generation(mechanism projectee)
{
  if (projectee.tag == Generation)
    return true;
  else
    return false;
}

uint32_t __proj__Generation__item__mechanismID(mechanism projectee)
{
  if (projectee.tag == Generation)
  {
    uint32_t mechanismID = projectee.case_Generation.mechanismID;
    return mechanismID;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

void (*__proj__Generation__item__m(mechanism projectee))(uint8_t *x0, uint32_t x1)
{
  if (projectee.tag == Generation)
  {
    void (*m)(uint8_t *x0, uint32_t x1) = projectee.case_Generation.m;
    return m;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

_CK_VOID_PTR __proj__Generation__item__pParameters(mechanism projectee)
{
  if (projectee.tag == Generation)
  {
    _CK_VOID_PTR pParameters = projectee.case_Generation.pParameters;
    return pParameters;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__Generation__item__ulParameterLen(mechanism projectee)
{
  if (projectee.tag == Generation)
  {
    uint32_t ulParameterLen = projectee.case_Generation.ulParameterLen;
    return ulParameterLen;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

attribute_t *__proj__Generation__item__attrs(mechanism projectee)
{
  if (projectee.tag == Generation)
  {
    attribute_t *attrs = projectee.case_Generation.attrs;
    return attrs;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__Generation__item__attributesLen(mechanism projectee)
{
  if (projectee.tag == Generation)
  {
    uint32_t attributesLen = projectee.case_Generation.attributesLen;
    return attributesLen;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t *__proj__Generation__item__attributesRequired(mechanism projectee)
{
  if (projectee.tag == Generation)
  {
    uint32_t *attributesRequired = projectee.case_Generation.attributesRequired;
    return attributesRequired;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

uint32_t __proj__Generation__item__attributesRequiredList(mechanism projectee)
{
  if (projectee.tag == Generation)
  {
    uint32_t attributesRequiredList = projectee.case_Generation.attributesRequiredList;
    return attributesRequiredList;
  }
  else
  {
    printf("KreMLin abort at %s:%d\n%s\n", __FILE__, __LINE__, "no else in F*");
    exit(255U);
  }
}

bool uu___is_NotFoundMechanism(mechanism projectee)
{
  if (projectee.tag == NotFoundMechanism)
    return true;
  else
    return false;
}

bool uu___is_AttributeRaw(_CK_ATTRIBUTE projectee)
{
  return true;
}

uint32_t __proj__AttributeRaw__item___type(_CK_ATTRIBUTE projectee)
{
  _CK_ATTRIBUTE scrut = projectee;
  uint32_t _type = scrut._type;
  return _type;
}

_CK_VOID_PTR __proj__AttributeRaw__item__pValue(_CK_ATTRIBUTE projectee)
{
  _CK_ATTRIBUTE scrut = projectee;
  _CK_VOID_PTR pValue = scrut.pValue;
  return pValue;
}

uint32_t __proj__AttributeRaw__item__ulValueLen(_CK_ATTRIBUTE projectee)
{
  _CK_ATTRIBUTE scrut = projectee;
  uint32_t ulValueLen = scrut.ulValueLen;
  return ulValueLen;
}

bool uu___is_MechanismRaw(_CK_MECHANISM projectee)
{
  return true;
}

uint32_t __proj__MechanismRaw__item___type(_CK_MECHANISM projectee)
{
  _CK_MECHANISM scrut = projectee;
  uint32_t _type = scrut._type;
  return _type;
}

_CK_VOID_PTR __proj__MechanismRaw__item__pParameter(_CK_MECHANISM projectee)
{
  _CK_MECHANISM scrut = projectee;
  _CK_VOID_PTR pParameter = scrut.pParameter;
  return pParameter;
}

uint32_t __proj__MechanismRaw__item__ulParameterLen(_CK_MECHANISM projectee)
{
  _CK_MECHANISM scrut = projectee;
  uint32_t ulParameterLen = scrut.ulParameterLen;
  return ulParameterLen;
}

uint32_t main()
{
  return (uint32_t)10U;
}

