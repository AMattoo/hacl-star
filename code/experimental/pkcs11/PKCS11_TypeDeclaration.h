/* This file was auto-generated by KreMLin! */
#include "kremlib.h"
#ifndef __PKCS11_TypeDeclaration_H
#define __PKCS11_TypeDeclaration_H


#include "PKCS11_DateTime.h"


typedef uint32_t _CK_ULONG;

typedef uint32_t _CK_ATTRIBUTE_TYPE;

typedef uint32_t _CK_MECHANISM_TYPE;

typedef uint32_t _CK_SESSION_HANDLE;

typedef uint32_t _CK_OBJECT_HANDLE;

typedef uint32_t _CK_RV;

typedef uint8_t *bytes;

typedef uint64_t int0;

extern bool *ptrCastToBool(_CK_VOID_PTR x0);

bool castableToBool(uint32_t length1);

typedef enum {
  CKA_CLASS,
  CKA_TOKEN,
  CKA_PRIVATE,
  CKA_LABEL,
  CKA_APPLICATION,
  CKA_VALUE,
  CKA_OBJECT_ID,
  CKA_CERTIFICATE_TYPE,
  CKA_ISSUER,
  CKA_SERIAL_NUMBER,
  CKA_KEY_TYPE,
  CKA_ID,
  CKA_SENSITIVE,
  CKA_ENCRYPT,
  CKA_DECRYPT,
  CKA_WRAP,
  CKA_UNWRAP,
  CKA_SIGN,
  CKA_VERIFY
}
attribute_t_tags;

typedef struct 
{
  attribute_t_tags tag;
  union {
    struct 
    {
      uint32_t typeId;
      uint32_t *pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_CLASS;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_TOKEN;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_PRIVATE;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_LABEL;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_APPLICATION;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_VALUE;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_OBJECT_ID;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_CERTIFICATE_TYPE;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_ISSUER;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_SERIAL_NUMBER;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_KEY_TYPE;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_ID;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_SENSITIVE;
    struct 
    {
      uint32_t typeId;
      bool *pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_ENCRYPT;
    struct 
    {
      uint32_t typeId;
      bool *pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_DECRYPT;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_WRAP;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_UNWRAP;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_SIGN;
    struct 
    {
      uint32_t typeId;
      _CK_VOID_PTR pValue;
      uint32_t ulValueLength;
      bool isReadOnly;
    }
    case_CKA_VERIFY;
  }
  ;
}
attribute_t;

bool uu___is_CKA_CLASS(attribute_t projectee);

uint32_t __proj__CKA_CLASS__item__typeId(attribute_t projectee);

uint32_t *__proj__CKA_CLASS__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_CLASS__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_CLASS__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_TOKEN(attribute_t projectee);

uint32_t __proj__CKA_TOKEN__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_TOKEN__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_TOKEN__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_TOKEN__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_PRIVATE(attribute_t projectee);

uint32_t __proj__CKA_PRIVATE__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_PRIVATE__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_PRIVATE__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_PRIVATE__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_LABEL(attribute_t projectee);

uint32_t __proj__CKA_LABEL__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_LABEL__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_LABEL__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_LABEL__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_APPLICATION(attribute_t projectee);

uint32_t __proj__CKA_APPLICATION__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_APPLICATION__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_APPLICATION__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_APPLICATION__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_VALUE(attribute_t projectee);

uint32_t __proj__CKA_VALUE__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_VALUE__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_VALUE__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_VALUE__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_OBJECT_ID(attribute_t projectee);

uint32_t __proj__CKA_OBJECT_ID__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_OBJECT_ID__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_OBJECT_ID__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_OBJECT_ID__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_CERTIFICATE_TYPE(attribute_t projectee);

uint32_t __proj__CKA_CERTIFICATE_TYPE__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_CERTIFICATE_TYPE__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_CERTIFICATE_TYPE__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_CERTIFICATE_TYPE__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_ISSUER(attribute_t projectee);

uint32_t __proj__CKA_ISSUER__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_ISSUER__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_ISSUER__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_ISSUER__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_SERIAL_NUMBER(attribute_t projectee);

uint32_t __proj__CKA_SERIAL_NUMBER__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_SERIAL_NUMBER__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_SERIAL_NUMBER__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_SERIAL_NUMBER__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_KEY_TYPE(attribute_t projectee);

uint32_t __proj__CKA_KEY_TYPE__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_KEY_TYPE__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_KEY_TYPE__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_KEY_TYPE__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_ID(attribute_t projectee);

uint32_t __proj__CKA_ID__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_ID__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_ID__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_ID__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_SENSITIVE(attribute_t projectee);

uint32_t __proj__CKA_SENSITIVE__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_SENSITIVE__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_SENSITIVE__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_SENSITIVE__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_ENCRYPT(attribute_t projectee);

uint32_t __proj__CKA_ENCRYPT__item__typeId(attribute_t projectee);

bool *__proj__CKA_ENCRYPT__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_ENCRYPT__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_ENCRYPT__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_DECRYPT(attribute_t projectee);

uint32_t __proj__CKA_DECRYPT__item__typeId(attribute_t projectee);

bool *__proj__CKA_DECRYPT__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_DECRYPT__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_DECRYPT__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_WRAP(attribute_t projectee);

uint32_t __proj__CKA_WRAP__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_WRAP__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_WRAP__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_WRAP__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_UNWRAP(attribute_t projectee);

uint32_t __proj__CKA_UNWRAP__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_UNWRAP__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_UNWRAP__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_UNWRAP__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_SIGN(attribute_t projectee);

uint32_t __proj__CKA_SIGN__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_SIGN__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_SIGN__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_SIGN__item__isReadOnly(attribute_t projectee);

bool uu___is_CKA_VERIFY(attribute_t projectee);

uint32_t __proj__CKA_VERIFY__item__typeId(attribute_t projectee);

_CK_VOID_PTR __proj__CKA_VERIFY__item__pValue(attribute_t projectee);

uint32_t __proj__CKA_VERIFY__item__ulValueLength(attribute_t projectee);

bool __proj__CKA_VERIFY__item__isReadOnly(attribute_t projectee);

typedef bool *flags_t;

typedef struct 
{
  uint8_t *key;
  bool *data;
}
key_t;

bool uu___is_MkKey(key_t projectee);

uint8_t *__proj__MkKey__item__key(key_t projectee);

bool *__proj__MkKey__item__data(key_t projectee);

typedef enum { Generation, NotFoundMechanism } mechanism_tags;

typedef struct 
{
  mechanism_tags tag;
  union {
    struct 
    {
      uint32_t mechanismID;
      void (*m)(uint8_t *x0, uint32_t x1);
      _CK_VOID_PTR pParameters;
      uint32_t ulParameterLen;
      attribute_t *attrs;
      uint32_t attributesLen;
      uint32_t *attributesRequired;
      uint32_t attributesRequiredList;
    }
    case_Generation;
  }
  ;
}
mechanism;

bool uu___is_Generation(mechanism projectee);

uint32_t __proj__Generation__item__mechanismID(mechanism projectee);

void (*__proj__Generation__item__m(mechanism projectee))(uint8_t *x0, uint32_t x1);

_CK_VOID_PTR __proj__Generation__item__pParameters(mechanism projectee);

uint32_t __proj__Generation__item__ulParameterLen(mechanism projectee);

attribute_t *__proj__Generation__item__attrs(mechanism projectee);

uint32_t __proj__Generation__item__attributesLen(mechanism projectee);

uint32_t *__proj__Generation__item__attributesRequired(mechanism projectee);

uint32_t __proj__Generation__item__attributesRequiredList(mechanism projectee);

bool uu___is_NotFoundMechanism(mechanism projectee);

typedef struct 
{
  uint32_t _type;
  _CK_VOID_PTR pValue;
  uint32_t ulValueLen;
}
_CK_ATTRIBUTE;

bool uu___is_AttributeRaw(_CK_ATTRIBUTE projectee);

uint32_t __proj__AttributeRaw__item___type(_CK_ATTRIBUTE projectee);

_CK_VOID_PTR __proj__AttributeRaw__item__pValue(_CK_ATTRIBUTE projectee);

uint32_t __proj__AttributeRaw__item__ulValueLen(_CK_ATTRIBUTE projectee);

typedef struct 
{
  uint32_t _type;
  _CK_VOID_PTR pParameter;
  uint32_t ulParameterLen;
}
_CK_MECHANISM;

bool uu___is_MechanismRaw(_CK_MECHANISM projectee);

uint32_t __proj__MechanismRaw__item___type(_CK_MECHANISM projectee);

_CK_VOID_PTR __proj__MechanismRaw__item__pParameter(_CK_MECHANISM projectee);

uint32_t __proj__MechanismRaw__item__ulParameterLen(_CK_MECHANISM projectee);

uint32_t main();
#endif
